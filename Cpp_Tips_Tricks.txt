0.  What are Classes
1.  Using namespace std;
2.  How to split a string
3.  Use of cin ignore
4.  Why to use nested class
5.  NULL pointer - nullptr
6.  Print contents of a vector:
7.  Convert string to Upper Case:
8.  Switch can't be used on strings:
9.  Copy String to Char array
10.  Char * vs Char []
11.  Char * assignment
12.  Passing Array requires number of elements. Arrays decay into pointers.
13.  Deleting Array of objects using delete[]. delete[] vs delete
13b. What happens on delete
13c. Is there delete in Java
14.  Setting pointers to NULL after delete
15.  cout << new int[0] << endl; Allocating new with size 0
16.  Default value of a boolean in a struct
17.  Clearing a Char array in C
18.  Re-declaration of default parameter
19.  IMP: Char array vs NULL terminated String
     C FAQs
19b.  Why should SCANF never be used
19c.  But I heard that char a[] was identical to char *a.
20a. Comparing String in C++
20b.  Find Substring
21.  Combining vector of strings:
22.  Convert String to Int - C++
22a. Concatenate String with Int
22b. Convert INT to STRING
23.  Align std out
24.  IMP: Why Pointers
25.  Garbage Collection:
26.  C++ References:
26b. When to use References vs. Pointers
27.  Smart Pointer:
28.  C++ Cast:
28b. Static Cast vs Dynamic Cast vs Regular Cast
28c. Static Cast vs Dynamic Cast
29.  C++ to Java:
30.  Finding all subsets of a Vector of Vector
31.  double vs float
32.  C++ Count occurrences of a char
33.  C++ Cin:
34.  C++ Empty String:
35.  Stack Unwinding
36.  RAII:
37.  Branch Prediction:
38.  Monitors in C++
39.  PThreads:
40.  Convert Vector to Array and Array to Vector
41.  Initialization of a normal array with one default value
42.  Templates: Template keyword vs Class keyword
43.  comparing int with size_t
44.  Unicode vs Ascii
45.  Where are Class Members stored in memory
45b. Memory Layout - Code Segment Data Segment Stack Heap
45c. ELF and how it is used for compiling and linking
     How are the different segments like heap, stack, text related to the physical memory
45d. What is a Symbol Table
46.  C++ Class vs C Struct Memory Layout
47.  Pass by Value vs Const Reference
47b. Why is Pass by Value faster than Pass by reference
48.  Virtual Function and Pure Virtual Functions
49.  Virtual Functions
49b. How Virtual Functions Work
50.  new vs new()
51.  Reading Multiple words from cin
52.  Reading multiple lines from cin
53.  Using size_t for loops
54.  size_t vs size_type
55.  File IO
57.  Meaning of const
57a. Const vs ReadOnly
57b. Const in C vs C++
58.  Reason to pass a pointer by reference
59.  Returning by reference:
60.  Sorting a vector of objects
61.  Find rightmost set bit
62.  #define vs typedef vs Enum
62a. C++ Const vs #Define
62a. C++ semantics of `static const` vs `const`
62b. C++ Const Read Only
62b. Const defaults to Internal Linkage in C++ and External Linkage in C
62c. When to use unnamed namespace
62d. Superiority of unnamed namespace over static
63.  Dynamic Array in C++
63b. TWOD Vector in C++
64.  Time in C++
65.  Ordered Data Set
66.  Tail Recursion
67.  Extern Variable; Static vs Extern
68.  vector<bool> vs bitset
69.  Reading from file, donot use EOF for checking
70.  Struct assignment vs memcpy
71.  Why 2's complement is used to represent negative numbers
72.  Extern Linkage and Intern linkage and NO linkage
73.  How a Computer Compiles and Executes a C++ Program
74.  When / Why to use stringstream
75.  Steps involved for execution of a C program
75a. Storage Classes - Static, Extern, Auto and Register
76.  Abstract Class vs Interface
77.  Can abstract class be instantiated
78.  C++ new int[0] - will it allocate memory
79.  C++ new vs C malloc
80.  How is memory allocated to Vectors
81.  Where Global Variables and Pointers are stored
82.  Where are the Variable Names stored in memory
82b. Where in memory are return values stored in memory
83.  What is Type Safe
84.  What is the name of the --> operator
85.  Why is ::operator new[] necessary when ::operator new is enough
86.  Allocator vs New
87.  What is RTTI and Why is it necessary
88.  When to use static methods
89.  Freeing memory twice
90.  C++ Memory management New operator vs Operator new 
91.  STACK VS HEAP
92.  Different behavior of Code Valid in C and C++
93.  Case Only Labels: Jumping over initialization
94.  What uses are there for placement new?
95.  Is there a "placement delete"?
96a. What is a smart pointer and when should I use one
96b.  Auto, Unique, Shared Pointers, Weak Pointers and Scoped Pointers
96c. When is std::weak_ptr useful
96c. Scoped Pointer vs Unique Pointer
97.  Vector - Accessing member elements using "at()" vs "[]"
98.  Created Vectors of User defined size
99.  How to use memset or fill_n to initialize a dynamic two dimensional TwoD array in C++
100. Unique Lock
101. Condition Variable
102. Lock_guard vs Unique_lock
103. Recursive Mutex
104. Lock vs Mutex vs Condition Variable
105. Need for THIS Pointer
106. Sort Unordered Map
107. IMP: Using [] operator in unordered_map inserts the element if not present.
108. Create a vector of userdefined size and initialize with default values
108b. Create a vector with an element using constructor
109. Copy from one vector to another
110. Copy Constructor vs Assignment Operator:
111. Volatile keyword:
112. How do you declare an interface in C++
113. Multiple Inheritence in C++
114. Exception handling in C++
115. Side effects of macros:
116. Macros vs Inline Function:
117. What is Arithmetic Overflow and Underflow
118. How to detect integer overflow in C/C++
119. Usage of Templates Function and Class
120. Passing a 2D array to a C++ function
121. Custom Comparator for Priority Queue
122. C++ Erase vector element by value rather than by position
123. Function Pointers and Callbacks
123b. How do function pointers in C work
124. Registering a Callback
125. Functors in C++ 
126. Operator Overloading in C++
127. Scope Guard in C++
128. C++11 introduced a standardized memory model. What does it mean?
129. When is void* useful
130. Virtual Destructor in C++
131. Print Unordered Map. Get key and get value
132. Self Referential Structures
133. How to use std::sort to sort a vector
134. Queue vs Vector
135. Differences between various Custom Comparator functions in C++ 
136. Creating a Vector and bitset on heap
137. Custom Hash Function
138. Fastest way to reset every value of std::vector<int> to 0
139. Using find_first_not_of and find_first_of
140. Best way to extract a subvector from a vector?
141. Running GDB on mac
142. C++ enable/disable debug messages of std::couts on the fly
143. Why use apparently meaningless do-while and if-else statements in C/C++ macros
144. Printing lists with commas C++
145. Nested Class Access Specifiers
146. Forward Declarations
147. Access Specifier: Public, Private, Default
148. What is std::move
149. Why is sizeof empty class 1
150. Use of std::endl vs \n
------------------------------------------------------------------------------------------
0. 
What are Classes
    Classes are a collection of functions which operate on data.

1.
Using namespace std;
http://stackoverflow.com/questions/1452721/why-is-using-namespace-std-considered-bad-practice
    Say you have,
    using namespace foo; has function foos()
        using namespace bar; has function bars()

    In version 2.0, foo comes up with a function bars(). Then we will end up calling the other function.
    So use foo::foos(), bar::bars()

2. 
How to split a string
http://stackoverflow.com/questions/236129/split-a-string-in-c
    
    #include <string>
    #include <sstream>
    #include <vector>

    std::vector<std::string> &split(const std::string &s, char delim, std::vector<std::string> &elems) {
        std::stringstream ss(s);
        std::string item;
        while (std::getline(ss, item, delim)) {
            elems.push_back(item);
        }
        return elems;
    }

    std::vector<std::string> split(const std::string &s, char delim)
    {
        std::vector<std::string> elems;
        split(s, delim, elems);
        return elems;
    }

    void splitStringByPatternString(const string& s, const string& pattern, vector<string>& words)
    {
        int startIndex = 0;
        unordered_set<char> patternSet;

        for (char c : pattern)
        {
            patternSet.insert(c);
        }

        for(int i = 0; i < s.length(); i++)
        {
            // If the character is present in the pattern, the split the word
            if (patternSet.find(s[i]) != patternSet.end())
            {
                if (startIndex != i)
                {
                    words.push_back(s.substr(startIndex, i - startIndex));
                    startIndex = i + 1;
                }
                else
                {
                    ++startIndex;
                }
            }
        }
    }

    void splitStringIntoWords(const string& s, vector<string>& words)
    {
        int startIndex = 0;
        
        for(int i = 0; i < s.length(); i++)
        {
            if (s[i] == ' ' || ispunct(s[i]))
            {
                if (startIndex != i)
                {
                    words.push_back(s.substr(startIndex, i - startIndex));
                    startIndex = i + 1;
                }
                else
                {
                    ++startIndex;
                }
            }
        }
    }

C++ Find Substring using a pattern
http://stackoverflow.com/questions/14265581/parse-split-a-string-in-c-using-string-delimiter-standard-c

    Parsing with a single char delimiter is fine. But what if I want to use a string as delimiter.
    Example: I want to split:
    scott>=tiger
    with >= as delimiter so that I can get scott and tiger.

    You can use the std::string::find() function to find the position of your string delimiter, then use std::string::substr() to get a token.
    Example:
    std::string s = "scott>=tiger";
    std::string delimiter = ">=";
    std::string token = s.substr(0, s.find(delimiter)); // token is "scott"
    The find(const string& str, size_t pos = 0) function returns the position of the first occurrence of str in the string, or npos if the string is not found.
    The substr(size_t pos = 0, size_t n = npos) function returns a substring of the object, starting at position pos and of length npos

3. 
Use of cin ignore
http://stackoverflow.com/questions/25475384/when-and-why-do-i-need-to-use-cin-ignore-in-c
http://stackoverflow.com/questions/5131647/why-would-we-call-cin-clear-and-cin-ignore-after-reading-input

        cin.ignore(256, '\n');

        // cin returns false if an input operation fails, that is, if
        // something other than an int (the type of input_var) is entered.
        while (!(cin >> input_var)) {
          cout << "Please enter numbers only." << endl;
          cin.clear();              // Both lines are very important
          cin.ignore(10000,'\n'); 
        }

    The cin.clear() clears the error flag on cin (so that future I/O operations will work correctly), and then
    cin.ignore(10000, '\n') skips to the next newline (to ignore anything else on the same line as the non-number so that it does not cause another parse failure).
    It will only skip up to 10000 characters, so the code is assuming the user will not put in a very long, invalid line.

        cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

    Essentially, for std::cin statements you use ignore before you do a getline call, because when a user inputs something with std::cin, they hit enter and a '\n' char gets into the cin buffer.
    Then if you use getline, it gets the newline char instead of the string you want.
    So you do a std::cin.ignore(1000,'\n') and that should clear the buffer up to the string that you want.
    (The 1000 is put there to skip over a specific amount of chars before the specified break point, in this case, the \n newline character.)

    std::ws
    Discards leading whitespace from an input stream.
        std::istringstream s("     this is a test");
        std::string line;
        getline(s >> std::ws, line);
        std::cout << "ws + getline returns: \"" << line << "\"\n";

4. 
Why to use nested class
http://stackoverflow.com/questions/4571355/why-would-one-use-nested-classes-in-c

    Cool to hide implementation details:
    class List
    {
        public:
            List(): head(NULL), tail(NULL) {}
        private:
            class Node
            {
                  public:
                      int   data;
                      Node* next;
                      Node* prev;
            };
        private:
            Node*     head;
            Node*     tail;
    };

5. 
NULL pointer - nullptr
http://stackoverflow.com/questions/1282295/what-exactly-is-nullptr
http://stackoverflow.com/questions/20509734/null-vs-nullptr-why-was-it-replaced?lq=1

    nullptr is always a pointer type. 0 (aka. C's NULL bridged over into C++) could cause ambiguity in overloaded function resolution, among other things:
    f(int);
    f(foo *);

6. 
Print contents of a vector:
http://stackoverflow.com/questions/10750057/c-printing-out-the-contents-of-a-vector

    Solution 1:
    for (std::vector<char>::const_iterator i = path.begin(); i != path.end(); ++i)
        std::cout << *i << ' ';

    Solution 2:
    for (auto i = path.begin(); i != path.end(); ++i)
        std::cout << *i << ' ';

7. 
Convert string to Upper Case:
http://stackoverflow.com/questions/735204/convert-a-string-in-c-to-upper-case

    #include <algorithm>
    #include <string>

    std::string str = "Hello World";
    std::transform(str.begin(), str.end(),str.begin(), ::toupper);

8. 
Switch can't be used on strings:
http://stackoverflow.com/questions/650162/why-switch-statement-cannot-be-applied-on-strings

    The reason why has to do with the type system. C/C++ doesn't really support strings as a type.
    It does support the idea of a constant char array but it doesn't really fully understand the notion of a string. 

9. 
Copy String to Char array
http://stackoverflow.com/questions/13294067/how-to-convert-string-to-char-array-in-c

        string tmp = "cat";
        char tab2[1024];
        strcpy(tab2, tmp.c_str());

    For safety, you might prefer:
        string tmp = "cat";
        char tab2[1024];
        strncpy(tab2, tmp.c_str(), sizeof(tab2));
        tab2[sizeof(tab2) - 1] = 0;

10.
Char * vs Char []
http://stackoverflow.com/questions/1704407/what-is-the-difference-between-char-s-and-char-s-in-c

        char *s = "Hello world";
    will place Hello world in the read-only parts of the memory and making s a pointer to that, making any writing operation on this memory illegal. While doing:
        char s[] = "Hello world";
    puts the literal string in read-only memory and copies the string to newly allocated memory on the stack. Thus making
        s[0] = 'J';
    legal.

    First off, in function arguments, they are exactly equivalent:
        void foo(char *x);
        void foo(char x[]); // exactly the same in all respects (note! this only applies if the brackets are empty)

    char s[] = "hello";
    Creates one object - a char array of size 6, called s, initialised with the values 'h', 'e', 'l', 'l', 'o', '\0'.
    Where this array is allocated in memory, and how long it lives for, depends on where the declaration appears.
    If the declaration is within a function, it will live until the end of the block that it is declared in, and almost certainly be allocated on the stack; if it's outside a function, it will probably be stored within an "initialised data segment" that is loaded from the executable file into writeable memory when the program is run.

    On the other hand, this declaration:
        char *s ="hello";
    Creates two objects:
        a read-only array of 6 chars containing the values 'h', 'e', 'l', 'l', 'o', '\0', which has no name and has static storage duration (meaning that it lives for the entire life of the program); and
        a variable of type pointer-to-char, called s, which is initialised with the location of the first character in that unnamed, read-only array.

    The unnamed read-only array is typically located in the "text" segment of the program, which means it is loaded from disk into read-only memory, along with the code itself.
    The location of the s pointer variable in memory depends on where the declaration appears (just like in the first example)

11.
Char * assignment
http://stackoverflow.com/questions/20944784/why-is-conversion-from-string-constant-to-char-valid-in-c-but-invalid-in-c

        char* p = "abc"; // valid in C, invalid in C++
    It uses a deprecated implicit conversion--a string literal should be treated as being of type char const *, since you can't modify its contents

12.
Passing Array requires number of elements. Arrays decay into pointers.
http://stackoverflow.com/questions/2559896/how-are-arrays-passed

    They are passed as pointers. This means that all information about the array size is lost.

13. 
Deleting Array of objects using delete[]. delete[] vs delete
http://stackoverflow.com/questions/703691/how-does-delete-know-its-an-array
http://stackoverflow.com/questions/197675/how-does-delete-know-the-size-of-the-operand-array?lq=1

    The compiler doesn't know it's an array, it's trusting the programmer. Deleting a pointer to a single int with delete [] would result in undefined behavior.

        Foo* set = new Foo[100];
        // ...
        delete [] set;

    When you allocate memory on the heap, your allocator will keep track of how much memory you have allocated.
    This is usually stored in a "head" segment just before the memory that you get allocated.
    That way when it's time to free the memory, the de-allocator knows exactly how much memory to free.

    If the runtime libraries (not the OS, really) can keep track of the number of things in the array, then why do we need the delete[] syntax at all? Why can't a single delete form be used to handle all deletes?
        The answer to this goes back to C++'s roots as a C-compatible language (which it no longer really strives to be.)
        Stroustrup's philosophy was that the programmer should not have to pay for any features that they aren't using.
        If they're not using arrays, then they should not have to carry the cost of object arrays for every allocated chunk of memory.

        That is, if your code simply does
            Foo* foo = new Foo;

        then the memory space that's allocated for foo shouldn't include any extra overhead that would be needed to support arrays of Foo.

        Since only array allocations are set up to carry the extra array size information, you then need to tell the runtime libraries to look for that information when you delete the objects.
        That's why we need to use
            delete[] bar;

        instead of just
            delete bar;

        if bar is a pointer to an array.

13b.
What happens on delete
http://stackoverflow.com/questions/11603005/what-does-delete-command-really-do-for-memory-for-pointers-in-c

    Think of memory as a big warehouse with lots of boxes to put things into.
    When you call "new", the warehouse staff finds an unused box large enough for your needs, records that box as being owned by you (so it's not given to someone else), and gives you the number of that box so you can put your stuff into it.
    This number would be the "pointer".

    Now, when you "delete" that pointer, the reverse happens: the warehouse staff notes that this particular box is available again.
    Contrary to real warehouse staff they aren't doing anything with the box — so if you look into it after a "delete" you might see your old stuff.
    Or you might see somebody else’s stuff, if the box was reassigned in the meantime.

    Technically, you are not allowed to look into your box once you have returned it to the pool, but this is a somewhat weird warehouse with no keys or guards, so you can still do whatever you want.
    However, it might cause problems with the new owner of the box, so it's expected that you follow the rules.

13c.
Is there delete in Java

    Java has no delete.
    We just set the object to NULL.
    Once the reference count has become zero the garbage collector will destroy the object.

14.
Setting pointers to NULL after delete
http://stackoverflow.com/questions/1931126/is-it-good-practice-to-null-a-pointer-after-deleting-it
http://stackoverflow.com/questions/9169774/what-happens-in-a-double-delete

    Double delete causes an undefined behavior. So setting a pointer to NULL will overcome that.
    Deleting a NULL pointer is a Void operation

    Setting a pointer to 0 (which is "null" in standard C++, the NULL define from C is somewhat different) avoids crashes on double deletes.
    Consider the following:
        Foo* foo = 0; // Sets the pointer to 0 (C++ NULL)
        delete foo; // Won't do anything
    Whereas:
        Foo* foo = new Foo();
        delete foo; // Deletes the object
        delete foo; // Undefined behavior

    Under the hood, any memory manager has to maintain some metadata about each block of data it allocates, in a way that allows it to look up the metadata from the pointer that malloc/new returned.
    Typically this takes the form of a structure at fixed offset before the allocated block.
    This structure can contain a "magic number" -- a constant that is unlikely to occur by pure chance.
    If the memory manager sees the magic number in the expected place, it knows that the pointer provided to free/delete is most likely valid.
    If it doesn't see the magic number, or if it sees a different number that means "this pointer was recently freed", it can either silently ignore the free request, or it can print a helpful message and abort.
    Either is legal under the spec, and there are pro/con arguments to either approach.

    If the memory manager doesn't keep a magic number in the metadata block, or doesn't otherwise check the sanity of the metadata, then anything can happen.
    Depending on how the memory manager is implemented, the result is most likely a crash without a helpful message, either immediately in the memory manager logic, somewhat later the next time the memory manager tries to allocate or free memory, or much later and far away when two different parts of the program each think they have ownership of the same chunk of memory.

15.
cout << new int[0] << endl; Allocating new with size 0
http://stackoverflow.com/questions/1087042/c-new-int0-will-it-allocate-memory

    When the value of the expression in a direct-new-declarator is zero, the allocation function is called to allocate an array with no elements.

    From 3.7.3.1/2
        The effect of dereferencing a pointer returned as a request for zero size is undefined.

        That means you can do it, but you can not legally (in a well defined manner across all platforms) dereference the memory that you get - you can only pass it to array delete - and you should delete it.

16.
Default value of a boolean in a struct
http://stackoverflow.com/questions/3845353/what-will-be-the-default-value-of-an-uninitialized-boolean-value-in-c
http://stackoverflow.com/questions/16782103/initializing-default-values-in-a-struct

    The value of the bool will is undefined. It will be whatever else was on the stack before it, which is sometimes zeroed out if nothing has used it previously.
    But again, it is undefined, which means it can be either true or false.
    If you need a default value, you can do:
        struct fool_bool {
          bool b1;
          bool b2;
          fool_bool() {
            b1 = true;
            b2 = false;
        }  };

    In C++ 11 default value can be given inside the struct itself:
        struct foo {
            bool a = true;
            bool b = true;
            bool c;
         } bar;

17.
Clearing a Char array in C
http://stackoverflow.com/questions/632846/clearing-a-char-array-c

    It depends on how you want to view the array. If you are viewing the array as a series of char's then the only way to clear out the data is to touch every entry.
    memset is probably the most effective way to achieve this.
    On the other hand if you are choosing to view this as a C/C++ null terminated string, setting the first byte to 0 will effectively clear the string.

        memset(&arr[0], 0, sizeof(arr));
    This is generally the fastest way to take care of this. If you can use C++, consider std::fill instead:
        char *begin = &arr;
        char *end = begin + sizeof(arr);
        std::fill(begin, end, 0);

18.
Re-declaration of default parameter
http://stackoverflow.com/questions/6210450/the-compiler-is-complaining-about-my-default-parameters

    You have to specify the default values for the arguments only in the declaration but not in the definition.
        class pBase : public sf::Thread {
             // ....
             void setColor( int _color = -1 );
             // ....
         } ;

         void pBase:: setColor( int _color )
         {
             // ....
         }

19.
IMP: Char array vs NULL terminated String
http://stackoverflow.com/questions/11229477/are-all-char-arrays-automatically-null-terminated
http://stackoverflow.com/questions/12019947/null-termination-of-char-array

    VERY NICE LINK. Read all examples here
http://c-faq.com/charstring/index.html

    Only string literals get null-terminated, and that means that char x[]="asdf" is an array of 5 elements.
    char arrays are not automatically NULL terminated

    Also, WE have to make sure there is space for NULL character.
    If you type more than four characters then the extra characters and the null terminator will be written outside the end of the array, overwriting memory not belonging to the array.
    This is a buffer overflow.

Q1:
    Why doesn't strcat(string, '!'); work?

A1:
    There is a very real difference between characters and strings, and strcat concatenates strings.

    A character constant like '!' represents a single character.
    A string literal between double quotes usually represents multiple characters.
    A string literal like "!" seems to represent a single character, but it actually contains two: the ! you requested, and the \0 which terminates all strings in C.

    Characters in C are represented by small integers corresponding to their character set values (see also question 8.6).
    Strings are represented by arrays of characters; you usually manipulate a pointer to the first character of the array.
    It is never correct to use one when the other is expected. To append a ! to a string, use
        strcat(string, "!");

Q2:
     I'm checking a string to see if it matches a particular value. Why isn't this code working?

        char *string;
        ...
        if(string == "value") {
            /* string matches "value" */
            ...
        }

A2:
    Strings in C are represented as arrays of characters, and C never manipulates (assigns, compares, etc.) arrays as a whole.
    The == operator in the code fragment above compares two pointers--the value of the pointer variable string and a pointer to the string literal "value"--to see if they are equal, that is, if they point to the same place.
    They probably don't, so the comparison never succeeds.

    To compare two strings, you generally use the library function strcmp:
        if(strcmp(string, "value") == 0) {
            /* string matches "value" */
            ...
        }

Q3:
    If I can say 
        char a[] = "Hello, world!";

    why can't I say
        char a[14];
        a = "Hello, world!";

A3:
    Strings are arrays, and you can't assign arrays directly. Use strcpy instead:
        strcpy(a, "Hello, world!");

Q4:
    I can't get strcat to work. I tried
        char *s1 = "Hello, ";
        char *s2 = "world!";
        char *s3 = strcat(s1, s2);

    but I got strange results.

A4:
    The main problem here is that space for the concatenated result is not properly allocated.
    C does not provide an automatically-managed string type.
    C compilers allocate memory only for objects explicitly mentioned in the source code (in the case of strings, this includes character arrays and string literals).
    The programmer must arrange for sufficient space for the results of run-time operations such as string concatenation, typically by declaring arrays, or by calling malloc.

    strcat performs no allocation; the second string is appended to the first one, in place.
    The first (destination) string must be writable and have enough room for the concatenated result.
    Therefore, one fix would be to declare the first string as an array:

        char s1[20] = "Hello, ";

    Since strcat returns the value of its first argument (s1, in this case), the variable s3 in the question above is superfluous; after the call to strcat, s1 contains the result.

    The original call to strcat in the question actually has two problems: the string literal pointed to by s1, besides not being big enough for any concatenated text, is not necessarily writable at all.

Q5.
    I'm reading strings typed by the user into an array, and then printing them out later.
    When the user types a sequence like \n, why isn't it being handled properly?

A5:
    Character sequences like \n are interpreted at compile time.
    When a backslash and an adjacent n appear in a character constant or string literal, they are translated immediately into a single newline character.
    (Analogous translations occur, of course, for the other character escape sequences.)
    When you're reading strings from the user or a file, however, no interpretation like this is performed: a backslash is read and printed just like any other character, with no particular interpretation.

Q6: C vs C++
    I think something's wrong with my compiler: I just noticed that sizeof('a') is 2, not 1 (i.e. not sizeof(char)).

A6:
    Perhaps surprisingly, character constants in C are of type int, so sizeof('a') is sizeof(int) (though this is another area where C++ differs)

19b.
Why should SCANF never be used
http://stackoverflow.com/questions/12019947/null-termination-of-char-array

    This is a great example of why scanf("%s") is dangerous and should never be used.
    It doesn't know about the size of your array which means there is no way to use it safely.
    Instead, avoid scanf and use something safer, like fgets():

        fgets() reads in at most one less than size characters from stream and stores them into the buffer pointed to by s.
        Reading stops after an EOF or a newline.
        If a newline is read, it is stored into the buffer.
        A terminating null byte ('\0') is stored after the last character in the buffer.

19c.
But I heard that char a[] was identical to char *a.
http://c-faq.com/aryptr/aryptr2.html
       - The array declaration char a[6] requests that space for six characters be set aside, to be known by the name ``a''.
         That is, there is a location named ``a'' at which six characters can sit
       - The pointer declaration char *p, on the other hand, requests a place which holds a pointer, to be known by the name ``p''.
       - VERY IMP: ``pointer arithmetic and array indexing [that] are equivalent in C, pointers and arrays are different.'')

    3. If they're so different, then why are array and pointer declarations interchangeable as function formal parameters? 
       - Since arrays decay immediately into pointers, an array is never actually passed to a function.

20a.
Comparing String in C++
http://stackoverflow.com/questions/9158894/differences-between-c-string-and-compare

        std::string::compare() returns an int:

        - equal to zero if s and t are equal,
        - less than zero if s is less than t,
        - greater than zero if s is greater than t.

    If you want your first code snippet to be equivalent to the second one, it should actually read:

    if (!s.compare(t)) {
        // 's' and 't' are equal.
    }

    The equality operator only tests for equality (hence its name) and returns a bool

20b.
Find Substring
http://www.cplusplus.com/reference/string/string/substr/

    std::string str="We think in generalities, but we live in details.";
                                               // (quoting Alfred N. Whitehead)

    std::string str2 = str.substr (3,5);     // "think"

    std::size_t pos = str.find("live");      // position of "live" in str

    std::string str3 = str.substr (pos);     // get from "live" to the end


21.
Combining vector of strings:
http://stackoverflow.com/questions/1985978/combining-a-vector-of-strings

    Use accumulate
        int main () {
            string str = "Hello World!";
            vector<string>  vec (10,str);
            string a = accumulate( vec.begin(), vec.end(), string("") );
            cout << a << endl;

22.
Convert String to Int - C++
http://stackoverflow.com/questions/7663709/convert-string-to-int-c

    In C++11 there are some nice new convert functions from std::string to a number type.
    So instead of
        atoi( str.c_str() )
    you can use
        std::stoi( str )
    where str is your number as std::string.

    There are version for all flavours of numbers:
        long stol(string), float stof(string), double stod(string)

22a.
Concatenate String with Int
http://stackoverflow.com/questions/191757/c-concatenate-string-and-int

    std::string name = "John";
    int age = 21;
    std::string result;

    // 1. with Boost
    result = name + boost::lexical_cast<std::string>(age);

    // 2. with C++11
    result = name + std::to_string(age);

22b.
Convert INT to STRING

    string strNum = to_string(number);

23.
Align std out
http://stackoverflow.com/questions/2485963/c-alignment-when-printing-cout

    The ISO C++ standard way to do it is to #include <iomanip> and use io manipulators like std::setw
    However, that said, those io manipulators are a real pain to use even for text, and are just about unusable for formatting numbers

24.
IMP: Why Pointers
http://stackoverflow.com/questions/22146094/why-should-i-use-a-pointer-rather-than-the-object-itself

    I'm coming from a Java background and have started working with objects in C++.
    But one thing that occurred to me is that people often use pointers to objects rather than the objects themselves, for example this declaration:
        Object *myObject = new Object;
    rather than:
        Object myObject;

    Or instead of using a function, let's say testFunc(), like this:
        myObject.testFunc();
    we have to write:
        myObject->testFunc();

    You have two questions bundled up into one. The first is when should we use dynamic allocation (using new)? The second is when should we use pointers?
    The important take-home message is that you should always use the appropriate tool for the job.
    In almost all situations, there is something more appropriate and safer than performing manual dynamic allocation and/or using raw pointers.

    Dynamic allocation
        In your question, you've demonstrated two ways of creating an object. The main difference is the storage duration of the object.
        When doing Object myObject; within a block, the object is created with automatic storage duration, which means it will be destroyed automatically when it goes out of scope.
        When you do new Object(), the object has dynamic storage duration, which means it stays alive until you explicitly delete it.
        You should only use dynamic storage duration when you need it. That is, you should always prefer creating objects with automatic storage duration when you can.

        The main two situations in which you might require dynamic allocation:
            1. You need the object to outlive the current scope - that specific object at that specific memory location, not a copy of it.
               If you're okay with copying/moving the object (most of the time you should be), you should prefer an automatic object.

            2. You need to allocate a lot of memory, which may easily fill up the stack.
               It would be nice if we didn't have to concern ourselves with this (most of the time you shouldn't have to), as it's really outside the purview of C++, but unfortunately we have to deal with the reality of the systems we're developing for.

        When you do absolutely require dynamic allocation, you should encapsulate it in a smart pointer or some other type that performs RAII (like the standard containers).
        Smart pointers provide ownership semantics of dynamically allocated objects.
        Take a look at std::unique_ptr and std::shared_ptr, for example.
        If you use them appropriately, you can almost entirely avoid performing your own memory management (see the Rule of Zero).

    Pointers
        However, there are other more general uses for raw pointers beyond dynamic allocation, but most have alternatives that you should prefer.
        As before, always prefer the alternatives unless you really need pointers.

     1. You need reference semantics.
        Sometimes you want to pass an object using a pointer (regardless of how it was allocated) because you want the function to which you're passing it to have access that that specific object (not a copy of it).
        However, in most situations, you should prefer reference types to pointers, because this is specifically what they're designed for.
        Note this is not necessarily about extending the lifetime of the object beyond the current scope, as in situation 1 above.
        As before, if you're okay with passing a copy of the object, you don't need reference semantics.

     2. You need polymorphism.
        You can only call functions polymorphically (that is, according to the dynamic type of an object) through a pointer or reference to the object.
        If that's the behaviour you need, then you need to use pointers or references.
        Again, references should be preferred.

     3. You want to represent that an object is optional by allowing a nullptr to be passed when the object is being omitted.
        If it's an argument, you should prefer to use default arguments or function overloads.
        Otherwise, you should prefer use a type that encapsulates this behaviour, such as boost::optional (or perhaps soon, std::optional - Edit std::optional is voted out of the current C++14 draft n3797).

     4. You want to decouple compilation units to improve compilation time.
        The useful property of a pointer is that you only require a forward declaration of the pointed-to type (to actually use the object, you'll need a definition).
        This allows you to decouple parts of your compilation process, which may significantly improve compilation time.
        See the Pimpl idiom.

     5. You need to interface with a C library or a C-style library.
        At this point, you're forced to use raw pointers.
        The best thing you can do is make sure you only let your raw pointers loose at the last possible moment.
        You can get a raw pointer from a smart pointer, for example, by using its get member function.
        If a library performs some allocation for you which it expects you to deallocate via a handle, you can often wrap the handle up in a smart pointer with a custom deleter that will deallocate the object appropriately.

25.
Garbage Collection:
http://stackoverflow.com/questions/5009869/how-to-implement-garbage-collection-in-c?lq=1

    Garbage collection in C and C++ are both difficult topics for a few reasons:

    1. Pointers can be typecast to integers and vice-versa.
    This means that I could have a block of memory that is reachable only by taking an integer, typecasting it to a pointer, then dereferencing it.
    A garbage collector has to be careful not to think a block is unreachable when indeed it still can be reached.

    2. Pointers are not opaque. Many garbage collectors, like stop-and-copy collectors, like to move blocks of memory around or compact them to save space.
    Since you can explicitly look at pointer values in C and C++, this can be difficult to implement correctly.
    You would have to be sure that if someone was doing something tricky with typecasting to integers that you correctly updated the integer if you moved a block of memory around.

    3. Memory management can be done explicitly. Any garbage collector will need to take into account that the user is able to explicitly free blocks of memory at any time.

    4. In C++, there is a separation between allocation/deallocation and object construction/destruction.
    A block of memory can be allocated with sufficient space to hold an object without any object actually being constructed there.
    A good garbage collector would need to know, when it reclaims memory, whether or not to call the destructor for any objects that might be allocated there.
    This is especially true for the standard library containers, which often make use of std::allocator to use this trick for efficiency reasons.

    5. Memory can be allocated from different areas.
    C and C++ can get memory either from the built-in freestore (malloc/free or new/delete), or from the OS via mmap or other system calls, and, in the case of C++, from get_temporary_buffer or return_temporary_buffer.
    The programs might also get memory from some third-party library.
    A good garbage collector needs to be able to track references to memory in these other pools and (possibly) would have to be responsible for cleaning them up.

    6. Pointers can point into the middle of objects or arrays.
    In many garbage-collected languages like Java, object references always point to the start of the object.
    In C and C++ pointers can point into the middle of arrays, and in C++ into the middle of objects (if multiple inheritance is used). This can greatly complicate the logic for detecting what's still reachable.

    So, in short, it's extremely hard to build a garbage collector for C or C++.
    Most libraries that do garbage collection in C and C++ are extremely conservative in their approach and are technically unsound - they assume that you won't, for example, take a pointer, cast it to an integer, write it to disk, and then load it back in at some later time.
    They also assume that any value in memory that's the size of a pointer could possibly be a pointer, and so sometimes refuse to free unreachable memory because there's a nonzero chance that there's a pointer to it.

    As others have pointed out, the Boehm GC does do garbage collection for C and C++, but subject to the aforementioned restrictions.

    Interestingly, C++11 includes some new library functions that allow the programmer to mark regions of memory as reachable and unreachable in anticipation of future garbage collection efforts.
    It may be possible in the future to build a really good C++11 garbage collector with this sort of information.
    In the meantime though, you'll need to be extremely careful not to break any of the above rules.

26.
C++ References:
http://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in?rq=1

    Summary from answers and links below:
        A pointer can be re-assigned any number of times while a reference can not be re-seated after binding.

    A pointer can be re-assigned:
        int x = 5;
        int y = 6;
        int *p;
        p =  &x;
        p = &y;
        *p = 10;
        assert(x == 5);
        assert(y == 10);

    A reference cannot, and must be assigned at initialization:
        int x = 5;
        int y = 6;
        int &r = x;

    Pointers can point nowhere (NULL), whereas reference always refer to an object.
        int *p = NULL;
        int &r = NULL; <--- compiling error

    You can't take the address of a reference like you can with pointers.
    A pointer has its own memory address and size on the stack (4 bytes on x86), whereas a reference shares the same memory address (with the original variable) but also takes up some space on the stack.
    Since a reference has the same address as the original variable itself, it is safe to think of a reference as another name for the same variable.

    There's no "reference arithmetics" (but you can take the address of an object pointed by a reference and do pointer arithmetics on it as in &obj + 5).

26b.
When to use References vs. Pointers
http://stackoverflow.com/questions/7058339/when-to-use-references-vs-pointers
http://stackoverflow.com/questions/21884825/reference-vs-pointer

    A pointer is the address of the memory location.
    You can change the value of that address to point at different memory addresses.

    A reference is an alias of the variable.
    You can only assign this alias during declaration.
    You cannot change which variable the reference is an alias of after it's declared.

    The following pointer assignments are not possible with references.
        int a = 10;
        int b = 20;

        int* pInt = NULL; // A pointer pointing at nothing.
        pInt = &a; // pInt now points at a
        pInt = &b; // pInt now points at b

    As for which one is better, it all depends on context.
    I use references for method and function parameters.
        void updateFoo(Foo& foo)

    I use references to alias complex objects.
        Foo& foo = bar.getBaz().getFoo(); // easy access to foo

    I use pointers for dynamically allocated objects.
        Foo* pFoo = new Foo();

    New returns a pointer of whatever type you used to allocate space in memory, not a void*
         auto p1 = new int[5];   // returns a pointer to an int pointing to the 1st element
         auto p2 = new short[5]; // returns a pointer to a short pointing to the 1st element

    I use pointers for things which may point at different values (including no value at all).
        Foo* pFoo = NULL;

        if (condition1)
            pFoo = &foo1;
        else (condition2)
            pFoo = &foo2;

    As a general rule, I default to references and use pointers in places where the limitations on references cause problems.

    - Use reference wherever you can, pointers wherever you must.
    - Avoid pointers until you can't.

    The reason is that pointers make things harder to follow/read, less safe and far more dangerous manipulations than any other constructs.

    So the rule of thumb is to use pointers only if there is no other choice.

    For example, returning a pointer to an object is a valid option when the function can return nullptr in some cases and it is assumed it will.
    That said, a better option would be to use something similar to boost::optional.

    Another example is to use pointers to raw memory for specific memory manipulations.
    That should be hidden and localized in very narrow parts of the code, to help limit the dangerous parts of the whole code base.

    In your example, there is no point in using a pointer as argument because:
        1. if you provide nullptr as the argument, you're going in undefined-behaviour-land;
        2. the reference attribute version doesn't allow (without easy to spot tricks) the problem with 1.
        3. the reference attribute version is simpler to understand for the user: you have to provide a valid object, not something that could be null.

    If the behaviour of the function would have to work with or without a given object, then using a pointer as attribute suggests that you can pass nullptr as the argument and it is fine for the function.
    That's kind of a contract between the user and the implementation.

27.
Smart Pointer:
http://stackoverflow.com/questions/106508/what-is-a-smart-pointer-and-when-should-i-use-one
http://ootips.org/yonat/4dev/smart-pointers.html

    The simplest example of a smart pointer is auto_ptr, which is included in the standard C++ library.
    You can find it in the header <memory>, or take a look at Scott Meyers' auto_ptr implementation.
    Here is part of auto_ptr's implementation, to illustrate what it does:
        template <class T> class auto_ptr
        {
            T* ptr;
        public:
            explicit auto_ptr(T* p = 0) : ptr(p) {}
            ~auto_ptr()                 {delete ptr;}
            T& operator*()              {return *ptr;}
            T* operator->()             {return ptr;}
            // ...
        };

    As you can see, auto_ptr is a simple wrapper around a regular pointer.
    It forwards all meaningful operations to this pointer (dereferencing and indirection).
    Its smartness in the destructor: the destructor takes care of deleting the pointer.
    For the user of auto_ptr, this means that instead of writing:

        void foo()
        {
            MyClass* p(new MyClass);
            p->DoSomething();
            delete p;
        }

    You can write:
        void foo()
        {
            auto_ptr<MyClass> p(new MyClass);
            p->DoSomething();
        }
    And trust p to cleanup after itself. 

28.
C++ Cast:
http://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used?rq=1

    static_cast is the first cast you should attempt to use.
        It does things like implicit conversions between types (such as int to float, or pointer to void*), and it can also call explicit conversion functions (or implicit ones).
        In many cases, explicitly stating static_cast isn't necessary, but it's important to note that the T(something) syntax is equivalent to (T)something and should be avoided (more on that later).
        A T(something, something_else) is safe, however, and guaranteed to call the constructor.
        static_cast can also cast through inheritance hierarchies. It is unnecessary when casting upwards (towards a base class), but when casting downwards it can be used as long as it doesn't cast through virtual inheritance.
        It does not do checking, however, and it is undefined behavior to static_cast down a hierarchy to a type that isn't actually the type of the object.

    const_cast can be used to remove or add const to a variable; no other C++ cast is capable of removing it (not even reinterpret_cast).
        It is important to note that modifying a formerly const value is only undefined if the original variable is const; if you use it to take the const off a reference to something that wasn't declared with const, it is safe.
        This can be useful when overloading member functions based on const, for instance.
        It can also be used to add const to an object, such as to call a member function overload.
        const_cast also works similarly on volatile, though that's less common.

        const_cast is safe only if you're casting a variable that was originally non-const.
        For example, if you have a function that takes a parameter of a const char *, and you pass in a modifiable char *, it's safe to const_cast that parameter back to a char * and modify it.
        However, if the original variable was in fact const, then using const_cast will result in undefined behavior.

            void func(const char *param, size_t sz, bool modify)
            {
                if(modify)
                    strncpy(const_cast<char *>(param), sz, "new string");
                printf("param: %s\n", param);
            }

            ...

            char buffer[16];
            const char *unmodifiable = "string constant";
            func(buffer, sizeof(buffer), true);  // OK
            func(unmodifiable, strlen(unmodifiable), false); // OK
            func(unmodifiable, strlen(unmodifiable), true);  // UNDEFINED BEHAVIOR

    dynamic_cast is almost exclusively used for handling polymorphism.
        You can cast a pointer or reference to any polymorphic type to any other class type (a polymorphic type has at least one virtual function, declared or inherited).
        You can use it for more than just casting downwards -- you can cast sideways or even up another chain.
        The dynamic_cast will seek out the desired object and return it if possible.
        If it can't, it will return nullptr in the case of a pointer, or throw std::bad_cast in the case of a reference.
        dynamic_cast has some limitations, though. It doesn't work if there are multiple objects of the same type in the inheritance hierarchy (the so-called 'dreaded diamond') and you aren't using virtual inheritance.
        It also can only go through public inheritance - it will always fail to travel through protected or private inheritance.
        This is rarely an issue, however, as such forms of inheritance are rare.

    reinterpret_cast is the most dangerous cast, and should be used very sparingly.
        It turns one type directly into another - such as casting the value from one pointer to another, or storing a pointer in an int, or all sorts of other nasty things.
        Largely, the only guarantee you get with reinterpret_cast is that normally if you cast the result back to the original type, you will get the exact same value (but not if the intermediate type is smaller than the original type).
        There are a number of conversions that reinterpret_cast cannot do, too.
        It's used primarily for particularly weird conversions and bit manipulations, like turning a raw data stream into actual data, or storing data in the low bits of an aligned pointer.

        All reinterpret_cast does is allow you to read the memory you passed in a different way.
        You give it a memory location and you ask it to read that memory as if it was what you asked it to.
        This is why it can only be used with pointers and references.

        Let's take this code as an example:
            #include <iostream>
            int main()
            {
                float a = 12;
                int b = *reinterpret_cast<int*>(&a);

                std::cout << b;
            }

        So to break this line of code into more details *reinterpret_cast<int*>(&a);:
            Take the reference of a
            reinterpret_cast to an int*
            Get back an int* that points to a
            Deference the value of the returned pointer as int

28b. 
Static Cast vs Reinterpret Cast
http://stackoverflow.com/questions/18544849/how-to-use-reinterpret-cast-in-c

    static_casting a pointer to and from void* preserves the address.
    That is, in the following, a, b and c all point to the same address:

        int* a = new int();
        void* b = static_cast<void*>(a);
        int* c = static_cast<int*>(b);

    reinterpret_cast only guarantees that if you cast a pointer to a different type, and then reinterpret_cast it back to the original type, you get the original value.

    So in the following:
        int* a = new int();
        void* b = reinterpret_cast<void*>(a);
        int* c = reinterpret_cast<int*>(b);

    a and c contain the same value, but the value of b is unspecified.
    (in practice it will typically contain the same address as a and c, but that's not specified in the standard, and it may not be true on machines with more complex memory systems.)

    For casting to and from void*, static_cast should be preferred.

28c.
Static Cast vs Dynamic Cast vs Regular Cast
http://stackoverflow.com/questions/2253168/dynamic-cast-and-static-cast-in-c
IMP Regular Cast vs Static Cast:
http://stackoverflow.com/questions/28002/regular-cast-vs-static-cast-vs-dynamic-cast

    REGULAR CAST:            
        - These casts are also called C-style cast.
        - A C-style cast is basically identical to trying out a range of sequences of C++ casts, and taking the first C++ cast that works, without ever considering dynamic_cast.
        - Needless to say, this is much more powerful as it combines all of const_cast, static_cast and reinterpret_cast, but it's also unsafe, because it does not use dynamic_cast.

        - In addition, C-style casts not only allow you to do this, but they also allow you to safely cast to a private base-class, while the "equivalent" static_cast sequence would give you a compile-time error for that.

        - Some people prefer C-style casts because of their brevity.
        - I use them for numeric casts only, and use the appropriate C++ casts when user defined types are involved, as they provide stricter checking.
        - C-style casts are a mix of const and reinterpret cast, and it's difficult to find-and-replace in your code. A C++ application programmer should avoid C-style cast.

static_cast< Type* >(ptr):
    This takes the pointer in ptr and tries to safely cast it to a pointer of type Type*.
    This cast is done at compile time.
    It will only perform the cast if the type types are related.
    If the types are not related, you will get a compiler error.

    For example:
        class B {};
        class D : public B {};
        class X {};

        int main()
        {
          D* d = new D;
          B* b = static_cast<B*>(d); // this works
          X* x = static_cast<X*>(d); // ERROR - Won't compile
          return 0;
        }

dynamic_cast< Type* >(ptr):
    This again tries to take the pointer in ptr and safely cast it to a pointer of type Type*.
    But this cast is executed at runtime, not compile time.
    Because this is a run-time cast, it is useful especially when combined with polymorphic classes.
    In fact, in certian cases the classes must be polymorphic in order for the cast to be legal.

    Casts can go in one of two directions: from base to derived (B2D) or from derived to base (D2B).
    It's simple enough to see how D2B casts would work at runtime.
    Either ptr was derived from Type or it wasn't.
    In the case of D2B dynamic_cast<>s, the rules are simple.
    You can try to cast anything to anything else, and if ptr was in fact derived from Type, you'll get a Type* pointer back from dynamic_cast.
    Otherwise, you'll get a NULL pointer.

    But B2D casts are a little more complicated. Consider the following code:
        #include <iostream>
        using namespace std;

        class Base
        {
        public:
            virtual void DoIt() = 0;    // pure virtual
            virtual ~Base() {};
        };

        class Foo : public Base
        {
        public:
            virtual void DoIt() { cout << "Foo"; }; 
            void FooIt() { cout << "Fooing It..."; }
        };

        class Bar : public Base
        {
        public :
            virtual void DoIt() { cout << "Bar"; }
            void BarIt() { cout << "baring It..."; }
        };

        Base* CreateRandom()
        {
            if( (rand()%2) == 0 )
                return new Foo;
            else
                return new Bar;
        }

        int main()
        {
            for( int n = 0; n < 10; ++n )
            {
                Base* base = CreateRandom();

                    base->DoIt();

                Bar* bar = (Bar*)base;
                bar->BarIt();
            }
          return 0;
        }

    main() can't tell what kind of object CreateRandom() will return, so the C-style cast Bar* bar = (Bar*)base; is decidedly not type-safe.
    How could you fix this? One way would be to add a function like bool AreYouABar() const = 0; to the base class and return true from Bar and false from Foo.
    But there is another way: use dynamic_cast<>:

        int main()
        {
            for( int n = 0; n < 10; ++n )
            {
                Base* base = CreateRandom();

                base->DoIt();

                Bar* bar = dynamic_cast<Bar*>(base);
                Foo* foo = dynamic_cast<Foo*>(base);
                if( bar )
                    bar->BarIt();
                if( foo )
                    foo->FooIt();
            }
          return 0;

        }

    The casts execute at runtime, and work by querying the object (no need to worry about how for now), asking it if it the type we're looking for.
    If it is, dynamic_cast<Type*> returns a pointer; otherwise it returns NULL.

    In order for this base-to-derived casting to work using dynamic_cast<>, Base, Foo and Bar must be what the Standard calls polymorphic types.
    In order to be a polymorphic type, your class must have at least one virtual function.
    If your classes are not polymorphic types, the base-to-derived use of dynamic_cast will not compile.

    Example:
        class Base {};
        class Der : public Base {};

        int main()
        {
            Base* base = new Der;
            Der* der = dynamic_cast<Der*>(base); // ERROR - Won't compile

            return 0;
        }

    Adding a virtual function to base, such as a virtual dtor, will make both Base and Der polymorphic types:
        class Base 
        {
        public:
            virtual ~Base(){};
        };
        class Der : public Base {};


        int main()
        {
            Base* base = new Der;
            Der* der = dynamic_cast<Der*>(base); // OK

            return 0;
        }

http://stackoverflow.com/questions/28002/regular-cast-vs-static-cast-vs-dynamic-cast
    Examples of static_cast and/vs dynamic_cast

        If we have the following classes

            class B {};
            class D : B {};

        then you can do the following
            B* b = new D();
            D* d1 = static_cast<D*>b; // Valid! d1 is a valid and correct pointer to a D
            D* d2 = dynamic_cast<D*>b; // Valid! d2 is a valid and correct pointer to a D

        In this example, both pointers d1 and d2 will point to a correctly typed version of b as requested.

        A potential for mishap where static_cast can be more unsafe than dynamic_cast is illustrated by the following example:
            B* b = new B();
            D* d1 = static_cast<D*>b; // works, but D component is invalid!
            D* d2 = dynamic_cast<D*>b; // cast fails => d2 is now a nullptr

        Now d1 will point to a data segment of type D*, but the actual data is B*, so attempting to access D-specific member is undefined behaviour.
        d2, on the other hand, will be a nullptr and can be checked and handled correctly (i.e. do not try to use it as a D if it failed to convert).

        Because dynamic_cast performs runtime type checking, it is slower, but whether this matters to your application should be checked by benchmarking.

29.
C++ to Java:
http://stackoverflow.com/questions/5732224/just-enough-java-for-hadoop

31.
double vs float
http://stackoverflow.com/questions/2386772/difference-between-float-and-double
http://programmers.stackexchange.com/questions/188721/when-do-you-use-float-and-when-do-you-use-double

    - As the name implies, a double has 2x the precision of float[1]. In general a double has 15 to 16 decimal digits of precision, while float only has 7
    - Also, the maximum value of float is only about 3e38, but double is about 1.7e308, so using float can hit Infinity much easier than double for something simple e.g. computing 60!

    float should only be used if you need to operate on a lot of floating-point numbers (think in the order of thousands or more) and analysis of the algorithm has shown that the reduced range and accuracy don't pose a problem.

    long double can be used if you need more range or accuracy than double, and if it provides this on your target platform.

    In summary, float and long double should be reserved for use by the specialists, with double for "every-day" use.

Double Float Comparison
http://stackoverflow.com/questions/17333/most-effective-way-for-float-and-double-comparison
    bool AreSame(double a, double b)
    {
        return fabs(a - b) < EPSILON;
    }

32.
C++ Count occurrences of a char
http://stackoverflow.com/questions/3867890/count-character-occurrences-in-a-string

    How can I count the number of "_" in a string like "bla_bla_blabla_bla"

    #include <algorithm>

    std::string s = "a_b_c";
    size_t n = std::count(s.begin(), s.end(), '_');

33.
C++ Cin:
How to include White space using Cin
http://stackoverflow.com/questions/2765462/how-to-cin-space-in-c
http://stackoverflow.com/questions/5838711/c-cin-input-with-spaces

    It skips all whitespace (spaces, tabs, new lines, etc.) by default.
    You can either change its behavior, or use a slightly different mechanism.
    To change its behavior, use the manipulator noskipws, as follows:

        cin >> noskipws >> a[i];
    But, since you seem like you want to look at the individual characters, I'd suggest using get, like this prior to your loop
        cin.get( a, n );

    #include <iostream>
    #include <string>
    int main()
    {
       std::string a;
       std::getline(std::cin,a);
       for(std::string::size_type i = 0; i < a.size(); ++i)
       {
           if(a[i] == ' ')
              std::cout<<"It is a space!!!"<<std::endl;
       }

    int main()
    {
       std::string name, title;

       std::cout << "Enter your name: ";
       std::getline(std::cin, name);

       std::cout << "Enter your favourite movie: ";
       std::getline(std::cin, title);

       std::cout << name << "'s favourite movie is " << title;
    }

34.
C++ Empty String:
http://stackoverflow.com/questions/26310772/why-an-empty-string-can-output-index-0-element-in-c
http://stackoverflow.com/questions/17997204/does-an-empty-string-contain-an-empty-string-in-c

    #include<iostream>
    #include<string>

    using std::string;
    using std::cout;
    using std::endl;

    int main()
    {
        string s;
        cout << s.size() << endl;
        cout << s[0] << endl;  //output empty line
        return 0;
    }

    There's a special rule that you can access s[n] where n is the length of s.
    The result is a null character (i.e. the value that results from value-initializing the character type) and attempting to modify it causes undefined behaviour

35.
Stack Unwinding
http://stackoverflow.com/questions/2331316/what-is-stack-unwinding

    Stack unwinding is usually talked about in connection with exception handling. Here's an example:
        void func( int x )
        {
            char* pleak = new char[1024]; // might be lost => memory leak
            std::string s( "hello world" ); // will be properly destructed

            if ( x ) throw std::runtime_error( "boom" );

            delete [] pleak; // will only get here if x == 0. if x!=0, throw exception
        }

        int main()
        {
            try
            {
                func( 10 );
            }
            catch ( const std::exception& e )
            {
                return 1;
            }

            return 0;
        }

    Here memory allocated for pleak will be lost if exception is thrown, while memory allocated to s will be properly released by std::string destructor in any case.
    The objects allocated on the stack are "unwound" when the scope is exited (here the scope is of the function func.)
    This is done by the compiler inserting calls to destructors of automatic (stack) variables.
    Now this is a very powerful concept leading to the technique called RAII, that is Resource Acquisition Is Initialization, that helps us manage resources like memory, database connections, open file descriptors, etc. in C++.

    The process of removing function entries from function call stack at run time is called Stack Unwinding.
    Stack Unwinding is generally related to Exception Handling.
    In C++, when an exception occurs, the function call stack is linearly searched for the exception handler, and all the entries before the function with exception handler are removed from the function call stack.
    So exception handling involves Stack Unwinding if exception is not handled in same function (where it is thrown).

    For example, output of the following program is:
         f3() Start
         f2() Start
         f1() Start
         Caught Exception: 100
         f3() End

        #include <iostream>
        using namespace std;
         
        // A sample function f1() that throws an int exception 
        void f1() throw (int) {
          cout<<"\n f1() Start ";
          throw 100;
          cout<<"\n f1() End "; 
        }
         
        // Another sample function f2() that calls f1()
        void f2() throw (int) {
          cout<<"\n f2() Start ";
          f1();
          cout<<"\n f2() End ";
        }
          
        // Another sample function f3() that calls f2() and handles exception thrown by f1()
        void f3() {
          cout<<"\n f3() Start ";
          try {
            f2();
          }
          catch(int i) {
           cout<<"\n Caught Exception: "<<i;
          }
          cout<<"\n f3() End";
        }
         
        // A driver function to demonstrate Stack Unwinding  process
        int main() {
          f3();
          
          getchar();
          return 0;
        } 

36.
RAII:
http://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii
http://www.tomdalling.com/blog/software-design/resource-acquisition-is-initialisation-raii-explained/
http://stackoverflow.com/questions/6500313/why-should-c-programmers-minimize-use-of-new?rq=1

    Smart pointers will use the RAII philosophy to ensure that heap allocated objects are destroyed any time the pointer variable is destroyed.
    Smart pointer is a variation of RAII. RAII means resource acquisition is initialization.
    Smart pointer acquires a resource (memory) before usage and then throws it away automatically in a destructor.

    In C++ there's a neat construct called a destructor.
    This mechanism allows you to manage resources by aligning the lifetime of the resource with the lifetime of a variable.

    It's a really terrible name for an incredibly powerful concept, and perhaps one of the number 1 things that C++ developers miss when they switch to other languages.
    There has been a bit of a movement to try to rename this concept as Scope-Bound Resource Management, though it doesn't seem to have caught on just yet.

    When we say 'Resource' we don't just mean memory - it could be file handles, network sockets, database handles, GDI objects.
    In short, things that we have a finite supply of and so we need to be able to control their usage.
    The 'Scope-bound' aspect means that the lifetime of the object is bound to the scope of a variable, so when the variable goes out of scope then the destructor will release the resource.
    A very useful property of this is that it makes for greater exception-safety. For instance, compare this:

        RawResourceHandle* handle=createNewResource();
        handle->performInvalidOperation();  // Oops, throws exception
        ...
        deleteResource(handle); // oh dear, never gets called so the resource leaks

    With the RAII one
        class ManagedResourceHandle {
        public:
           ManagedResourceHandle(RawResourceHandle* rawHandle_) : rawHandle(rawHandle_) {};
           ~ManagedResourceHandle() {delete rawHandle; }
           ... // omitted operator*, etc
        private:
           RawResourceHandle* rawHandle;
        };

        ManagedResourceHandle handle(createNewResource());
        handle->performInvalidOperation();

    In this latter case, when the exception is thrown and the stack is unwound, the local variables are destroyed which ensures that our resource is cleaned up and doesn't leak.

        File f;
        f.open("boo.txt");
        //UNSAFE - an exception here means the file is never closed
        loadFromFile(f);
        f.close();

        Dog* dog = new Daschund;
        //UNSAFE - an exception here means the dog is never deleted
        goToThePark(dog); 
        delete dog;

        Lock* lock = getLock();
        lock.aquire();
        //UNSAFE - an exception here means the lock is never released
        doSomething();
        lock.release();

37.
Branch Prediction:
http://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-an-unsorted-array?rq=1

    Why is processing a sorted array faster than an unsorted array

    You are a processor and you see a branch.
    You have no idea which way it will go. What do you do? You halt execution and wait until the previous instructions are complete.
    Then you continue down the correct path.

    Modern processors are complicated and have long pipelines. So they take forever to "warm up" and "slow down".
    Is there a better way? You guess which direction the branch will go!
    If you guessed right, you continue executing.
    If you guessed wrong, you need to flush the pipeline and roll back to the branch. Then you can restart down the other path.
    If you guess right every time, the execution will never have to stop.
    If you guess wrong too often, you spend a lot of time stalling, rolling back, and restarting.

    Notice that the data is evenly distributed between 0 and 255.
    When the data is sorted, roughly the first half of the iterations will not enter the if-statement.
    After that, they will all enter the if-statement.

    This is very friendly to the branch predictor since the branch consecutively goes the same direction many times.
    Even a simple saturating counter will correctly predict the branch except for the few iterations after it switches direction.

    However, when the data is completely random, the branch predictor is rendered useless because it can't predict random data.
    Thus there will probably be around 50% misprediction. (no better than random guessing)

38.
Monitors in C++
http://stackoverflow.com/questions/12647217/making-a-c-class-a-monitor-in-the-concurrent-sense

39.
PThreads:
http://stackoverflow.com/questions/22427007/difference-between-pthread-exit-pthread-join-and-pthread-detach
http://stackoverflow.com/questions/20824229/when-to-use-pthread-exit-and-when-to-use-pthread-join-in-linux

    Pthread Join and Pthread exit
http://stackoverflow.com/questions/20824229/when-to-use-pthread-exit-and-when-to-use-pthread-join-in-linux

    Both methods ensure that your process doesn't end before all of your threads have ended.

    The join method has your thread of the main function explicitly wait for all threads that are to be "joined".

    The pthread_exit method terminates your main function and thread in a controlled way. main has the particularity that ending main otherwise would be terminating your whole process including all other threads.

    pthread_exit:
        pthread_exit is called from the thread itself to terminate its execution (and return a result) early.

    pthread_join:
        pthread_join is called from another thread (usually the thread that created it) to wait for a thread to terminate and obtain its return value.
        It can be called before or after the thread you're waiting for calls pthread_exit.
        If before, it will wait for the exit to occur. If after, it simply obtains the return value and releases the pthread_t resources.

    pthread_detach:
        pthread_detach can be called from either the thread itself or another thread, and indicates that you don't want the thread's return value or the ability to wait for it to finish.
        This is useful because otherwise, until you call pthread_join, the pthread_t value remains valid and consumes resources - at the very least, resources to store the return value and tying up one possible value of pthread_t.
        If you're using pthread_detach, normally you call it from either the new thread or the creating thread as soon as the new thread is created (right after pthread_create)

40.
Convert Vector to Array and Array to Vector
http://stackoverflow.com/questions/2923272/how-to-convert-vector-to-array-c

    There's a fairly simple trick to do so, since the spec now guarantees vectors store their elements contiguously:
        std::vector<double> v;
        double* a = &v[0];

    Convert array to vector:
http://stackoverflow.com/questions/8777603/what-is-the-simplest-way-to-convert-array-to-vector

        int x[3]={1, 2, 3};
        std::vector<int> v(x, x + sizeof x / sizeof x[0]);

    VERY IMP: GIVES ERROR
        void fn(vector<int>& nums)

        int arr[] = {1,2,3}
        fn(vector<int> (arr, arr + sizeof(arr)/sizeof(arr[0]);
    
    As the function take a REFERENCE, we should first store in a variable before passing it. Can’t pass a value to a reference.

Converting String to Vector of Chars
http://stackoverflow.com/questions/8263926/how-to-copy-stdstring-into-stdvectorchar

        std::string str = "hello";
        std::vector<char> data(str.begin(), str.end());

    If you already have a vector and want to add the characters at the end, you need a back inserter:

        std::string str = "hello";
        std::vector<char> data = /* ... */;
        std::copy(str.begin(), str.end(), std::back_inserter(data));

41.
Initialization of a normal array with one default value
http://stackoverflow.com/questions/1065774/c-c-initialization-of-a-normal-array-with-one-default-value

    Using the syntax that you used:
        int array[100] = {-1};
    says "set the first element to -1 and the rest to 0" since all omitted elements are set to 0.

    In C++, to set them all to -1, you can use something like std::fill_n (from <algorithm>):
        std::fill_n(array, 100, -1);

Initialize TwoD (two dimensional) array with 0
    int a[100][200] = {{0}};

    OR 

    fill_n( a, 100*200, 0 );

42.
Templates: Template keyword vs Class keyword
http://stackoverflow.com/questions/213121/use-class-or-typename-for-template-parameters

    Stroustrup originally used class to specify types in templates to avoid introducing a new keyword.
    Some in the committee worried that this overloading of the keyword led to confusion.
    Later, the committee introduced a new keyword typename to resolve syntactic ambiguity, and decided to let it also be used to specify template types to reduce confusion, but for backward compatibility, class kept its overloaded meaning.

43.
comparing int with size_t
http://stackoverflow.com/questions/3642010/comparing-int-with-size-t

    size_t CANNOT be compared with int when the int is INT is negative

    It's safe provided the int is zero or positive.
    If it's negative, and size_t is of equal or higher rank than int, then the int will be converted to size_t and so its negative value will instead become a positive value.
    This new positive value is then compared to the size_t value, which may (in a staggeringly unlikely coincidence) give a false positive.
    To be truly safe (and perhaps overcautious) check that the int is nonnegative first:

    /* given int i; size_t s; */
        if (i>=0 && i == s)
    and to suppress compiler warnings:
    if (i>=0 && (size_t)i == s)

44.
Unicode vs Ascii
http://stackoverflow.com/questions/19212306/whats-the-difference-between-ascii-and-unicode

    ASCII defines 128 characters, which map to the numbers 0–127.
    It can fit in a single 8-bit byte, the values 128 through 255 tended to be used for other characters

    Unicode defines (less than) 2^21 characters, which, similarly, map to numbers 0–221 (though not all numbers are currently assigned, and some are reserved).
    Unicode characters don't generally fit into one 8-bit byte, there are numerous ways of storing Unicode characters in byte sequences, such as UTF-32 and UTF-8

45.
Where are Class Members stored in memory
http://stackoverflow.com/questions/15572411/where-are-member-functions-stored-for-an-object
http://stackoverflow.com/questions/22119360/class-members-and-member-functions-memory-location/22119456#22119456
http://stackoverflow.com/questions/1169858/global-memory-management-in-c-in-stack-or-heap
http://stackoverflow.com/questions/648647/in-c-where-in-memory-are-class-functions-put
http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch10s04.html

    Typically a process has 5 different areas of memory allocated

        Code - text segment
        Initialized data – data segment
        Uninitialized data – bss segment
        Heap
        Stack

    The size of the text and data segments are known as soon as compilation or assembly is completed. The stack and heap segments, on the other hand, grow and shrink during program execution.

    In the assembler's point of view, all variables are global.
    The notion of a variable's scope in C or Java is enforced by the compiler, not the hardware.
    Hardware knows only about memory addresses, and the compiler must keep track of which addresses are used by each subprogram.

    member functions don't eat any additional space in the object. If it is non-virtual, it is just a plain function (in the code segment)

    Member functions or pointers to them aren't stored in the object.
    (virtual functions are typically called through a pointer stored in a table to which an object has a single pointer to) This would be a huge waste of memory. 

    They're typically stored in a code memory section, and are known to the compiler.
    The object (*this) is typically passed as an invisible parameter so the functions know on which object to operate when they are called.

    Size of a C++ Object is determined by Class’s data members and base classes
    Only non-virtual data members occupy space.
    Each instance of derived class will contain a complete copy of the instance data of the base class

http://stackoverflow.com/questions/648647/in-c-where-in-memory-are-class-functions-put
    - It's not necessarily true that "each object - when created - will be given space in the HEAP for member variables".
    - Each object you create will take some nonzero space somewhere for its member variables, but where is up to how you allocate the object itself.
    - If the object has automatic (stack) allocation, so too will its data members.
    - If the object is allocated on the free store (heap), so too will be its data members.
    - After all, what is the allocation of an object other than that of its data members?

    - If a stack-allocated object CONTAINS A POINTER or other type which is then used to allocate on the heap, that allocation will occur on the heap regardless of where the object itself was created.

    - For objects with virtual functions, EACH WILL HAVE A VTABLE POINTER allocated as if it were an explicitly-declared data member within the class.

    - As for member functions, the code for those is likely no different from free-function code in terms of where it goes in the executable image.
    - After all, a member function is basically a free function with an implicit "this" pointer as its first argument.

http://stackoverflow.com/questions/5037701/where-are-const-objects-stored
http://programmers.stackexchange.com/questions/142475/how-does-const-storage-work-item-2-scott-myers-effective-c
    Compilers wouldn't set aside data memory for const objects of integer type: they would trade it for program memory.

    Automatic variables are either stored on the stack or in a register. Doesn't matter if they're const or not.

    Static variables are stored in program memory.
    There may be multiple blocks of program memory, some read-only and some not.
    Declaring a variable const may affect which block something is stored in.

    Variables allocated with new will be on the heap. Doesn't matter if it's const or not.

    STATIC MEMBER FUNCTIONS:
        http://stackoverflow.com/questions/10952385/distinguish-if-a-c-static-method-is-called-by-the-class-or-by-an-object
        Can be called either using an object or just with the Class Name

    CALLING A MEMBER FUNCTION WILL BE A JUMP INSTRUCTION TO THAT FUNCTION

45b.
Memory Layout - Code Segment Data Segment Stack Heap
    http://www.geeksforgeeks.org/memory-layout-of-c-program/
    http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/
    http://www.tenouk.com/ModuleW.html

    Text, Data, Stack, Heap belong to a Process

    Text / Code Segment:
        Machine instructions gets stored here
        Code segment, also known as text segment contains machine code of the compiled program.
        The text segment of an executable object file is often read-only segment that prevents a program from being accidentally modified.

    DATA Segment:
        - Has Initialized and Uninitialized segments
        Data segment stores program data.
        This data could be in form of initialized or uninitialized variables, and it could be local or global.
        Data segment is further divided into four sub-data segments (initialized data segment, uninitialized or .bss data segment, stack, and heap)

45c.
ELF and how it is used for compiling and linking
How are the different segments like heap, stack, text related to the physical memory
http://www.tenouk.com/ModuleW.html
http://stackoverflow.com/questions/9226088/how-are-the-different-segments-like-heap-stack-text-related-to-the-physical-me
VERY IMP LINK: http://resources.infosecinstitute.com/hello-world-c-assembly-object-file-and-executable/

    An object and executable come in several formats such as ELF (Executable and Linking Format) and COFF (Common Object-File Format).
    For example, ELF is used on Linux systems, while COFF is used on Windows systems.

    Q1.
    When a C program is compiled and the object file(ELF) is created. the object file contains different sections such as bss, data, text and other segments. I understood that these sections of the ELF are part of virtual memory address space. Am I right? Please correct me if I am wrong.
    A1.
    1. Correct, the ELF file lays out the absolute or relative locations in the virtual address space of a process that the operating system should copy the ELF file contents into. (The bss is just a location and a size, since its supposed to be all zeros, there is no need to actually have the zeros in the ELF file). Note that locations can be absolute locations (like virtual address 0x100000 or relative locations like 4096 bytes after the end of text.)

    Q2.
    Also, there will be a virtual memory and page table associated with the compiled program. Page table associates the virtual memory address present in ELF to the real physical memory address when loading the program. Is my understanding correct?
    A2.
    2. The virtual memory definition (which is kept in page tables and maps virtual addresses to physical addresses) is not associated with a compiled program, but with a "process" (or "task" or whatever your OS calls it) that represents a running instance of that program. For example, a single ELF file can be loaded into two different processes, at different virtual addresses (if the ELF file is relocatable).

    Q3.
    I read that in the created ELF file, bss sections just keeps the reference of the uninitialised global variables. Here uninitialised global variable means, the variables that are not intialised during declaration?
    A3.
    3. The programming language you're using defines which uninitialized state goes in the bss, and which gets explicitly initialized. Note that the bss does not contain "references" to these variables, it is the storage backing those variables.

    Q4.
    Also, I read that the local variables will be allocated space at run time (i.e., in stack). Then how they will be referenced in the object file?
    A4.
    4. Stack variables are referenced implicitly from the generated code. There is nothing explicit about them (or even the stack) in the ELF file.

    Q5.
    If in the program, there is particular section of code available to allocate memory dynamically. How these variables will be referenced in object file?
    A5.
    5. Like stack references, heap references are implicit in the generated code in the ELF file. (They're all stored in memory created by changing the virtual address space via a call to sbrk or its equivalent.)

    The ELF file explains to an OS how to setup a virtual address space for an instance of a program. The different sections describe different needs. For example ".rodata" says I'd like to store read-only data (as opposed to executable code). The ".text" section means executable code. The "bss" is a region used to store state that should be zeroed by the OS. The virtual address space means the program can (optionally) rely on things being where it expects when it starts up. (For example, if it asks for the .bss to be at address 0x4000, then either the OS will refuse to start it, or it will be there.)

    Note that these virtual addresses are mapped to physical addresses by the page tables managed by the OS. The instance of the ELF file doesn't need to know any of the details involved in which physical pages are used.

45d. What is a Symbol Table

    A C compiler first creates a symbol table, which stores the relationship between the variable name and where it's located in memory.
    When compiling, it uses this table to replace all instances of the variable with a specific memory location, as others have stated.
    You can find a lot more on it on the Wikipedia page.

46.
C++ Class vs C Struct Memory Layout
http://stackoverflow.com/questions/422830/structure-of-a-c-object-in-memory-vs-a-struct

    The C++ standard guarantees that memory layouts of a C struct and a C++ class (or struct -- same thing) will be identical, provided that the C++ class/struct fits the criteria of being POD ("Plain Old Data").

    So what does POD mean?
    A class or struct is POD if:
    All data members are public and themselves POD or fundamental types (but not reference or pointer-to-member types), or arrays of such
    It has no user-defined constructors, assignment operators or destructors
    It has no virtual functions
    It has no base classes

47.
Pass by Value vs Const Reference
http://stackoverflow.com/questions/2582797/why-pass-by-const-reference-instead-of-by-value
http://stackoverflow.com/questions/1567138/const-t-arg-vs-t-arg/1567186#1567186
http://stackoverflow.com/questions/270408/is-it-better-in-c-to-pass-by-value-or-pass-by-constant-reference

    It used to be generally recommended best practice1 to use pass by const ref for all types, except for builtin types (char, int, double, etc.), for iterators and for function objects (lambdas, classes deriving from std::*_function)

    Passing arguments by value and thus copying them can be expensive - const references avoid that expensive step while still promising the caller that the object won't be changed.
    Usually fundamental types (int, double, ...) are passed by value, while class-types are passed by const reference.

    Use const T & arg if sizeof(T)>sizeof(void*) and use T arg if sizeof(T) <= sizeof(void*)

47b.
Why is Pass by Value faster than Pass by reference
http://stackoverflow.com/questions/5346853/c-why-pass-by-value-is-generally-more-efficient-than-pass-by-reference-for-bu
Nice link with Assembly code
http://stackoverflow.com/questions/22840120/pass-by-value-faster-than-pass-by-reference

    For pod types like int, char, short, and float the size of the data is the same size (or smaller) than the address passed in to reference the actual data. Looking up the value at the referenced address is an unnecessary step and adds additional cost.

    For example, take the following functions foo and bar
        void foo(char& c) {...}
        void bar(char c) {...}

    When foo is called an address is passed by value of either 32bits or 64bits, depending on your platform. When you use c within foo you have the cost of looking up the value of data held at the passed in address.

    When calling bar a value of the size of char is passed in and there is no address lookup overhead.

    Overhead with passing by reference:
        each access needs a dereference, i.e., there is one more memory read

    Overhead with passing by value:
        the value needs to be copied on stack or into registers

    For small objects, such as an integer, passing by value will be faster.
    For bigger objects (for example a large structure), the copying would create too much overhead so passing by reference will be faster.

48.
Virtual Function and Pure Virtual Functions
http://stackoverflow.com/questions/1306778/c-virtual-pure-virtual-explained?rq=1

    - What a Virtual function will do is,
        - It will make its CLASS a polymorphic base class. 
        - So we can have derived classes that can override the virtual methods in the base class.

    - What a PURE Virtual function will do is,
        http://stackoverflow.com/questions/1306778/c-virtual-pure-virtual-explained
        - When you want SOMEONE TO DEFINE ALL THE METHODS in your class.
        - It will make the base Class ABSTRACT. And any class that derives it MUST have an 
          implementation for the virtual function.
        - A pure virtual function or pure virtual method is a virtual function that is
          REQUIRED to be implemented by a derived class that is not abstract"

    A virtual function or virtual method is a function or method whose behavior can be overridden within an inheriting class by a function with the same signature 

    A pure virtual function or pure virtual method is a virtual function that is required to be implemented by a derived class that is not abstract" - Wikipedia

    The virtual keyword gives C++ its' ability to support polymorphism. When you have a pointer to an object of some class such as:

        class Animal
        {
          public:
            virtual int GetNumberOfLegs() = 0;
        };

        class Duck : public Animal
        {
          public:
             int GetNumberOfLegs() { return 2; }
        };

        class Horse : public Animal
        {
          public:
             int GetNumberOfLegs() { return 4; }
        };

        void SomeFunction(Animal * pAnimal)
        {
          cout << pAnimal->GetNumberOfLegs();
        }

    In this (silly) example, the GetNumberOfLegs() function returns the appropriate number based on the class of the object that it is called for.
    Now, consider the function 'SomeFunction'.
    It doesn't care what type of animal object is passed to it, as long as it is derived from Animal.
    The compiler will automagically cast any Animal-derived class to a Animal as it is a base class.

    If we do this:
        Duck d;
        SomeFunction(&d);
    it'd output '2'.

    If we do this:
        Horse h;
        SomeFunction(&h);
    it'd output '4'.

    We can't do this:
        Animal a;
        SomeFunction(&a);
    because it won't compile due to the GetNumberOfLegs() virtual function being pure, which means it must be implemented by deriving classes (subclasses).

    Pure Virtual Functions are mostly used to define:
        a) abstract classes
        These are base classes where you have to derive from them and then implement the pure virtual functions.

        b) interfaces
        These are 'empty' classes where all functions are pure virtual and hence you have to derive and then implement all of the functions.

    Purpose of Virtual in C++
        - When you want to OVERRIDE an method in base class AND
            - CALL it using a base class pointer
        You use virtual functions when you want to override a certain behavior (read method) for your derived class rather than the one implemented for the base class and
    you want to do so at run-time through a pointer to the base class. 

49.
Virtual Functions
http://stackoverflow.com/questions/2391679/why-do-we-need-virtual-methods-in-c

    Each time you create a class that contains virtual functions, or you derive from a class that contains virtual functions, the compiler creates a VTABLE for that class
    In that table it places the addresses of all the functions that are declared virtual in this class or in the base class

    Why VIRTUAL Methods in C++
        Let's say you have these two classes:

        class Animal
        {
        public:
        void eat() { std::cout << "I'm eating generic food."; }
        }

        class Cat : public Animal
        {
        public:
        void eat() { std::cout << "I'm eating a rat."; }
        }

        In your main function:

        Animal *animal = new Animal;
        Cat *cat = new Cat;

        animal->eat(); // outputs: "I'm eating generic food."
        cat->eat();    // outputs: "I'm eating a rat."

        So far so good right? Animals eat generic food, cats eat rats, all without virtual.

        Let's change it a little now so that eat() is called via an intermediate function (a trivial function just for this example):

        //this can go at the top of the main.cpp file
        void func(Animal *xyz) { xyz->eat(); }

        Now our main function is:

        Animal *animal = new Animal;
        Cat *cat = new Cat;

        func(animal); // outputs: "I'm eating generic food."
        func(cat);    // outputs: "I'm eating generic food."

        Uh oh... we passed a Cat into func(), but it won't eat rats. Should you overload func() so it takes a Cat* ? If you have to derive more animals from Animal they would all need their own func().

        The solution is to make eat() a virtual function:

        class Animal
        {
        public:
        virtual void eat() { std::cout << "I'm eating generic food."; }
        }
        class Cat : public Animal
        {
        public:
        void eat() { std::cout << "I'm eating a rat."; }
        }

        Main:

        func(animal); // outputs: "I'm eating generic food."
        func(cat);    // outputs: "I'm eating a rat."

49b.
How Virtual Functions Work
http://www.learncpp.com/cpp-tutorial/125-the-virtual-table/
http://www.go4expert.com/articles/virtual-table-vptr-t16544/

        class Base  
         {  
         public:  
            virtual void function1() {cout<<"Base :: function1()\n";};  
            virtual void function2() {cout<<"Base :: function2()\n";};  
            virtual ~Base(){};
        };  
           
        class D1: public Base  
        {  
        public:  
           ~D1(){};
           virtual void function1() { cout<<"D1 :: function1()\n";};
        };  
          
        class D2: public Base  
        {  
        public:  
           ~D2(){};
           virtual void function2() { cout<< "D2 :: function2\n";};  
        };  

        int main()
        {
          D1 *d = new D1;;
          Base *b = d; 

          b->function1();
          b->function2();

          delete (b);
          
          return (0);
        }

    Here in function main b pointer gets assigned to D1's _vptr and now starts pointing to D1's vtable.
    Then calling to a function1(), makes it's _vptr startightway calls D1's vtable function1() and so in turn calls D1's method i.e. function1() as D1 has it's own function1() defined it's class.

    Where as pointer b calling to a function2(), makes it's _vptr points to D1's vatble which in-turn pointing to Base class's vtable function2 () as shown in the diagram (as D1 class does not have it's own definition or function2()).

    So, now calling delete on pointer b follows the _vptr - which is pointing to D1's vtable calls it's own class's destructor i.e. D1 class's destructor and then calls the destrcutor of Base class - this as part of when dervied object gets deleted it turn deletes it's emebeded base object.
    Thats why we must always make Base class's destrcutor as virtual if it has any virtual functions in it.

50.
new vs new()
http://stackoverflow.com/questions/620137/do-the-parentheses-after-the-type-name-make-a-difference-with-new

    new Thing(); is explicit that you want a constructor called whereas new Thing; is taken to imply you don't mind if the constructor isn't called

    If used on a struct/class with a user-defined constructor, there is no difference.
    If called on a trivial struct/class (e.g. struct Thing { int i; };) then new Thing; is like malloc(sizeof(Thing)); whereas new Thing(); is like calloc(sizeof(Thing)); - it gets zero initialized.

    new uses std::nothrow to check if nullptr got returned.

51.
Reading Multiple words from cin

    std::getline(cin, wordsList);

52.
Reading multiple lines from cin

        while (getline(cin, line))
        {
            if (!line.empty())
            {
                lines.push_back(line);
            }
            else
            {
                break;
            }
        }

53.
Using size_t for loops
http://www.embedded.com/electronics-blogs/programming-pointers/4026076/Why-size-t-matters
http://stackoverflow.com/questions/1951519/when-should-i-use-stdsize-t
http://stackoverflow.com/questions/19732319/difference-between-size-t-and-unsigned-int
http://stackoverflow.com/questions/131803/unsigned-int-vs-size-t

    Code that assumes sizeof yields an unsigned int would not be portable. Code that assumes it yields a size_t is more likely to be portable.

    The size_t type is meant to specify the size of something so it's natural to use it, for example, getting the length of a string and then processing each character:

        for (size_t i = 0, max = strlen (str); i < max; i++)
            doSomethingWith (str[i]);

    You do have to watch out for boundary conditions of course, since it's an unsigned type.
    The boundary at the top end is not usually that important since the maximum is usually large (though it is possible to get there).
    Most people just use an int for that sort of thing because they rarely have structures or arrays that get big enough to exceed the capacity of that int.

    IMP: But watch out for things like:

        for (size_t i = strlen (str) - 1; i >= 0; i--)

    which will cause an infinite loop due to the wrapping behaviour of unsigned values (although I've seen compilers warn against this).
    This can also be alleviated by the (slightly harder to understand but at least immune to wrapping problems):

        for (size_t i = strlen (str); i-- > 0; )

    So, you ask, why not just use an unsigned int?
        Because unsigned int is not the only unsigned integral type.
        size_t could be any of unsigned char, unsigned short, unsigned int, unsigned long or unsigned long long, depending on the implementation.

        It may not be able to hold big enough numbers.
        In an implementation where unsigned int is 32 bits, the biggest number it can represent is 4294967295.
        Some processors, such as the IP16L32, can copy objects larger than 4294967295 bytes.
        For example in 64 bit systems int and unsigned int may be 32 bit wide, but size_t must be big enough to store numbers bigger than 4G

    So, you ask, why not use an unsigned long int?
        It exacts a performance toll on some platforms.
        Standard C requires that a long occupy at least 32 bits.
        An IP16L32 platform implements each 32-bit long as a pair of 16-bit words.
        Almost all 32-bit operators on these platforms require two instructions, if not more, because they work with the 32 bits in two 16-bit chunks.
        For example, moving a 32-bit long usually requires two machine instructions -- one to move each 16-bit chunk.

    The size_t type is the unsigned integer type that is the result of the sizeof operator (and the offsetof operator),
    so it is guaranteed to be big enough to contain the size of the biggest object your system can handle (e.g., a static array of 8Gb).

    There are 5 standard unsigned integer types in C:
        unsigned char
        unsigned short
        unsigned int
        unsigned long
        unsigned long long

    with various requirements for their sizes and ranges (briefly, each type's range is a subset of the next type's range, but some of them may have the same range).

    size_t is a typedef (i.e., an alias) for some unsigned type, (probably one of the above but possibly an extended unsigned integer type, though that's unlikely). It's the type yielded by the sizeof operator.

    On one system, it might make sense to use unsigned int to represent sizes; on another, it might make more sense to use unsigned long or unsigned long long. (size_t is unlikely to be either unsigned char or unsigned short, but that's permitted).

    The purpose of size_t is to relieve the programmer from having to worry about which of the predefined types is used to represent sizes.

    Code that assumes sizeof yields an unsigned int would not be portable. Code that assumes it yields a size_t is more likely to be portable.

54.
size_t vs size_type
http://stackoverflow.com/questions/918567/size-t-vs-containersize-type
http://stackoverflow.com/questions/8507851/stdsize-t-vs-size-t-vs-stdstringsize-type

    vector<int>::size_type x;
        I would read it as "declare x as a variable of a type suitable for holding the size of a vector".
        The vector defines its own type for its length, and it's always cleanest to use that if possible, rather than "guessing" and using int, unsigned int, long, unsigned long or size_t etc directly as you'd otherwise need to do

    You could use size_type when using those classes if you like.
    In most cases, you'll know that it's the same as size_t, so you might as well use that and save a bit of typing.
    If you're writing generic code, where you don't know what the class is, then it's better to use size_type in case it's not compatible with size_t.

    For example, you might want to write a container designed to hold more items than can be represented by size_t.
    You might use some kind of big number type to represent the container's size, which isn't convertible to size_t.
    In that case, code like size_t s = c.size() would fail to compile - you'd need to use Container::size_type instead.

    The standard containers define size_type as a typedef to Allocator::size_type (Allocator is a template parameter), which for std::allocator is defined to be size_t.
    So for the standard case, they are the same.

    However, if you use a custom allocator a different underlying type could be used.
    So container::size_type is preferable for maximum portability.

    size_type - C++
    For better portability

    This is how SIZE should be used
        for(size_t i = 0; i < dataVecs.size(); i++)

    This is how SIZE_TYPE should be used
        for(vector<string>::size_type i = 0; i < dataVecs.size(); i++)

    size_t is defined as the type used for the size of an object and is platform dependent.
    container::size_type is the type that is used for the number of elements in the container and is container dependent.

    All std containers use size_t as the size_type, but each independent library vendor chooses a type that it finds appropriate for its container.

55.
File IO
http://www.cplusplus.com/doc/tutorial/files/

    For ifstream and ofstream classes, ios::in and ios::out are automatically and respectively assumed, even if a mode that does not include them is passed as second argument to the open member function (the flags are combined).

    Copying from One file to Another
        ifstream in("document1.txt");
        ofstream out("document2.txt");
        string str;
        while(getline(in,str))
        {
            out<<str;
        }
        in.close(); // <---
        out.close(); // <---

        // position to the nth byte of fileObject (assumes ios::beg)
        fileObject.seekg( n );

        // position n bytes forward in fileObject
        fileObject.seekg( n, ios::cur );

        // position n bytes back from end of fileObject
        fileObject.seekg( n, ios::end );

        // position at end of fileObject
        fileObject.seekg( 0, ios::end );

    Using ENDL will cause the buffer to be FLUSH. So use "\n" for performance reasons
    Closing the file will flush the buffer.

    Output in C++ may be buffered.
    This means that anything that is output to a file stream may not be written to disk immediately.
    Instead, several output operations may be batched and handled together.
    This is done primarily for performance reasons.
    When a buffer is written to disk, this is called flushing the buffer.
    One way to cause the buffer to be flushed is to close the file -- the contents of the buffer will be flushed to disk, and then the file will be closed.

    Buffering is usually not a problem, but in certain circumstance it can cause complications for the unwary.
    The main culprit in this case is when there is data in the buffer, and then program terminates immediately (either by crashing, or by calling exit()).
    In these cases, the destructors for the file stream classes are not executed, which means the files are never closed, which means the buffers are never flushed.
    In this case, the data in the buffer is not written to disk, and is lost forever.
    This is why it is always a good idea to explicitly close any open files before calling exit().

    It is possible to flush the buffer manually using the ostream::flush() function or sending std::flush to the output stream.
    Either of these methods can be useful to ensure the contents of the buffer are written to disk immediately, just in case the program crashes.

    One interesting note is that std::endl; also flushes the output stream.
    Consequently, overuse of std::endl (causing unnecessary buffer flushes) can have performance impacts when doing buffered I/O where flushes are expensive (such as writing to a file).
    For this reason, performance conscious programmers will often use ‘\n’ instead of std::endl to insert a newline into the output stream, to avoid unnecessary flushing of the buffer.

56:
What is string::npos
http://www.cplusplus.com/reference/string/string/npos/

    npos is a static member constant value with the greatest possible value for an element of type size_t.

    This value, when used as the value for a len (or sublen) parameter in string's member functions, means "until the end of the string"

57.
Meaning of const
http://stackoverflow.com/questions/1143262/what-is-the-difference-between-const-int-const-int-const-and-int-const
http://www.gotw.ca/gotw/006.htm
http://stackoverflow.com/questions/455518/how-many-and-which-are-the-uses-of-const-in-c

        int* - pointer to int
        int const * - pointer to const int
        int * const - const pointer to int
        int const * const - const pointer to const int

    Now the first const can be on either side of the type so:

        const int * == int const *
        const int * const == int const * const

    Since the point object is passed by value, there is little or no benefit to declaring it const.
    Normally const pass-by-value is unuseful and misleading at best.

    CONST MEMBER FUNCTION:
        const int* const Method3(const int* const&) const;
    The final const means that the function Method3 does not modify the non mutable members of its class.

    CONST variable can either be stored in CODE segment and just copied over.

    c1 is different from the other two constants in that it is initialized with a literal value.
    This lets compiler put that value everywhere the constant is used, like this:
        int x = z + c1;
    can be replaced by
        int x = z + 1; <--- This is constant folding

    This means that the compiler does not need to allocate space and store 1 in it.

    c3 and c4 are different: one is calculated using a function, and the other one is supplied from a different compilation unit.
    This means that the compiler can no longer perform the substitution the way it could with c1: the values of the c3 and c4 are not known to the compiler.
    Therefore the compiler generates code for

        int x = z + c4;
    in the same way as if c4 were a variable stored in some place in memory.

57a.
Const vs ReadOnly
http://stackoverflow.com/questions/4486442/how-does-const-differ-in-c-and-c
http://stackoverflow.com/questions/4486326/does-const-just-mean-read-only-or-something-more

    By declaring a variable as const you indicate compiler that you have no intentions of modifying that variable. But it does not mean others don't have

    const does not mean read only, because you can write const volatile, that would mean it could change by itself anytime, but I have no intentions to modify it.

    EDIT: here is a classical example: consider I'm writing the code that reads current time from a memory-mapped port. Consider that RTC is mapped to memory DWORD 0x1234.

        const volatile DWORD* now = *(DWORD*)0x1234;

    It's const because it's a read-only port, and it's volatile because each time I will read it it will change

     It reminds you as you look at function prototypes of the contract that your functions expect.
     Your compiler will yell at you if you carelessly break it.
     (But not if you intentionally break it, as with the above cast.)

    const means that you promise not to mutate the variable.
    It could still be changed.
        class A {
          public:
            A(const int& a);
            int getValue() const;
            void setValue(int b);
          private:
            const int& a;
        };
        A::A(a) : a(a) {}
        int A::getValue() const {
            return a;
        }
        void A::setValue(int b) {
            a = b;  // error
        }

        int main() {
            int my_a = 0;
            A a(my_a);
            std::cout << a.getValue() << std::endl;  // prints 0
            my_a = 42;
            std::cout << a.getValue() << std::endl;  // prints 42
        }

    No method A::* may change a, but main can.

57b.
Const in C vs C++
http://stackoverflow.com/questions/4486442/how-does-const-differ-in-c-and-c

    const in C cannot be used to build constant expressions.

    For example :
        #include <stdio.h>
        int main()
        {
           int i = 2;
           const int C = 2;
           switch(i)
           {
              case C  : printf("Hello") ;
              break;

              default : printf("World");
           }
        }

    doesn't work in C because case label does not reduce to an integer constant.

58.
Reason to pass a pointer by reference
http://stackoverflow.com/questions/10240161/reason-to-pass-a-pointer-by-reference-in-c

    Linked List, changing the HEAD pointer.

    You would want to pass a pointer by reference if you have a need to modify the pointer rather than the object that the pointer is pointing to.

    This is similar to why double pointers are used; using a reference to a pointer is slightly safer than using pointers.

    50% of C++ programmers like to set their pointers to null after a delete:

    template<typename T>    
    void moronic_delete(T*& p)
    {
        delete p;
        p = nullptr;
    }

    Without the reference, you would only be changing a local copy of the pointer, not affecting the caller.

59.
Returning by reference:
http://stackoverflow.com/questions/752658/is-the-practice-of-returning-a-c-reference-variable-evil

        int& getInt(void)
        {
            int i;
            return i;
        }

    That is all sorts of evil. The stack-allocated i will go away and you are referring to nothing. This is semi-evil:

        int& getInt(void)
        {
            int *i = new int;
            return *i;
        }

    Because now the client has to eventually do the strange:

        int& myInt = getInt(); // note the &.
        int badInt = getInt(); // the & will be easy to miss (source of problems).
        delete &myInt; // must delete.
        delete &badInt; // won't work. badInt was a copy of the allocated int, which
                        // is now lost forever

    I think the best way to do something like that is just:

        int *getInt(void)
        {
            return new int;
        }

    And now the client stores a pointer:

        int *myInt = getInt(); // has to be a pointer
        int& weirdInt = *getInt(); // but this works too if you really want.
        delete myInt; // being a pointer, this is easy to do.
        delete &weirdInt; // works.

    Now for members of classes, & is powerful, such as operator chaining (cout's <<), or operator[].

    What is evil is making a reference to a dynamically allocated object and losing the original pointer. When you new an object you assume an obligation to have a guaranteed delete.

    But have a look at, eg, operator<<: that must return a reference, or

        cout << "foo" << "bar" << "bletch" << endl ;

    won't work.

60.
Sorting a vector of objects
http://stackoverflow.com/questions/1380463/sorting-a-vector-of-custom-objects

        struct MyStruct
        {
            int key;
            std::string stringValue;

            MyStruct(int k, const std::string& s) : key(k), stringValue(s) {}

            bool operator < (const MyStruct& str) const
            {
                return (key < str.key);
            }
        };

    Using this method means you can simply sort the vector as follows:

        std::sort(vec.begin(), vec.end());

    DESCENDING ORDER:
        struct MyStruct
        {
            int key;
            std::string stringValue;

            MyStruct(int k, const std::string& s) : key(k), stringValue(s) {}

            bool operator > (const MyStruct& str) const
            {
                return (key > str.key);
            }
        };

    And you should call sort as:
        std::sort(vec.begin(), vec.end(), greater<MyStruct>())

        struct Xgreater
        {
            bool operator()( const X& lx, const X& rx ) const {
                return lx.x < rx.x;
            }
        };
        std::sort( my_vec.begin(), my_vec.end(), Xgreater() );

61.
Find rightmost set bit
http://www.geeksforgeeks.org/position-of-rightmost-set-bit/
http://stackoverflow.com/questions/20026243/find-2-missing-numbers-in-an-array-of-integers-with-two-missing-values

    log2(n&-n)+1;
    Algorithm: (Example 18(010010))

        1. Take two's complement of the given no as all bits are reverted
        except the first '1' from right to left (10111)

        2  Do an bit-wise & with original no, this will return no with the
        required one only (00010)

        3  Take the log2 of the no, you will get position -1 (1)

        4  Add 1 (2)

    Find rightmost set bit
        x = x &(~(x-1));

61b.
Find leftmost set bit
http://stackoverflow.com/questions/671815/what-is-the-fastest-most-efficient-way-to-find-the-highest-set-bit-msb-in-an-i

    1 << ( int) log2( x)

    int hibit(unsigned int n) {
        n |= (n >>  1);
        n |= (n >>  2);
        n |= (n >>  4);
        n |= (n >>  8);
        n |= (n >> 16);
        return n - (n >> 1);
    }

    int hob (int num)
    {
        if (!num)
            return 0;

        int ret = 1;

        while (num >>= 1)
            ret <<= 1;

        return ret;
    }

62. 
#define vs typedef vs Enum
http://stackoverflow.com/questions/1666353/are-typedef-and-define-the-same-in-c

    A typedef is generally preferred unless there's some odd reason that you specifically need a macro.

    macros do textual substitution, which can do considerable violence to the semantics of the code.

    #define is a preprocessor token: the compiler itself will never see it.
    typedef is a compiler token: the preprocessor does not care about it.

    typedef obeys scoping rules just like variables, whereas
    define stays valid until the end of the file (or until a matching undef

        typedef int* int_p1;
        int_p1 a, b, c;  // a, b, and c are all int pointers.

        #define int_p2 int*
        int_p2 a, b, c;  // only the first is a pointer!

        typedef int a10[10];
        a10 a, b, c; // create three 10-int arrays

http://stackoverflow.com/questions/1674032/static-const-vs-define-vs-enum
        static const int var = 5;
        #define var 5
        enum { var = 5 };

    Ignoring issues about the choice of name, then:
        If you need to pass a pointer around, you must use (1).
        Since (2) is apparently an option, you don't need to pass pointers around.
        Both (1) and (3) have a symbol in the debugger's symbol table - that makes debugging easier. It is more likely that (2) will not have a symbol, leaving you wondering what it is.
        (1) cannot be used as a dimension for arrays at global scope; both (2) and (3) can.
        (1) cannot be used as a dimension for static arrays at function scope; both (2) and (3) can.
        Under C99, all of these can be used for local arrays. Technically, using (1) would imply the use of a VLA (variable-length array), though the dimension referenced by 'var' would of course be fixed at size 5.
        (1) cannot be used in places like switch statements; both (2) and (3) can.
        (1) cannot be used to initialize static variables; both (2) and (3) can.
        (2) can change code that you didn't want changed because it is used by the preprocessor; both (1) and (3) will not have unexpected side-effects like that.
        You can detect whether (2) has been set in the preprocessor; neither (1) nor (3) allows that.

    So, in most contexts, prefer the 'enum' over the alternatives.
    Otherwise, the first and last bullet points are likely to be the controlling factors — and you have to think harder if you need to satisfy both at once.

    If you were asking about C++, then you'd use option (1) — the static const — every time

62a.
C++ Const vs #Define vs Enum
http://stackoverflow.com/questions/1637332/static-const-vs-define
http://stackoverflow.com/questions/1674032/static-const-vs-define-vs-enum

    And, finally, in C++ const is preferable.
    At least because such constants are typed and scoped.
    There are simply no reasons to prefer #define over const, aside from few exceptions.

    String constants, BTW, are one example of such an exception.
    With #defined string constants one can use compile-time concatenation feature of C/C++ compilers, as in
        #define OUT_NAME "output"
        #define LOG_EXT ".log"
        #define TEXT_EXT ".txt"

        const char *const log_file_name = OUT_NAME LOG_EXT;
        const char *const text_file_name = OUT_NAME TEXT_EXT;

    It depends on what you need the value for.
    You (and everyone else so far) omitted the third alternative:

        (1) static const int var = 5;
        (2) #define var 5
        (3) enum { var = 5 };

    Ignoring issues about the choice of name, then:
        * If you need to pass a pointer around, you must use (1).
        Since (2) is apparently an option, you don't need to pass pointers around.
        Both (1) and (3) have a symbol in the debugger's symbol table - that makes debugging easier. It is more likely that (2) will not have a symbol, leaving you wondering what it is.
        (1) cannot be used as a dimension for arrays at global scope; both (2) and (3) can.
        (1) cannot be used as a dimension for static arrays at function scope; both (2) and (3) can.
        Under C99, all of these can be used for local arrays. Technically, using (1) would imply the use of a VLA (variable-length array), though the dimension referenced by 'var' would of course be fixed at size 5.
        (1) cannot be used in places like switch statements; both (2) and (3) can.
        (1) cannot be used to initialize static variables; both (2) and (3) can.
        (2) can change code that you didn't want changed because it is used by the preprocessor; both (1) and (3) will not have unexpected side-effects like that.
        * You can detect whether (2) has been set in the preprocessor; neither (1) nor (3) allows that.

    So, in most contexts, prefer the 'enum' over the alternatives.
    Otherwise, the first and last bullet points are likely to be the controlling factors — and you have to think harder if you need to satisfy both at once.

    If you were asking about C++, then you'd use option (1) — the static const — every time

62a.
C++ semantics of `static const` vs `const`
http://stackoverflow.com/questions/3709207/c-semantics-of-static-const-vs-const
http://objectmix.com/c/786892-const-int-same-static-const-int.html

Question:
    In C++ specifically, what are the semantic differences between for example:
        static const int x = 0 ;
    and
        const int x = 0 ;
    for both static as a linkage and a storage class specifier (i.e. inside and outside a function).

In C:
    static determines visibility outside of a function or a variables lifespan inside.
    So it has nothing to do with const per se.

    const means that you're not changing the value after it has been initialised.

    static inside a function means the variable will exist before and after the function has ended.

    static outside of a function means that the scope of the symbol marked static is limited to that .c file and cannot be seen outside of it.

Solution In C++:
    In a CLASS context, static declares that there will be only 1 such class-wide data member; as opposed to there being 1 per-instance (inside every object of the class).
    The const declares that this variable will receive a value only during its construction.

    Inside a member function of a class (or for that matter, any function), static means that it's non-automatic; that is, that its value survives returning from the function (also that it can have a value prior to ever entering it, too).
    It also means that multiple threads of execution through such a routine can contend over access to the variable.

    At file scope, no difference in C++.
    const makes internal linkage the default, and all global variables have static lifetime.
    But the first variant has the same behavior in C, so that may be a good reason to use it.

    Within a function, the second version can be computed from parameters, in C or C++ it doesn't have to be a compile-time constant like some other languages require.

    Within a class, basically the same thing as for functions, an instance const value can be computed in the ctor-initializer-list.
    A static const is set during startup initialization and remains unchanged for the rest of the program.
    (Note: the code for static members looks a little different because declaration and initialization are separated.)

    Remember, in C++, const means read-only, not constant.
    If you have a pointer-to-const then other parts of the program may change the value while you're not looking.
    If the variable was defined with const, then no one can change it after initialization but initialization can still be arbitrarily complex.

62b.
C++ Const Read Only
http://stackoverflow.com/questions/3709207/c-semantics-of-static-const-vs-const

    "const means read-only, not constant", i.e., "Compiler, if you see someone trying to modify this const thing, bark very loudly.
    This is the reason something can be const & volatile at the same time.

    It's more "Compiler, if you see me try to modify this const thing (or give someone else permission to do so)", bark very loudly.
    In most context, const applies to a view of the variable and not the variable itself, someone else can have a non-const view of the same variable, and the compiler will be quite silent when they modify it. 

62b.
Const defaults to Internal Linkage in C++ and External Linkage in C
Thinking in C++ Pg 288

62c.
When to use unnamed namespace
http://stackoverflow.com/questions/5312213/uses-of-unnamed-namespace-in-c
C++ Primer - Pg 431
Thinking in C++ - Pg 289

    When you want an object to be available only for that SPECIFIC file and not for the entire progrgam.

    The names of global functions, global variables, and classes are still in a single global name space.
    The static keyword gives you some control over this by allowing you to give variables and functions internal linkage (make them file static).
    A namespace definition can be “continued” over multiple header files

    According to Stroustrup, you should use it in places where in old C you would have made static globals.
    The idea is that the items in question can be "global" to the source file they are in, but not pollute the namespace of any other source files in your compilation.

    In other words, you shouldn't be creating static globals in C++.
    You should be using unnamed namespaces instead.

62d.
Superiority of unnamed namespace over static
http://stackoverflow.com/questions/4422507/superiority-of-unnamed-namespace-over-static
http://www.comeaucomputing.com/techtalk/#nostatic

Question:
    The project makes frequent use of unnamed namespaces.
    For example, something like this may occur in a class definition file:

        // newusertype.cc
        namespace {
          const int SIZE_OF_ARRAY_X;
          const int SIZE_OF_ARRAY_Y;
          bool getState(userType*,otherUserType*);
        }

        newusertype::newusertype(...) {...

    What are the design considerations that might cause one to use an unnamed namespace? What are the advantages and disadvantages?

Solution:
http://en.cppreference.com/w/cpp/language/namespace#Unnamed_namespaces
    SINCE C++11
    Unnamed namespaces as well as all namespaces declared directly or indirectly within an unnamed namespace have internal linkage, which means that any name that is declared within an unnamed namespace has internal linkage. 

    The use of the static keyword is deprecated when declaring objects in a namespace scope; the unnamed-namespace provides a superior alternative.

    Unnamed namespace is superior to static keyword, primarily because the keyword static applies only to the variables declarations and functions, not to the user-defined types.

    The following code is valid in C++
       //legal code
       static int sample_function() { /* function body */ }
       static int sample_variable;

    But this code is NOT valid:
       //illegal code
       static class sample_class { /* class body */ };
       static struct sample_struct { /* struct body */ };

    So the solution is, unnamed-namespace, which is this,
       //legal code
       namespace 
       {  
            class sample_class { /* class body */ };
            struct sample_struct { /* struct body */ };
       }

62e.
Why Static still exists
http://stackoverflow.com/questions/8460327/why-are-anonymous-namespaces-not-a-sufficient-replacement-for-namespace-static

    unnamed namespaces place entities into different namespaces (in addition to affecting their linkage).
    static only affects the linkage, leaving the namespace of which functions and variables are a member of unchanged.

63.
Dynamic Array in C++
Variable Length arrays
http://stackoverflow.com/questions/1204521/dynamic-array-in-stack
http://stackoverflow.com/questions/14989674/dynamic-array-without-new-operator
http://stackoverflow.com/questions/5368531/why-cant-i-create-an-array-of-size-n

    int n;
    cin >> n;
    int array[n];

    This will work if use g++. g++ support VLAs as an extension. However ISO C++ mandates size of an array to be a constant expression i.e the size must be known at compile time.

        Why is it that C++ don't allow you to create array of dynamic length in stack memory?

    Simple answer "Because the standard says so". Even the upcoming C++ Standard (C++0x) is not going to allow Variable Length Arrays.

    Below Code is standard C99. This is because C99 allows you to declare arrays dynamically that way.
    To clarify, this is also standard C99:
        #include <stdio.h>

        int main()
        {
            int x = 0;

            scanf("%d", &x);

            char pz[x]; 
        }

    This is not standard anything:
        #include <iostream>
        int main()
        {
            int x = 0;
            std::cin >> x;
            char pz[x]; 
        }
    It cannot be standard C++ because that required constant array sizes, and it cannot be standard C because C does not have std::cin (or namespaces, or classes, etc...)

    To make it standard C++, do this:
        int main()
        {
            const int x = 12; // x is 12 now and forever...
            char pz[x]; // ...therefore it can be used here
        }

    If you want a dynamic array, you can do this:
        #include <iostream>

        int main()
        {
            int x = 0;
            std::cin >> x;

            char *pz = new char[x];

            delete [] pz;
        }

    But you should do this:
        #include <iostream>
        #include <vector>

        int main()
        {
            int x = 0;
            std::cin >> x;

            std::vector<char> pz(x);
        }

63b.
TWOD Vector in C++
http://stackoverflow.com/questions/17663186/initializing-a-two-dimensional-stdvector

        std::vector::vector(count, value)
        vector< vector<int> > myTwoDVec(rows, vector<int> (cols, 5));

64.
Time in C++
http://www.cplusplus.com/reference/ctime/tm/
http://code.runnable.com/U2DKRsrlaUEEYt4f/get-the-current-local-time-with-ctime-for-c%2B%2B

        time_t rawTime = time(nullptr);   // get time now
        //time_t rawTime = time(0);   // get time now

        // http://www.cplusplus.com/reference/ctime/time/
        time_t curTime;
        curTime = time(0); // OR
        time(&curTime);

        struct tm *locTime = localtime(& rawTime); // Convert to tm struct
        cout << "Year: " << locTime->tm_year + 1900 << endl;
        cout << "Mon : " << locTime->tm_mon + 1 << endl;
        cout << "Hour: " << locTime->tm_hour << endl;
        cout << "Min : " << locTime->tm_min << endl;
        cout << "Sec : " << locTime->tm_sec << endl;

65.
Ordered Data Set
http://stackoverflow.com/questions/17296570/best-data-structure-for-ordered-list-performance

    There are at least two efficient solutions:

        Append elements to a vector; sort the vector; scan the vector.
        Insert elements into a priority_queue; drain it.

    The vector has the advantage of O(N) load time (vs. O(N log N) for the priority_queue). (Note that it still takes O(N log N) overall, due to the sort).

    The priority_queue has the advantage of freeing memory as you drain it. This doesn't reduce the maximum memory footprint, and is probably of negligible benefit, but it's worth trying anyway

66. 
Tail Recursion
http://stackoverflow.com/questions/33923/what-is-tail-recursion

    In traditional recursion, the typical model is that you perform your recursive calls first, and then you take the return value of the recursive call and calculate the result.
    In this manner, you don't get the result of your calculation until you have returned from every recursive call.

    In tail recursion, you perform your calculations first, and then you execute the recursive call, passing the results of your current step to the next recursive step.
    Basically, the return value of any given recursive step is the same as the return value of the next recursive call.

    The consequence of this is that once you are ready to perform your next recursive step, you don't need the current stack frame any more.
    This allows for some optimization.
    In fact, with an appropriately written compiler, you should never have a stack overflow snicker with a tail recursive call.
    Simply reuse the current stack frame for the next recursive step. I'm pretty sure Lisp does this.

67. 
Extern Variable; Static vs Extern
http://stackoverflow.com/questions/10422034/when-to-use-extern-in-c
Thinking in C++ PG 288

    It is useful when you share a variable between a few modules. You define it in one module, and use extern in the others.

    For example:
    in file1.cpp:

        int global_int = 1;

    in file2.cpp:
        extern int global_int;
        //in some function
        cout << "global_int = " << global_int;

    In addition, the visibility of a is global, across all translation units.
    In terms of visibility, the opposite of static (visible only in this translation unit) is extern, which explicitly states that the visibility of the name is across all translation units.
    So the above definition is equivalent to saying
        extern int a = 0;

68.
vector<bool> vs bitset
http://stackoverflow.com/questions/17794569/why-is-vectorbool-not-a-stl-container
http://stackoverflow.com/questions/4156538/how-can-stdbitset-be-faster-than-stdvectorbool

    Note: vector<bool> is overloaded and not very efficient (i.e. this structure was optimized for size not speed)

    Measurements on Visual Studio 2010 show that std::bitset is not generally faster than std::vector<bool>
    For space-optimization reasons, the C++ standard (as far back as C++98) explicitly calls out vector<bool> as a special standard container where each bool uses only one bit of space rather than one byte as a normal bool would (implementing a kind of "dynamic bitset").
    In exchange for this optimization it doesn't offer all the capabilities and interface of a normal standard container.

69.
Reading from file, donot use EOF for checking
http://stackoverflow.com/questions/5605125/why-is-iostreameof-inside-a-loop-condition-considered-wrong

    Because iostream::eof will only return true after reading the end of the stream. It does not indicate, that the next read will be the end of the stream.

    Consider this (and assume then next read will be at the end of the stream):

        while(!inStream.eof()){
          int data;
          // yay, not end of stream yet, now read ...
          inStream >> data;
          // oh crap, now we read the end and *only* now the eof bit will be set (as well as the fail bit)
          // do stuff with (now uninitialized) data
        }

    Against this:
        int data;
        while(inStream >> data){
          // when we land here, we can be sure that the read was successful.
          // if it wasn't, the returned stream from operator>> would be converted to false
          // and the loop wouldn't even be entered
          // do stuff with correctly initialized data (hopefully)
        }

70.
Struct assignment vs memcpy
http://stackoverflow.com/questions/5383318/struct-assignment-or-memcpy

    struct1 = struct2;
    VS
    memcpy(&struct1, &struct2, sizeof(mystruct_t));

    USE struct1=struct2;
    notation is not only more concise, but also shorter and leaves more optimization opportunities to the compiler.
    The semantic meaning of = is an assignment, while memcpy just copies memory.
    That's a huge difference in readability as well, although memcpy does the same in this case.

    Also, if the structure is heavily padded, assignment might make the compiler emit something more efficient, since it doesn't have to copy the padding (and it knows where it is), but mempcy() doesn't so it will always copy the exact number of bytes you tell it to copy.

    Beware though, that copying structs that contain pointers to heap-allocated memory can be a bit dangerous, since by doing so you're aliasing the pointer, and typically making it ambiguous who owns the pointer after the copying operation.

    For these situations a "deep copy" is really the only choice, and that needs to go in a function

    MEMCPY is a SHALLOW COPY
    is a shallow copy. In other words, if you have a char * pointing to a specific string, both structures will point to the same string.

    Since C90, you can simply use:
        dest_struct = source_struct;

    as long as the string is memorized inside an array:
        struct xxx {
            char theString[100];
        };

    Otherwise, if it's a pointer, you'll need to copy it by hand.

71.
Why 2's complement is used to represent negative numbers
http://stackoverflow.com/questions/1125304/why-is-twos-complement-used-to-represent-negative-numbers?rq=1
http://stackoverflow.com/questions/1049722/what-is-2s-complement
    
    - Makes addition with negative numbers simple
    - When register size increases from (say) 4 to 8, easy to just take MSB and copy it throughout.

    - Eg 1: 5 + (-2) would be
      0 101
      1 010
      -----
      1 111 <--- Wrong

    - With 2's complement: -2 would be 1101 + 1 = 1110
      0 101
      1 110
      -----
     10 011 = 3 (Discard the extra carry bit)

    Additionally, in the "intuitive" storage method, there are two zeroes:

    0000  "zero"
    1000  "negative zero"

    Which are intuitively the same number but have two different values when stored. Every application will need to take extra steps to make sure that non-zero values are also not negative zero.

    There's another bonus with storing ints this way, and that's when you need to extend the width of the register the value is being stored in.
    With two's complement, storing a 4-bit number in a 8-bit register is a matter of repeating its most significant bit:

        0001 (one, in four bits)
    00000001 (one, in eight bits)
        1110 (negative two, in four bits)
    11111110 (negative two, in eight bits)

    It's just a matter of looking at the sign bit of the smaller word and repeating it until it pads the width of the bigger word.

    With your method you would need to clear the existing bit, which is an extra operation in addition to padding:

        0001 (one, in four bits)
    00000001 (one, in eight bits)
        1010 (negative two, in four bits)
    10000010 (negative two, in eight bits)

    You still need to set those extra 4 bits in both cases, but in the "intuitive" case you need to clear the 5th bit as well.
    It's one tiny extra step in one of the most fundamental and common operations present in every application.

72.
Extern Linkage and Intern linkage and NO linkage

    External linkage means the symbol (function or global variable) is accessible throughout your program and
    internal linkage means that it's only accessible in one translation unit

    INTERNAL LINAKGE:
        Internal linkage means that storage is created to represent the identifier only for the file being compiled.
        Other files may use the same identifier name with internal linkage, or for a global variable, and no conflicts will be found by the linker - separate storage is created for each identifier.
        Internal linkage is specified by the keyword static in C and C++.

        Note that instead of using static for internal linkage it is better to use anonymous namespaces into which you can also put classes.
        The linkage for anonymous namespaces has changed between C++98 and C++11 but the main thing is that they are unreachable from other translation units.

            namespace {
               int i; // external linkage but unreachable from other translation units.
               class invisible_to_others { };
            }

    EXTERNAL LINKAGE:
        External linkage means that a single piece of storage is created to represent the identifier for all files being compiled.
        The storage is created once, and the linker must resolve all other references to that storage.
        Global variables and function names have external linkage.
        These are accessed from other files by declaring them with the keyword extern.
        Variables defined outside all functions (with the exception of const in C++) and function definitions default to external linkage.
        You can specifically force them to have internal linkage using the static keyword.
        You can explicitly state that an identifier has external linkage by defining it with the extern keyword.
        Defining a variable or function with extern is not necessary in C, but it is sometimes necessary for const in C++.

    NO LINKAGE:
        Automatic (local) variables exist only temporarily, on the stack, while a function is being
        called. The linker doesn’t know about automatic variables, and they have no linkage

73.
How a Computer Compiles and Executes a C++ Program
http://sites.psu.edu/bdk5043/wp-content/uploads/sites/11448/2014/04/process_description.pdf
http://stackoverflow.com/questions/6264249/how-does-the-compilation-linking-process-work
        1. C++ Code -> (Preprocessor) -> Modified C++ Code -> (Compiler) -> Assembly Code -> (Assembler) -> Binary Code -> (Linker links with other external libs) -> Executable file
           -> (Loader) -> Gets loaded in main meory from disk
                    
    CALLING A MEMBER FUNCTION WILL BE A JUMP INSTRUCTION TO THAT FUNCTION

74.
When / Why to use stringstream
http://stackoverflow.com/questions/20594520/what-exactly-does-stringstream-do

    ostringstream os;
    os << "dec: " << 15 << " hex: " << std::hex << 15 << endl;
    cout<<os.str()<<endl;

    Sometimes it is very convenient to use stringstream to convert between strings and other numerical types.

75.
Steps involved for execution of a C program
http://www.thegeekstuff.com/2011/10/c-program-to-an-executable/
Thinking in C++ - Pg 167

    All global objects implicitly have static storage class, so if you say (at file scope),
        int a = 0;
    then storage for a will be in the program’s static data area, and the initialization for a will occur once, before main( ) is entered

    Each separate C file is a translation unit.
    That is, the compiler is run separately on each translation unit, and when it is running it is aware of only that unit.
    Thus, any information you provide by including header files is quite important because it provides the compiler’s understanding of the rest of your program.

    External References should be resolved at Link Time
    For each translation unit, the compiler creates an object file, with an extension of .o or .obj or something similar.
    These object files, along with the necessary start-up code, must be collected by the linker into the executable program.
    During linking, all the external references must be resolved.
    For example, in Libtest.c, functions like initialize( ) and fetch( ) are declared (that is, the compiler is told what they look like) and used, but not defined.
    They are defined elsewhere, in Lib.c.
    Thus, the calls in Libtest.c are external references.
    The linker must, when it puts all the object files together, take the unresolved external references and find the addresses they actually refer to.
    Those addresses are put in to replace the external references.

75a.
Storage Classes - Static, Extern, Auto and Register
Thinking in C++

    The auto specifier is almost never used because it tells the compiler that this is a local variable.
    The compiler can always determine this fact from the context in which the variable is defined, so auto is redundant.

    A register variable is a local (auto) variable, along with a hint to the compiler that this particular variable will be heavily used, so the compiler ought to keep it in a register if it can.

76.
Abstract Class vs Interface
http://stackoverflow.com/questions/479142/when-to-use-an-interface-instead-of-an-abstract-class-and-vice-versa
http://stackoverflow.com/questions/197893/why-an-abstract-class-implementing-an-interface-can-miss-the-declaration-impleme

    Interface:
        - Interfaces have no implementation.
        - A class implementing an interface should implements all its functions.
        
    - Abstract class have some implementation.

When to use Abstract Class vs Interface
http://stackoverflow.com/questions/56867/interface-vs-base-class

    Theoretically you can override them from a higher base class, but essentially an interface allows you to add on only the things you need into a class without the need for inheritance.

    Use abstract clases and inheritance if you can make the statement "A is a B".
    Use interfaces if you can make the statement "A is capable of [doing] as", or also, abstract for what a class is, interface for what a class can do.
    For example, we can say a triangle is a polygon but it makes no sense to say a triangle is capable of being a polygon

        public class Dog : Mammal
        public class Cat : Mammal
        public class Giraffe : Mammal
        public class Rhinoceros : Mammal
        public class Hippopotamus : Mammal

        public interface IPettable
        {
            IList<Trick> Tricks{get; set;}
            void Bathe();
            void Train(Trick t);
        }

    The implementation for the above contract will not be the same between a cat and dog; putting their implementations in an abstract class to inherit will be a bad idea.

    Your Dog and Cat definitions should now look like:

        public class Dog : Mammal, IPettable
        public class Cat : Mammal, IPettable

77.
Can abstract class be instantiated
http://stackoverflow.com/questions/13670991/interview-can-we-instantiate-abstract-class

        abstract class My {
            public void myMethod() {
                System.out.print("Abstract");
            }
        }

    Poly.java:

        class Poly extends My {
            public static void main(String a[]) {
                My m = new My() {};
                m.myMethod();
            }
        }

    Now, compile both your source files:

        javac My.java Poly.java

    Now in the directory where you compiled the source code, you will see the following class files:

        My.class
        Poly$1.class  // Class file corresponding to anonymous subclass
        Poly.class

    See that class - Poly$1.class. It's the class file created by the compiler corresponding to the anonymous subclass you instantiated using the below code:

        new My() {};

    So, it's clear that there is a different class being instantiated. It's just that, that class is given a name only after compilation by the compiler

http://stackoverflow.com/questions/2091426/why-cant-we-create-objects-for-an-abstract-class-in-c/2091633#2091633
    They can't be instantiated for the simple reason that they're missing those methods.

    An abstract class is a description that is incomplete.
    It indicates what things need to be filled out to make it complete but without those bits its not complete.

    My first example was a chess game:
    The game has lots of pieces of different type (King,Queen,Pawn ... etc).

    But there are no actual objects of type piece, but all objects are instances of objects derived from piece.
    How can you have an object of something that is not fully defined.
    There is not point in creating an object of piece as the game does not know how it moves (that is the abstract part). It knows it can move but not how it does it.

    Classes are a collection of functions which operate on data.
    Functions themselves contain no memory in a class. The following class:

        struct dumb_class
        {
            void foo(){}
            void bar(){}
            void baz(){}
            // .. for all eternity

            int i;
        };
    Has a size of int.
    No matter how many functions you have ever, this class will only take up the space it takes to operate on an int.
    When you call a function in this class, the compiler will pass you a pointer to the place where the data in the class is stored; this is the this pointer.

    So, the function lie in memory somewhere, loaded once at the beginning of your program, and wait to be called with data to operate on.

    Virtual functions are different.
    The C++ standard does not mandate how the behavior of the virtual functions should go about, only what that behavior should be.
    Typically, implementations use what's called a virtual table, or vtable for short.
    A vtable is a table of function pointers, which like normal functions, only get allocated once.

    Take this class, and assume our implementor uses vtables:

        struct base { virtual void foo(void); };
        struct derived { virtual void foo(void); };

    The compiler will need to make two vtables, one for base and one for derived.
    They will look something like this:

        typedef /* some generic function pointer type */ func_ptr;

        func_ptr __baseTable[] = {&base::foo}; 
        func_ptr __derivedTable[] = {&derived::foo}; 

    How does it use this table? When you create an instance of a class above, the compiler slips in a hidden pointer, which will point to the correct vtable.
    So when you say:
        derived d;
        base* b = &d;
        b->foo();

    Upon executing the last line, it goes to the correct table (__derivedTable in this case), goes to the correct index (0 in this case), and calls that function.
    As you can see, that will end up calling derived::foo, which is exactly what should happen.

    Note, for later, this is the same as doing derived::foo(b), passing b as the this pointer.

    So, when virtual methods are present, the class of the size will increase by one pointer (the pointer to the vtable.)
    Multiple inheritance changes this a bit, but it's mostly the same. You can get more details at C++-FAQ.

    Now, to your question. I have:
        struct base { virtual void foo(void) = 0; }; // notice the = 0
        struct derived { virtual void foo(void); };

    and base::foo has no implementation.
    This makes base::foo a pure abstract function.  So, if I were to call it, like above:

        derived d;
        base* b = &d;
        base::foo(b);

    What behavior should we expect? Being a pure virtual method, base::foo doesn't even exist.
    The above code is undefined behavior, and could do anything from nothing to crashing, with anything in between. (Or worse.)

78.
C++ new int[0] - will it allocate memory
http://stackoverflow.com/questions/1087042/c-new-int0-will-it-allocate-memory?rq=1

    When the value of the expression in a direct-new-declarator is zero, the allocation function is called to allocate an array with no elements.
    The effect of dereferencing a pointer returned as a request for zero size is undefined.
    Even if the size of the space requested [by new] is zero, the request can fail.

http://stackoverflow.com/questions/9058103/memory-allocation-on-c-object-creation
        class C {
         int i;
         int j;
        };

        void f() {
         C *c = new C;
         C *c2 = new C[2];
         C (*c3)[2] = new C[2][2];
        }

    c is allocated with 8 bytes;

    c2 is allocated with 8*2+4 bytes;

    c3 is allocated with 8*2*2+4 bytes. 

    A lot of compilers use the 4 bytes before the pointer returned from new[] to store the number of objects actually being allocated.
    This is all implementation dependent

79.
C++ new vs C malloc
http://www.tutorialspoint.com/cplusplus/cpp_dynamic_memory.htm

    The main advantage of new over malloc() is that new doesn't just allocate memory, it constructs objects which is prime purpose of C++.

80.
How is memory allocated to Vectors
http://stackoverflow.com/questions/12507114/how-does-a-stack-allocated-vector-expand-in-c
http://stackoverflow.com/questions/5232198/about-vectors-growth

    vector<Type> vect;
        will allocate the vector, i.e. the header info, on the stack, but the elements on the free store ("heap").

    vector<Type> *vect = new vector<Type>;
        allocates everything on the free store.

    vector<Type*> vect;
        will allocate the vector on the stack and a bunch of pointers on the free store, but where these point is determined by how you use them (you could point element 0 to the free store and element 1 to the stack, say).

     IMP:
     Implementations almost invariable choose exponential growth, in order to meet the amortized constant time requirement for the push_back operation.

    Internally, a vector<string> will most likely consist of a string* pointing at the actual data and probably two more size_t members indicating occupied and reserved memory.
    All the rest will be on the heap.
    Therefore, sizeof(vector<string>) is fixed, and the allocation on the stack won't change.

    std::vector internaly maintains a pointer to heap allocated space that is resized as necessary. The footprint on the stack doesn't change.

http://stackoverflow.com/questions/10366474/where-does-a-stdvector-allocate-its-memory
        Does a std::vector allocate memory for its elements on the heap?
    Yes. Or more accurately it allocates based on the allocator you pass in at construction. You didn't specify one, so you get the default allocator. By default, this will be the heap.

        But how does it free that heap memory?
    Through its destructor when it goes out of scope. (Note that a pointer to a vector going out of scope won't trigger the destructor).

    The main advantage of new over malloc() is that new doesn't just allocate memory, it constructs objects which is prime purpose of C++.

    All containers in the STL are parameterized with template arguments, usually the last argument is called A or Allocator and defaults to std::allocator<...> where ... represents the type of the value stored within the container.

    The Allocator is a class that is used to provide memory and build/destroy the elements in this memory area.
    It can allocate memory from a pool or directly from the heap, whichever you build the allocator from.
    By default the std::allocator<T> is a simple wrapper around ::operator new and will thus allocate memory on the heap as you inferred.

    The memory is allocated on demand, and is deallocated at the very least when the vector's destructor is called.
    C++11 introduces shrink_to_fit to release memory sooner too.
    Finally, when the vector outgrow its current capacity, a new (larger) allocation is made, the objects are moved to it, and the old allocation is released

http://stackoverflow.com/questions/8036474/allocating-vectors-memory-on-heap-or-stack
        vector<Type> vect;
    will allocate the vector, i.e. the header info, on the stack, but the elements on the free store ("heap").

        vector<Type> *vect = new vector<Type>;
    allocates everything on the free store.

        vector<Type*> vect;
    will allocate the vector on the stack and a bunch of pointers on the free store, but where these point is determined by how you use them (you could point element 0 to the free store and element 1 to the stack, say).

NICE LINK ON HOW VECTOR MEMORY ALLOCATION HAPPENS
https://frogatto.com/2009/11/17/how-cs-vector-works-the-gritty-details/

    begin points to the start of the buffer.
    It is fairly easy to understand. You can get it using the begin() member of vector.

    end points to one past the end of the valid, initialized elements of the vector.
    Note that it points one past the end, making it so that end – begin = size. You can retrieve the end pointer using the end() function and the size() function is the same as evaluating end() – begin().
    capacity pointers to one past the end of the buffer.

    Therefore, compared to arrays, vectors consume more memory in exchange for the ability to manage storage and grow dynamically in an efficient way.

What should your store in a Vector
    Built-ins like integers can be stored easily, of course.
    But what about objects of class type?
    Suppose you are programming a particle system and have a particle class, and want to store a long list of particles, what is the best way to do it? One way is to store a vector<particle>, another is to store a vector<particle*> — that is, don’t store the particles themselves directly in the vector, but store pointers to particles.

    How do you choose which?
        Generally, the larger and bulkier the object is, the more likely it is you want to store pointers to it, rather than the object itself.
        Storing a vector<int*> would be very inefficient, since the pointers would be as large or larger than the integers and you’d have to have the overhead of the memory allocations too.
        But for a large object, like Frogatto’s custom_object class, a vector<custom_object*> is probably what we want.
        Note that to store an object directly, it must be copyable, i.e. have accessible copy constructors and assignment operators.

81.
Where Global Variables and Pointers are stored
http://stackoverflow.com/questions/3113668/location-of-pointers-and-global-variables-in-c

    Compile
        When a file is compiled, variables with "program duration" (static or global variables) which are defined within that "compilation unit" (in rough terms, the "c file") determine how much global space this program needs, and how it is initialized.

    Link
        When the linker creates your executable, it combines this information and puts it into sections of the executable used for that purpose.
        The linker then goes through and changes all references to that data to where it will put that data in the process's memory space when the program is loaded.
        So the pointers to the global data will be like constants in your source file; no memory needs to be set aside for them.

        For zero-initialized or uninitialized global data, just the amount of space needed for such data is stored. For initialized data, the initial values are stored.

    Load
        When your program is loaded, the loader will look into the program file to tell how much zero-initialized data is needs, and sets aside enough of the process's memory space for it, and initializes it all to binary zero.
        For the initialized data, it sets aside memory for that and initializes it to the initial values saved in the exe file. It also sets aside areas for the heap (used by malloc()) and the stack.

    Dynamic Libraries
        If your code is in a dynamic library, the linker can't know where it will put the global data.
        In this case, it creates sections in the library to tell it where the references to the global data are, and the loader takes care of changing the references to point to the right place when it loads the file (this is why you pass -fPIC on the gcc command line for dlls).
        But since this is done at load time, by the time your program runs the placement of the data is known, so the loader knows where that data will be pointers to global data can still act as constants in your program.

    Dynamic Loading
        If you link dynamically to a dll, the loader doesn't know about it, so you have to call functions which know how to load a dll and get the address of its exported data and functions.

Where are my Varibles stored in memory in  C
http://stackoverflow.com/questions/14588767/where-in-memory-are-my-variables-stored-in-c
    You got some of these right, but whoever wrote the questions tricked you on at least one question:

        global variables -------> data (correct)
        Global Variables - Global variables can be in a couple places, depending on how they're set up - for example, const globals may be in a read-only section of the executable.
        "Normal" globals are in a read-write section of the executable.

        static variables -------> data (correct)

        constant data types -----> code and/or data.
        in the GCC compiler, on most machines, read-only variables, constants, and jump tables are placed in the text section
        Consider string literals for a situation when a constant itself would be stored in the data segment, and references to it would be embedded in the code

        local variables(declared and defined in functions) --------> stack (correct)

        variables declared and defined in main function -----> Also stack (the teacher was trying to trick you)

        pointers(ex: char *arr, int *arr) -------> heap data or stack, depending on the context.
        C lets you declare a global or a static pointer, in which case the pointer itself would end up in the data segment.
        Pointers - Pointers are just a type of variable, so they can be wherever you want them to be (on the heap if you malloc() them, on the stack if they're local variables, or in the data section if they're global).

        dynamically allocated space(using malloc, calloc, realloc) --------> heap

82.
Where are the Variable Names stored in memory
http://stackoverflow.com/questions/14612314/how-are-variable-names-stored-in-memory-in-c
http://www.csee.umbc.edu/~chang/cs313.s02/stack.shtml

    A C compiler first creates a symbol table, which stores the relationship between the variable name and where it's located in memory.
    When compiling, it uses this table to replace all instances of the variable with a specific memory location

    Variable names don't exist anymore after the compiler runs (barring special cases like exported globals in shared libraries or debug symbols).
    The entire act of compilation is intended to take those symbolic names and algorithms represented by your source code and turn them into native machine instructions.
    So yes, if you have a global variable_name, and compiler and linker decide to put it at 0xaaaaaaaa, then wherever it is used in the code, it will just be accessed via that address.

    So to answer your literal questions:

        How does the compiler recognize that the string "variable_name" is associated with that particular memory address?
    The toolchain (compiler & linker) work together to assign a memory location for the variable.
    It's the compiler's job to keep track of all the references, and linker puts in the right addresses later.

        Is the string "variable_name" stored somewhere in memory?
    Only while the compiler is running.

        Does the compiler just substitute variable_name for 0xaaaaaaaa whenever it sees it, and if so, wouldn't it have to use memory in order to make that substitution?

    Yes, that's pretty much what happens, except it's a two-stage job with the linker.
    And yes, it uses memory, but it's the compiler's memory, not anything at runtime for your program.

    An example might help you understand. Let's try out this program:

        int x = 12;

        int main(void)
        {
            return x;
        }

    Pretty straightforward, right? OK. Let's take this program, and compile it and look at the disassembly:
        $ cc -Wall -Werror -Wextra -O3    example.c   -o example
        $ otool -tV example
        example:
        (__TEXT,__text) section
        _main:
        0000000100000f60    pushq   %rbp
        0000000100000f61    movq    %rsp,%rbp
        0000000100000f64    movl    0x00000096(%rip),%eax
        0000000100000f6a    popq    %rbp
        0000000100000f6b    ret

    See that movl line? It's grabbing the global variable (in an instruction-pointer relative way, in this case). No more mention of x.

    Now let's make it a bit more complicated and add a local variable:

        int x = 12;

        int main(void)
        {  
            volatile int y = 4;
            return x + y;
        }

    The disassembly for this program is:
        (__TEXT,__text) section
        _main:
        0000000100000f60    pushq   %rbp
        0000000100000f61    movq    %rsp,%rbp
        0000000100000f64    movl    $0x00000004,0xfc(%rbp)
        0000000100000f6b    movl    0x0000008f(%rip),%eax
        0000000100000f71    addl    0xfc(%rbp),%eax
        0000000100000f74    popq    %rbp
        0000000100000f75    ret

    Now there are two movl instructions and an addl instruction.
    You can see that the first movl is initializing y, which it's decided will be on the stack (base pointer - 4).
    Then the next movl gets the global x into a register eax, and the addl adds y to that value.
    But as you can see, the literal x and y strings don't exist anymore.
    They were conveniences for you, the programmer, but the computer certainly doesn't care about them at execution time.

VERY NICE LINK ON HOW A FUNCTION CALL ACTUALLY HAPPENS
http://www.csee.umbc.edu/~chang/cs313.s02/stack.shtml
    Return Value of More than 4 bytes
        Return values of 4 bytes or less are stored in the EAX register. If a return value with more than 4 bytes is needed, then the caller passes an "extra" first argument to the callee. This extra argument is address of the location where the return value should be stored. I.e., in C parlance the function call:

           x = foo(a, b, c) ;

        is transformed into the call:

           foo(&x, a, b, c) ;

82b.
Where in memory are return values stored in memory
http://stackoverflow.com/questions/5472008/where-in-memory-are-return-values-stored-in-memory

    There is no general answer to this question, because it depends on the target architecture.
    There is usually a Binary API Spec for any target architecture that defines that and the compiler creates codes that works according to this spec.
    Most architectures use a register for passing the return value back, simply because it is the fastest way to do it.
    That is only possible if the value will fit into a register, of course.
    If not, they might use a register pair (e.g. lower 32 bit in one register, upper 32 bit in another one), or they will pass it back via the stack.
    Some architectures never use registers and always pass back via the stack.
    Since the caller must create a stack frame before calling the function (there are exceptions to this rule, but lets stay with the default case here), the stack frame is still there when the function returns to the caller and the caller knows how to access it, it has to know that, since it must also clean the stack frame on return.
    On most architectures the caller cleans the stack frame, not the callee, since the caller knows how many arguments it has passed via stack (e.g. for a C function that takes a variable number of arguments), while the callee does not (not at compile time, the callee may only know that at runtime), thus it makes more sense to let the caller clean it.
    And before doing that, the caller can read back any value of the stack frame it wishes to retrieve.

83.
What is Type Safe
http://stackoverflow.com/questions/260626/what-is-type-safe
http://stackoverflow.com/questions/2140369/what-is-type-safety-and-what-are-the-type-safe-alternatives

    Type safety means that the compiler can check whether you're using the right types.
    For example, if you're using printf, you could accidentally crash your program by writing this:
        printf("The meaning of life is %s", 42);
    because 42 is an integer, not a string

    when you call memcpy, the function (and compiler) only sees two pointers in memory, and will happily start copying data. This means you can mix incompatible data types like this:
        SomeClass a;
        AnotherClass b;
        memcpy((void*)&a, (void*)&b, sizeof(b));

    Type safety means that the compiler will validate types while compiling, and throw an error if you try to assign the wrong type to a variable.
    Some simple examples:
        // Fails, Trying to put an integer in a string
        String one = 1;
        // Also fails.
        int foo = "bar";

    This also applies to method arguments, since you are passing explicit types to them:
        int AddTwoNumbers(int a, int b)
        {
            return a + b;
        }

    If I tried to call that using:
        int Sum = AddTwoNumbers(5, "5");

    The compiler would throw an error, because I am passing a string ("5"), and it is expecting an integer.

84.
What is the name of the --> operator
http://stackoverflow.com/questions/1642028/what-is-the-name-of-the-operator?rq=1

    while (x --> 0) // x goes to 0

    --> is not an operator. It is in fact two separate operators, -- and >.
    while( (x--) > 0 )

85.
Why is ::operator new[] necessary when ::operator new is enough
http://stackoverflow.com/questions/24603142/why-is-operator-new-necessary-when-operator-new-is-enough?rq=1

    ::operator new[] and ~delete[] facilitate memory usage debugging, being a central point to audit allocation and deallocation operations;
    you can then ensure the array form is used for both or neither.

    operator new can reasonably expect that an object will be constructed at the exact address returned, but operator new[] cannot.
    The first bytes of the allocation block might be used for a size "cookie", the array might be sparsely initialized, etc.

86.
Allocator vs New
http://stackoverflow.com/questions/5628059/c-stl-allocator-vs-operator-new

    For general programming, yes you should use new and delete.

    However, if you are writing a library, you should not! I don't have your textbook, but I imagine it is discussing allocators in the context of writing library code.

    Users of a library may want control over exactly what gets allocated from where.
    If all of the library's allocations went through new and delete, the user would have no way to have that fine-grained level of control.

    All STL containers take an optional allocator template argument.
    The container will then use that allocator for its internal memory needs.
    By default, if you omit the allocator, it will use std::allocator which uses new and delete (specifically, ::operator new(size_t) and ::operator delete(void*)).

    This way, the user of that container can control where memory gets allocated from if they desire.

http://stackoverflow.com/questions/31358804/whats-the-advantage-of-using-stdallocator-instead-of-new-in-c
    new T[N] doesn't allow you control over what constructors are called.
    And it forces you to construct all your objects at the same time.
    This is terrible for the purposes of, for example, std::vector where you only want to allocate occasionally.

    With a raw memory allocator, you can allocate a certain amount of memory, which determines your capacity.
    Then, as the user adds items to the vector (using the constructor of their choice), you can construct objects in place in this memory.

    sometimes you want to separate allocation and construction into two steps (and similarly to separate destruction and deallocation into two steps).
    If you don't want to do that, don't use an allocator, use new instead.

Q. In which cases can it be used and when should it be used instead of new and delete?

    When you need the behaviour of an allocator, not the behaviour of new and delete, obviously! The typical case is when implementing a container.

    Consider the following code:
        std::vector<X> v;
        v.reserve(4);        // (1)
        v.push_back( X{} );  // (2)
        v.push_back( X{} );  // (3)
        v.clear();           // (4)

    Here line (1) must allocate enough memory for four objects, but not construct them yet.
    Then lines (2) and (3) must construct objects into the allocated memory.
    Then line (4) must destroy those objects, but not deallocate the memory. Finally, in the vector's destructor, all the memory can be deallocated.

    So the vector cannot just use new X() or delete &m_data[1] to create and destroy the objects, it must perform allocation/deallocation separately from construction/destruction.
    A container's allocator template argument defines the policy that should be used for (de)allocating memory and constructing/destructing objects, allowing the container's use of memory to be customised.
    The default policy is the std::allocator type.

    So you use an allocator when an allocator is required (such as when using a container) and you use std::allocator when you don't want to provide a custom allocator and just want the standard one.

    You don't use an allocator as a replacement for new and delete

87. 
What is RTTI and Why is it necessary

    Run-time type information (RTTI) is a mechanism that allows the type of an object to be determined during program execution.

    There are three main C++ language elements to run-time type information:
    1. The dynamic_cast operator.
       Used for conversion of polymorphic types.

    2. The typeid operator.
       Used for identifying the exact type of an object.

    3. The type_info class.
       Used to hold the type information returned by the typeid operator.

http://stackoverflow.com/questions/18590086/use-of-rtti-in-c
    It enables you to identify the dynamic type of a object at run time.
    You can use it when checking post-condtions:

        class Clonable
        {
            virtual Clonable* doClone() const = 0;
        public:
            Clonable* clone() const
            {
                Clonable* results = doClone();
                assert( typeid(*results) == typeid(*this) );
                return results;
            }
        };

    It can also be used as an index into a map of factory functions: in C++11, you have std::type_index with which you can wrap it; in earlier versions, you wrote your own:

        std::map<std::type_index, Base* (*)()> factoryMap;

    The fact that the output of std::type_info::name() isn't specified, however, limits its utility much more that one would like.


    Here is an example: Sometimes you would want to (though you should avoid to) downcast polymorphic objects. In many cases, you do not know at compile time whether this cast will be valid every time you do it:

        struct Base { virtual ~Base() {} };
        struct A : Base {};
        struct B : Base {};

        void foo(Base * base)
        {
            A * a = dynamic_cast<A *>(base); // RTTI magic here!
            if(a != nullptr)
            {
                // do something with a
            }
        }

    Notice that RTTI comes at the cost of runtime checks and thus performance loss, but you probably already know that if you are familiar with the concept.

88.
When to use static methods
http://stackoverflow.com/questions/2671496/java-when-to-use-static-methods

    So in a class Car you might have a method double convertMpgToKpl(double mpg) which would be static, because one might want to know what 35mpg converts to, even if nobody has ever built a Car.
    But void setMileage(double mpg) (which sets the efficiency of one particular Car) can't be static since it's inconceivable to call the method before any Car has been constructed.

89.
Freeing memory twice
http://stackoverflow.com/questions/2468853/freeing-memory-twice
http://stackoverflow.com/questions/3117615/why-free-crashes-when-called-twice

    Freeing memory does not set the pointer to null.
    The pointer remains pointing to the memory it used to own, but which has now had ownership transferred back to the heap manager.
    The heap manager may have since reallocated the memory your stale pointer is pointing to.

        thread A allocated and freed memory at address 42.
        thread B allocated memory a address 42 and started using it.
        thread A freed that memory a second time.
        thread C allocated memory a address 42 and started using it.

        Malloc some memory -- adds the bookkeeping data.
        Free it -- memory is returned to pool.
        You or someone else malloc's some more memory, which might or might not include or line up with the old allocation.
        You free the old pointer again.

90.
C++ Memory management
New operator vs Operator new 
http://www.bogotobogo.com/cplusplus/memoryallocation.php

    1. new operator:
        - It allocates enough memory to hold an object of the type requested.
        - It calls a constructor to initialize an object in the memory that was allocated.


    So, what function is the new calling?
    It is operator new.
        void * operator new (size_t size);

    The return type is void*.
    Since this function returns a pointer to raw which is not typed and uninitialized memory large enough to hold an object of the specified type.
    The size_t specifies how much memory to allocate.

    It's rare but there is a chance we may want to call operator new directly.
        void *pRawMemory = operator new(sizeof(string));


    Operator New:
        The operator new returns a pointer to a chunk of memory enough to hole a string object.
        The operator new is similar to malloc in that it's responsible only for allocating memory.
        It knows nothing about constructors.
        All operator new understands is memory allocation. That's it. 

Delete Operator and Operator Delete 
    When we use a delete expression to delete a dynamically allocated object:
        delete ptr;

    two things happen.
    First, the appropriate destructor is run on the object to which ptr points.
    Then, the memory used by the object is freed by calling a operator delete function.

    Overloaded versions of operator new and operator delete
        Note that operator new and operator delete apply only to allocations for single objects.
        Memory for array is allocated by operator new[] and deallocated by operator delete[].
        Also note that heap memory for STL containers is managed by the containers' allocator objects, not by new and delete directly.

        There are two overloaded versions of operator new and operator delete functions:

        void *operator new(size_t);	// allocate an object
        void *perator new[](size_t);  	// allocate an array

        void *operator delete(void*);	// free an object
        void *perator delete[](void*); 	// free an array

    Malloc vs New
        Malloc just allocates memory. New allocates memory as well as constructs the object
91.
STACK VS HEAP
http://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap?rq=1

    Each thread gets a stack, while there's typically only one heap for the application (although it isn't uncommon to have multiple heaps for different types of allocation).

    Q. What is their scope?
        The stack is attached to a thread, so when the thread exits the stack is reclaimed.
        The heap is typically allocated at application startup by the runtime, and is reclaimed when the application (technically process) exits

    Q. What determines the size of each of them?
        The size of the stack is set when a thread is created.
        The size of the heap is set on application startup, but can grow as space is needed (the allocator requests more memory from the operating system).

    Q. What makes one faster?

        The stack is faster because the access pattern makes it trivial to allocate and deallocate memory from it (a pointer/integer is simply incremented or decremented),
        while the heap has much more complex bookkeeping involved in an allocation or free.

        Also, each byte in the stack tends to be reused very frequently which means it tends to be mapped to the processor's cache, making it very fast.
        Another performance hit for the heap is that the heap, being mostly a global resource, typically has to be multi-threading safe,
        i.e. each allocation and deallocation needs to be - typically - synchronized with "all" other heap accesses in the program.

92.
Different behavior of Code Valid in C and C++
http://stackoverflow.com/questions/12887700/can-code-that-is-valid-in-both-c-and-c-produce-different-behavior-when-compile?rq=1

        #include <stdio.h>

        int  sz = 80;

        int main(void)
        {
            struct sz { char c; };

            int val = sizeof(sz);      // sizeof(int) in C,
                                       // sizeof(struct sz) in C++
            printf("%d\n", val);
            return 0;
        }

        #include <stdio.h>

        struct f { };

        int main() {
            f();
        }

        int f() {
            return printf("hello");
        }

    In C++ this will print nothing because a temporary f is created and destroyed, but in C it will print hello because functions can be called without having been declared.

    In case you were wondering about the name f being used twice, the C and C++ standards explicitly allows this, and to make an object you have to say struct f to disambiguate if you want the structure, or leave off struct if you want the function.

93.
Case Only Labels: Jumping over initialization
http://stackoverflow.com/questions/92396/why-cant-variables-be-declared-in-a-switch-statement?rq=1

    Case statements are only 'labels'.
    This means the compiler will interpret this as a jump directly to the label.
    In C++, the problem here is one of scope.
    Your curly brackets define the scope as everything inside the 'switch' statement.
    This means that you are left with a scope where a jump will be performed further into the code skipping the initialization.
    The correct way to handle this is to define a scope specific to that case statement and define your variable within it.

        switch (val)
        {   
        case VAL:  
        {
          // This will work
          int newVal = 42;  
          break;
        }
        case ANOTHER_VAL:  
        ...
        break;
        }

94.
What uses are there for “placement new”?
http://stackoverflow.com/questions/222557/what-uses-are-there-for-placement-new?rq=1

    We use it with custom memory pools.

    Placement new allows you to construct an object on memory that's already allocated.

    You may want to do this for optimizations (it is faster not to re-allocate all the time) but you need to re-construct an object multiple times.
    If you need to keep re-allocating it might be more efficient to allocate more than you need, even though you don't want to use it yet.

    Devex gives a good example:

        Standard C++ also supports placement new operator, which constructs an object on a pre-allocated buffer.
        This is useful when building a memory pool, a garbage collector or simply when performance and exception safety are paramount (there's no danger of allocation failure since the memory has already been allocated, and constructing an object on a pre-allocated buffer takes less time):

        char *buf  = new char[sizeof(string)]; // pre-allocated buffer
        string *p = new (buf) string("hi");    // placement new
        string *q = new string("hi");          // ordinary heap allocation

    You may also want to be sure there can be no allocation failure at a certain part of critical code (maybe you work on a pacemaker for example).
    In that case you would want to use placement new.

    Deallocation in placement new:
        You should not deallocate every object that is using the memory buffer.
        Instead you should delete[] only the original buffer. You would have to then call the destructors directly of your classes manually.

95.
Is there a "placement delete"?
http://www.stroustrup.com/bs_faq2.html#placement-delete

    No, but if you need one you can write your own.

    Consider placement new used to place objects in a set of arenas
            class Arena {
            public:
                    void* allocate(size_t);
                    void deallocate(void*);
                    // ...
            };

            void* operator new(size_t sz, Arena& a)
            {
                    return a.allocate(sz);
            }

            Arena a1(some arguments);
            Arena a2(some arguments);

    Given that, we can write

            X* p1 = new(a1) X;
            Y* p2 = new(a1) Y;
            Z* p3 = new(a2) Z;
            // ...

    But how can we later delete those objects correctly? The reason that there is no built-in "placement delete" to match placement new is that there is no general way of assuring that it would be used correctly. Nothing in the C++ type system allows us to deduce that p1 points to an object allocated in Arena a1. A pointer to any X allocated anywhere can be assigned to p1.

    However, sometimes the programmer does know, and there is a way:

            template<class T> void destroy(T* p, Arena& a)
            {
                    if (p) {
                            p->~T();		// explicit destructor call
                            a.deallocate(p);
                    }
            }

    Now, we can write:

            destroy(p1,a1);
            destroy(p2,a2);
            destroy(p3,a3);

    If an Arena keeps track of what objects it holds, you can even write destroy() to defend itself against mistakes.

96a. What is a smart pointer and when should I use one
http://stackoverflow.com/questions/106508/what-is-a-smart-pointer-and-when-should-i-use-one
http://www.codeproject.com/Articles/541067/Cplusplus11-Smart-Pointers

    A smart pointer is a class that wraps a 'raw' (or 'bare') C++ pointer, to manage the lifetime of the object being pointed to. There is no single smart pointer type, but all of them try to abstract a raw pointer in a practical way.

    Smart pointers should be preferred over raw pointers. If you feel you need to use pointers (first consider if you really do), you would normally want to use a smart pointer as this can alleviate many of the problems with raw pointers, mainly forgetting to delete the object and leaking memory.

    With raw pointers, the programmer has to explicitly destroy the object when it is no longer useful.

        // Need to create the object to achieve some goal
        MyObject* ptr = new MyObject(); 
        ptr->DoSomething(); // Use the object in some way
        delete ptr; // Destroy the object. Done with it.
        // Wait, what if DoSomething() raises an exception...?

    A smart pointer by comparison defines a policy as to when the object is destroyed. You still have to create the object, but you no longer have to worry about destroying it.

        SomeSmartPtr<MyObject> ptr(new MyObject());
        ptr->DoSomething(); // Use the object in some way.

        // Destruction of the object happens, depending 
        // on the policy the smart pointer class uses.

        // Destruction would happen even if DoSomething() 
        // raises an exception

    The simplest policy in use involves the scope of the smart pointer wrapper object, such as implemented by boost::scoped_ptr or std::unique_ptr.

    void f()
    {
        {
           boost::scoped_ptr<MyObject> ptr(new MyObject());
           ptr->DoSomethingUseful();
        } // boost::scopted_ptr goes out of scope -- 
          // the MyObject is automatically destroyed.

        // ptr->Oops(); // Compile error: "ptr" not defined
                        // since it is no longer in scope.
    }

    Note that scoped_ptr instances cannot be copied. This prevents the pointer from being deleted multiple times (incorrectly). You can, however, pass references to it around to other functions you call.

    Scoped pointers are useful when you want to tie the lifetime of the object to a particular block of code, or if you embedded it as member data inside another object, the lifetime of that other object. The object exists until the containing block of code is exited, or until the containing object is itself destroyed.

    A more complex smart pointer policy involves reference counting the pointer. This does allow the pointer to be copied. When the last "reference" to the object is destroyed, the object is deleted. This policy is implemented by boost::shared_ptr and std::shared_ptr.

    void f()
    {
        typedef std::shared_ptr<MyObject> MyObjectPtr; // nice short alias
        MyObjectPtr p1; // Empty

        {
            MyObjectPtr p2(new MyObject());
            // There is now one "reference" to the created object
            p1 = p2; // Copy the pointer.
            // There are now two references to the object.
        } // p2 is destroyed, leaving one reference to the object.
    } // p1 is destroyed, leaving a reference count of zero. 
      // The object is deleted.

    Reference counted pointers are very useful when the lifetime of your object is much more complicated, and is not tied directly to a particular section of code or to another object.

    There is one drawback to reference counted pointers ¿ the possibility of creating a dangling reference:

    // Create the smart pointer on the heap
    MyObjectPtr* pp = new MyObjectPtr(new MyObject())
    // Hmm, we forgot to destroy the smart pointer,
    // because of that, the object is never destroyed!

    Another possibility is creating circular references:

    struct Owner {
       boost::shared_ptr<Owner> other;
    };

    boost::shared_ptr<Owner> p1 (new Owner());
    boost::shared_ptr<Owner> p2 (new Owner());
    p1->other = p2; // p1 references p2
    p2->other = p1; // p2 references p1

    // Oops, the reference count of of p1 and p2 never goes to zero!
    // The objects are never destroyed!

    To work around this problem, both Boost and C++11 have defined a weak_ptr to define a weak (uncounted) reference to a shared_ptr.

    This answer is rather old, and so describes what was 'good' at the time, which was smart pointers provided by the Boost library. Since C++11, the standard library has provided sufficient smart pointers types, and so you should favour the use of std::unique_ptr, std::shared_ptr and std::weak_ptr.

    There is also std::auto_ptr. It is very much like a scoped pointer, except that it also has the "special" dangerous ability to be copied ¿ which also unexpectedly transfers ownership! It is deprecated in the newest standards, so you shouldn't use it. Use the std::unique_ptr instead.

    std::auto_ptr<MyObject> p1 (new MyObject());
    std::auto_ptr<MyObject> p2 = p1; // Copy and transfer ownership. 
                                     // p1 gets set to empty!
    p2->DoSomething(); // Works.
    p1->DoSomething(); // Oh oh. Hopefully raises some NULL pointer exception.


96b.
Auto, Unique, Shared Pointers, Weak Pointers and Scoped Pointers
http://stackoverflow.com/questions/569775/smart-pointers-boost-explained
http://stackoverflow.com/questions/6876751/differences-between-unique-ptr-and-shared-ptr
VERY IMP LINK: http://www.codeproject.com/Articles/541067/Cplusplus-Smart-Pointers 

    auto_ptr, unique_ptr and shared_ptr

    Raw Pointers: Only use if you really, really, really, really, know what you are doing and have carefully hidden usage behind an interface.
    std::auto_ptr: Obsolete never use.
    std::unique_ptr: Singleton pointer that transfers ownership upon assignment.
    std::shared_ptr: Reference counted pointer that does not transfer ownership upon assignment but increments its reference count. When all references leave scope or are explicitly std::shared_ptr::reset the underlying deallocator is called.
    std::weak_ptr: A sub-type std::shared_ptr that does not increment the reference count and is invalidated when its parent std::shared_ptr no longer exists. May return and invalid reference. Always check before using.

    Basic properties of smart pointers
    It's easy when you have properties that you can assign each smart pointer. There are three important properties.
        1. no ownership at all
            The first means that a smart pointer cannot delete the object, because it doesn't own it.

        2. transfer of ownership
            The second means that only one smart pointer can ever point to the same object at the same time.
            If the smart pointer is to be returned from functions, the ownership is transferred to the returned smart pointer.

        3. share of ownership
            The third means that multiple smart pointers can point to the same object at the same time.
            This applies to a raw pointer too, however raw pointers lack an important feature: They do not define whether they are owning or not.
            A share of ownership smart pointer will delete the object if every owner gives up the object. This behavior happens to be needed often, so shared owning smart pointers are widely spread.

    Some owning smart pointers support neither the second nor the third. They can therefore not be returned from functions or passed somewhere else. Which is most suitable for RAII purposes where the smart pointer is kept local and is just created so it frees an object after it goes out of scope.

    Share of ownership can be implemented by having a copy constructor. This naturally copies a smart pointer and both the copy and the original will reference the same object. Transfer of ownership cannot really be implemented in C++ currently, because there are no means to transfer something from one object to another supported by the language: If you try to return an object from a function, what is happening is that the object is copied. So a smart pointer that implements transfer of ownership has to use the copy constructor to implement that transfer of ownership. However, this in turn breaks its usage in containers, because requirements state a certain behavior of the copy constructor of elements of containers which is incompatible with this so-called "moving constructor" behavior of these smart pointers.

    C++1x provides native support for transfer-of-ownership by introducing so-called "move constructors" and "move assignment operators". It also comes with such a transfer-of-ownership smart pointer called unique_ptr.

    Categorizing smart pointers
    scoped_ptr is a smart pointer that is neither transferable nor sharable. It's just usable if you locally need to allocate memory, but be sure it's freed again when it goes out of scope. But it can still be swapped with another scoped_ptr, if you wish to do so.

    scoped_ptr is the simplest. When it goes out of scope, it is destroyed. The following code is illegal (scoped_ptrs are non-copyable) but will illustrate a point:

        std::vector< scoped_ptr<T> > tPtrVec;
        {
             scoped_ptr<T> tPtr(new T());
             tPtrVec.push_back(tPtr);
             // raw T* is freed
        }
        tPtrVec[0]->DoSomething(); // accessing freed memory

    shared_ptr is a smart pointer that shares ownership (third kind above). It is reference counted so it can see when the last copy of it goes out of scope and then it frees the object managed.

        shared_ptr is reference counted. Every time a copy or assignment occurs, the reference count is incremented. Every time an instance's destructor is fired, the reference count for the raw T* is decremented. Once it is 0, the pointer is freed.

        std::vector< shared_ptr<T> > tPtrVec;
        {
             shared_ptr<T> tPtr(new T());
             // This copy to tPtrVec.push_back and ultimately to the vector storage
             // causes the reference count to go from 1->2
             tPtrVec.push_back(tPtr);
             // num references to T goes from 2->1 on the destruction of tPtr
        }
        tPtrVec[0]->DoSomething(); // raw T* still exists, so this is safe

weak_ptr is a non-owning smart pointer. It is used to reference a managed object (managed by a shared_ptr) without adding a reference count. Normally, you would need to get the raw pointer out of the shared_ptr and copy that around. But that would not be safe, as you would not have a way to check when the object was actually deleted. So, weak_ptr provides means by referencing an object managed by shared_ptr. If you need to access the object, you can lock the management of it (to avoid that in another thread a shared_ptr frees it while you use the object) and then use it. If the weak_ptr points to an object already deleted, it will notice you by throwing an exception. Using weak_ptr is most beneficial when you have a cyclic reference: Reference counting cannot easily cope with such a situation.

    weak_ptr is a weak-reference to a shared pointer that requires you to check to see if the pointed-to shared_ptr is still around

        std::vector< weak_ptr<T> > tPtrVec;
        {
             shared_ptr<T> tPtr(new T());
             tPtrVec.push_back(tPtr);
             // num references to T goes from 1->0
        }
        shared_ptr<T> tPtrAccessed =  tPtrVec[0].lock();
        if (tPtrAccessed[0].get() == 0)
        {
             cout << "Raw T* was freed, can't access it"
        }
        else
        {
             tPtrVec[0]->DoSomething(); // raw 
        }

    intrusive_ptr is like a shared_ptr but it does not keep the reference count in a shared_ptr but leaves incrementing/decrementing the count to some helper functions that need to be defined by the object that is managed. This has the advantage that an already referenced object (which has a reference count incremented by an external reference counting mechanism) can be stuffed into an intrusive_ptr - because the reference count is not anymore internal to the smart pointer, but the smart pointer uses an existing reference counting mechanism.

    intrusive_ptr is typically used when there is a 3rd party smart ptr you must use. It will call a free function to add and decrement the reference count.See the link to boost documentation for more info.

    unique_ptr is a transfer of ownership pointer. You cannot copy it, but you can move it by using C++1x's move constructors:

    unique_ptr<type> p(new type);
    unique_ptr<type> q(p); // not legal!
    unique_ptr<type> r(move(p)); // legal. p is now empty, but r owns the object
    unique_ptr<type> s(function_returning_a_unique_ptr()); // legal!

    This is the semantic that std::auto_ptr obeys, but because of missing native support for moving, it fails to provide them without pitfalls. unique_ptr will automatically steal resources from a temporary other unique_ptr which is one of the key features of move semantics. auto_ptr will be deprecated in the next C++ Standard release in favor of unique_ptr. C++1x will also allow stuffing objects that are only movable but not copyable into containers. So you can stuff unique_ptr's into a vector for example.

96c.
When is std::weak_ptr useful
http://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful

    Creating a weak pointer out of a shared pointer increases the weak reference counter of the shared pointer.
    This means that the shared pointer shares it resource with another pointer.

    A good example would be a cache.
    For recently accessed objects, you want to keep them in memory, so you hold a strong pointer to them.
    Periodically, you scan the cache and decide which objects have not been accessed recently.
    You don't need to keep those in memory, so you get rid of the strong pointer.

    But what if that object is in use and some other code holds a strong pointer to it? If the cache gets rid of its only pointer to the object, it can never find it again.
    So the cache keeps a weak pointer to objects that it needs to find if they happen to stay in memory.

    This is exactly what a weak pointer does -- it allows you to locate an object if it's still around, but doesn't keep it around if nothing else needs it.

    std::weak_ptr is a very good way to solve the dangling pointer problem.
    By just using raw pointers it is impossible to know if the referenced data has been deallocated or not.
    Instead, by letting a std::shared_ptr manage the data, and supplying std::weak_ptr to users of the data, the users can check validity of the data by calling expired() or lock().

    You could not do this with std::shared_ptr alone, because all std::shared_ptr instances share the ownership of the data which is not removed before all instances of std::shared_ptr are removed.
    Here is an example of how to check for dangling pointer using lock():
        #include <iostream>
        #include <memory>

        int main()
        {
            // OLD, problem with dangling pointer
            // PROBLEM: ref will point to undefined data!

            int* ptr = new int(10);
            int* ref = ptr;
            delete ptr;

            // NEW
            // SOLUTION: check expired() or lock() to determine if pointer is valid

            // empty definition
            std::shared_ptr<int> sptr;

            // takes ownership of pointer
            sptr.reset(new int);
            *sptr = 10;

            // get pointer to data without taking ownership
            std::weak_ptr<int> weak1 = sptr;

            // deletes managed object, acquires new pointer
            sptr.reset(new int);
            *sptr = 5;

            // get pointer to new data without taking ownership
            std::weak_ptr<int> weak2 = sptr;

            // weak1 is expired!

            if(auto tmp = weak1.lock())
                std::cout << *tmp << '\n';
            else
                std::cout << "weak1 is expired\n";

            // weak2 points to new data (5)

            if(auto tmp = weak2.lock())
                std::cout << *tmp << '\n';
            else
                std::cout << "weak2 is expired\n";
        }

96d.
Scoped Pointer vs Unique Pointer
http://stackoverflow.com/questions/8199812/difference-between-boostscoped-ptrt-and-stdunique-ptrt

    A difference between boost::scoped_ptr<T> and std::unique_ptr<T> the fact that,
        std::unique_ptr<T> has move semantics whereas
        boost::scoped_ptr<T> is just a get/reset smart pointer

    The other major difference is that unique_ptr can have a destructor object with it, similarly to how shared_ptr can.
    Unlike shared_ptr, the destructor type is part of the unique_ptr's type (the way allocators are part of STL container types).

    unique_ptr owns an object exclusively.
    It is non-copyable but supports transfer-of-ownership.
    It was introduced as replacement for the now deprecated auto_ptr.

    scoped_ptr is neither copyable nor movable.
    It is the preferred choice when you want to make sure pointers are deleted when going out of scope.

    Another preferred choice when you want to make sure that pointers are deleted at the end of a scope was unique_ptr<T> const

97.
Vector - Accessing member elements using "at()" vs "[]"
http://stackoverflow.com/questions/9376049/vectorat-vs-vectoroperator
    Vector.at() is SLOWER than vector[]

    IMP: Use vector.at() when INDEX is not in your control.

98.
Created Vectors of User defined size
http://stackoverflow.com/questions/10559283/how-to-create-a-vector-of-user-defined-size

    // create a vector with 20 integer elements
    std::vector<int> arr(20);

99.
How to use memset or fill_n to initialize a dynamic two dimensional TwoD array in C++
http://stackoverflow.com/questions/36506331/how-to-use-memset-or-fill-n-to-initialize-a-dynamic-two-dimensional-array-in-c

    1.
    I think that your main problem here is that you don't have an array of int values.
    You have an array of pointers to ints.

    You probably should start with int* abc = new int[rows * cols]; and work from there, if I understand what you are trying to achieve here.

    2.
        int **abc = new int*[rows];
        for (uint32_t i = 0; i < rows; i++)
        {
            abc[i] = new int[cols];
            std::fill_n(abc[i], cols, 1);
        }
    
100.
Unique Lock
http://www.cplusplus.com/reference/mutex/unique_lock/

    A unique lock is an object that manages a mutex object with unique ownership in both states: locked and unlocked.

    On construction (or by move-assigning to it), the object acquires a mutex object, for whose locking and unlocking operations becomes responsible.

    The object supports both states: locked and unlocked.

    This class guarantees an unlocked status on destruction (even if not called explicitly). Therefore it is especially useful as an object with automatic duration, as it guarantees the mutex object is properly unlocked in case an exception is thrown.

101.
Condition Variable
http://www.cplusplus.com/reference/condition_variable/condition_variable/wait/
    wait()
    notify_one()

102.
Lock_guard vs Unique_lock
http://stackoverflow.com/questions/20516773/stdunique-lockstdmutex-or-stdlock-guardstdmutex

    lock_guard and unique_lock are pretty much the same thing; lock_guard is a restricted version with a limited interface.

    A lock_guard always holds a lock from its construction to its destruction.
    A lock_guard can't transfer ownership of a lock
    A unique_lock can be created without immediately locking, can unlock at any point in its existence, and can transfer ownership of the lock from one instance to another.

    So you always use lock_guard, unless you need the capabilities of unique_lock.
    A condition_variable needs a unique_lock.

    The class lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a mutex for the duration of a scoped block.

    When a lock_guard object is created, it attempts to take ownership of the mutex it is given.
    When control leaves the scope in which the lock_guard object was created, the lock_guard is destructed and the mutex is released. 

        #include <thread>
        #include <mutex>
        #include <iostream>
         
        int g_i = 0;
        std::mutex g_i_mutex;  // protects g_i
         
        void safe_increment()
        {
            std::lock_guard<std::mutex> lock(g_i_mutex);
            ++g_i;
         
            std::cout << std::this_thread::get_id() << ": " << g_i << '\n';
         
            // g_i_mutex is automatically released when lock
            // goes out of scope
        }
         
        int main()
        {
            std::cout << __func__ << ": " << g_i << '\n';
         
            std::thread t1(safe_increment);
            std::thread t2(safe_increment);
         
            t1.join();
            t2.join();
         
            std::cout << __func__ << ": " << g_i << '\n';
        }
103.
Recursive Mutex
    The same lock can be obtained by the same thread multiple times.

104.
Lock vs Mutex vs Condition Variable
http://stackoverflow.com/questions/1055398/differences-between-conditional-variables-mutexes-and-locks

    "mutex" is the actual low-level synchronizing primitive.
    You can take a mutex and then release it, and only one thread can take it at any single time (hence it is a synchronizing primitive).
    A recursive mutex is one which can be taken by the same thread multiple times, and then it needs to be released as many times by the same thread before others can take it.

    A "lock" here is just a C++ wrapper class that takes a mutex in its constructor and releases it at the destructor.
    It is useful for establishing synchronizing for C++ scopes.

    A condition variable is a more advanced / high-level form of synchronizing primitive which combines a lock with a "signaling" mechanism.
    It is used when threads need to wait for a resource to become available.
    A thread can "wait" on a CV and then the resource producer can "signal" the variable, in which case the threads who wait for the CV get notified and can continue execution.
    A mutex is combined with CV to avoid the race condition where a thread starts to wait on a CV at the same time another thread wants to signal it; then it is not controllable whether the signal is delivered or gets lost.

105.
Need for THIS Pointer
http://stackoverflow.com/questions/577243/is-there-any-reason-to-use-this
    1. When the name of the formal argument is same as actual argument.
    2. For templates

    The only place where it really makes a difference is in templates in derived classes:

        template<typename T>
        class A {
        protected:
          T x;
        };

        template<typename T>
        class B : A<T> {
        public:
          T get() {
            return this->x;
          }
        };

    Due to details in the name lookup in C++ compilers, it has to be made explicitly clear that x is a (inherited) member of the class, most easily done with this->x.
    But this is a rather esoteric case, if you don't have templated class hierarchies you don't really need to explicitly use this to access members of a class.

106.
Sort Unordered Map
http://stackoverflow.com/questions/24212356/why-stl-unordered-map-and-unordered-set-cannot-be-sorted-by-stl-algorithms

    unordered containers store internally hashed data and thus it's not possible to order them after the hash has been generated.

    In order to sort the data you can use an additional non-hashed container (e.g. map or set) and either use them along with the unordered version (so you can use the normal one to sort the data and the unordered one to have fast per-item access) or you can do something like

    std::map<int, int> ordered(unordered.begin(), unordered.end());
    for(auto it = ordered.begin(); it != ordered.end(); ++it)
         std::cout << it->second;

107.
IMP: Using [] operator in unordered_map inserts the element if not present.
http://www.cplusplus.com/reference/unordered_map/unordered_map/operator[]/
    
    If k matches the key of an element in the container, the function returns a reference to its mapped value.

    If k does not match the key of any element in the container, the function inserts a new element with that key and returns a reference to its mapped value.
    Notice that this always increases the container size by one, even if no mapped value is assigned to the element (the element is constructed using its default constructor).

    IMP: Use .at() method instead

108. 
Create a vector of userdefined size and initialize with default values

    vector<int32_t> sumArr1(divNum, 0);
    vector<uint32_t> sumArr1(4, 0);

108b.
Create a vector with an element using constructor

    vector<int> {5}

109.
Copy from one vector to another
http://stackoverflow.com/questions/644673/fast-way-to-copy-one-vector-into-another

    1) vector a = b;
    2) vector<int> new_(original);

110.
Copy Constructor vs Assignment Operator:
    A copy constructor is used to initialize a previously uninitialized object from some other object's data.

        A(const A& rhs) : data_(rhs.data_) {}

    An assignment operator is used to replace the data of a previously initialized object with some other object's data.

        A& operator=(const A& rhs) {data_ = rhs.data_; return *this;}

    Copy constructor is called when a new object is created from an existing object, as a copy of the existing object (see this G-Fact). And assignment operator is called when an already initialized object is assigned a new value from another existing object.
        t2 = t1;  // calls assignment operator, same as "t2.operator=(t1);"
        Test t3 = t1;  // calls copy constructor, same as "Test t3(t1);"

        class Test
        {
        public:
           Test() {}
           Test(const Test &t)
           {
              cout<<"Copy constructor called "<<endl;
           }
           Test& operator = (const Test &t)
           {
              cout<<"Assignment operator called "<<endl;
           }
        };
         
        int main()
        {
          Test t1, t2;
          t2 = t1;      // Assignment operator
          Test t3 = t1; // Copy Constructor
        }

111.
Volatile keyword:
http://stackoverflow.com/questions/246127/why-is-volatile-needed-in-c

        quit = 0;
        while (!quit)
        {
            /* very small loop which is completely visible to the compiler */
        }

    The compiler is allowed to notice the loop body does not touch the quit variable and convert the loop to a while (true) loop.
    Even if the quit variable is set on the signal handler for SIGINT and SIGTERM; the compiler has no way to know that

112.
How do you declare an interface in C++
    Make a class with pure virtual methods. Use the interface by creating another class that overrides those virtual methods.

    class IDemo
    {
        public:
            virtual ~IDemo() {}
            virtual void OverrideMe() = 0;
    }

    class Child : public IDemo
    {
        public:
            virtual void OverrideMe()
            {
                //do stuff
            }
    }   

113.
Multiple Inheritence in C++
http://www.geeksforgeeks.org/multiple-inheritance-in-c/
    IT creates the Diamond problem.
         A
        /  \
       B    C
        \  /
         D

    - Can be solved by making the BASE class virtual.

114.
Exception handling in C++
http://stackoverflow.com/questions/7480146/difference-between-exception-handling-in-c-and-java
    Question:
        In Java, if a specific line of code causes the program to crash, then the exception is caught and the program continues to execute.

        However, in C++, if I have a piece of code that causes the program to crash, like:

        try
        {
            int x = 6;
            int *p = NULL;
            p = reinterpret_cast<int*>(x);

            *p = 10; // the program crashed here

            cout << "x = " << *p << endl;
        }
        catch(const char* Message)
        {
            cout << "There is an run-time error";
        }

        Then the program still crash and the exception is not caught

    Answer:
        The line that crashes is dereferencing an invalid pointer.
        In C++ this will not throw an exception. Instead it is undefined behaviour.

        There's no such thing as a null pointer exception in C++, unlike Java which will throw a null pointer exception.
        Instead dereferencing an invalid pointer will lead to undefined behaviour.

    How to use exception in C++ - Example
      try
      {
        int* myarray= new int[1000];
      }
      catch (exception& e)
      {
        cout << "Standard exception: " << e.what() << endl;
      }

115.
Side effects of macros:
https://gcc.gnu.org/onlinedocs/cpp/Duplication-of-Side-Effects.html

        Many C programs define a macro min, for “minimum”, like this:
         #define min(X, Y)  ((X) < (Y) ? (X) : (Y))

        When you use this macro with an argument containing a side effect, as shown here,
         next = min (x + y, foo (z));

        it expands as follows:
         next = ((x + y) < (foo (z)) ? (x + y) : (foo (z)));

        foo (z) gets executed twice.

116.
Macros vs Inline Function:
http://stackoverflow.com/questions/1137575/inline-functions-vs-preprocessor-macros

    - Macros are not type safe, and can be expanded regardless of whether they are syntatically correct - the compile phase will report errors resulting from macro expansion problems.
    - Macros can be used in context where you don't expect, resulting in problems
    - Macros are more flexible, in that they can expand other macros - whereas inline functions don't necessarily do this.
    - Macros can result in side effects because of their expansion, since the input expressions are copied wherever they appear in the pattern.
    - Inline function are not always guaranteed to be inlined - some compilers only do this in release builds, or when they are specifically configured to do so. Also, in some cases inlining may not be possible.
    - Inline functions can provide scope for variables (particularly static ones), preprocessor macros can only do this in code blocks {...}, and static variables will not behave exactly the same way.
 
117.
What is Arithmetic Overflow and Underflow
http://stackoverflow.com/questions/6360049/what-are-arithmetic-underflow-and-overflow-in-c

    The situation where an integer outside the allowed range requires more bits than can be stored is called an overflow.

    Underflow
        Similarly, with real numbers, an exponent that is too small to be stored causes an underflow.

        The condition in a computer program that can occur when the true result of a floating point operation is smaller in magnitude (that is, closer to zero) than the smallest value representable as a normal floating point number in the target datatype.

118.
How to detect integer overflow in C/C++
http://stackoverflow.com/questions/199333/how-to-detect-integer-overflow-in-c-c
http://www.cplusplus.com/articles/DE18T05o/

    Overflow can only occur when sign of numbers being added is the same (which will always be the case in unsigned numbers)
    signed overflow can be easily detected by seeing that its sign is opposite to that of the operands.

    For addition, any two operands will result in (at most) one bit more than the largest operand's highest one-bit. For example:
        bool addition_is_safe(uint32_t a, uint32_t b) {
            size_t a_bits=highestOneBitPosition(a), b_bits=highestOneBitPosition(b);
            return (a_bits<32 && b_bits<32);
        }

    For multiplication, any two operands will result in (at most) the sum of the bits of the operands. For example:
        bool multiplication_is_safe(uint32_t a, uint32_t b) {
            size_t a_bits=highestOneBitPosition(a), b_bits=highestOneBitPosition(b);
            return (a_bits+b_bits<=32);
        }

    Similarly, you can estimate the maximum size of the result of a to the power of b like this:
        bool exponentiation_is_safe(uint32_t a, uint32_t b) {
            size_t a_bits=highestOneBitPosition(a);
            return (a_bits*b<=32);
        }

    (Substitute the number of bits for your target integer, of course.)

    I'm not sure of the fastest way to determine the position of the highest one-bit in a number, here's a brute-force method:
        size_t highestOneBitPosition(uint32_t a) {
            size_t bits=0;
            while (a!=0) {
                ++bits;
                a>>=1;
            };
            return bits;
        }

119.
Usage of Templates Function and Class
http://www.codeproject.com/Articles/257589/An-Idiots-Guide-to-Cplusplus-Templates-Part#ClassTempl

    // Read a request
    GetData<DataType>(&_chain, sizeof(header), resultData);

    template<class T>
    int GetData(Chain* chain, uint32_t offset, T*& pStruct)
    {
        uint8_t* pData = NULL;

        Chk(chain->getDataVolatile(offset, sizeof(T), pData));
        pStruct = reinterpret_cast<T*>(pData);
    }

120.
Passing a 2D array to a C++ function
http://stackoverflow.com/questions/8767166/passing-a-2d-array-to-a-c-function

    FIXED SIZE

    1. Pass by reference

        template <size_t rows, size_t cols>
        void process_2d_array_template(int (&array)[rows][cols])
        {
            std::cout << __func__ << std::endl;
            for (size_t i = 0; i < rows; ++i)
            {
                std::cout << i << ": ";
                for (size_t j = 0; j < cols; ++j)
                    std::cout << array[i][j] << '\t';
                std::cout << std::endl;
            }
        }

        In C++ passing the array by reference without losing the dimension information is probably the safest, since one needn't worry about the caller passing an incorrect dimension (compiler flags when mismatching).
        However, this isn't possible with dynamic (freestore) arrays; it works for automatic (usually stack-living) arrays only i.e. the dimensionality should be known at compile time.

    2. Pass by pointer

        void process_2d_array_pointer(int (*array)[5][10])
        {
            std::cout << __func__ << std::endl;
            for (size_t i = 0; i < 5; ++i)
            {
                std::cout << i << ": ";
                for (size_t j = 0; j < 10; ++j)
                    std::cout << (*array)[i][j] << '\t';
                std::cout << std::endl;
            }    
        }

    The C equivalent of the previous method is passing the array by pointer.
    This should not be confused with passing by the array's decayed pointer type (3), which is the common, popular method, albeit less safe than this one but more flexible.
    Like (1), use this method when all the dimensions of the array is fixed and known at compile-time.
    Note that when calling the function the array's address should be passed process_2d_array_pointer(&a) and not the address of the first element by decay process_2d_array_pointer(a)

    Variable Size
    These are inherited from C but are less safe, the compiler has no way of checking, guaranteeing that the caller is passing the required dimensions.
    The function only banks on what the caller passes in as the dimension(s).
    These are more flexible than the above ones since arrays of different lengths can be passed to them invariably.

    It is to be remembered that there's no such thing as passing an array directly to a function in C [while in C++ they can be passed as a reference (1)]; (2) is passing a pointer to the array and not the array itself.
    Always passing an array as-is becomes a pointer-copy operation which is facilitated by array's nature of decaying into a pointer.

    3. Pass by (value) a pointer to the decayed type

        // int array[][10] is just fancy notation for the same thing
        void process_2d_array(int (*array)[10], size_t rows)
        {
            std::cout << __func__ << std::endl;
            for (size_t i = 0; i < rows; ++i)
            {
                std::cout << i << ": ";
                for (size_t j = 0; j < 10; ++j)
                    std::cout << array[i][j] << '\t';
                std::cout << std::endl;
            }
        }

    Although int array[][10] is allowed, I'd not recommend it over the above syntax since the above syntax makes it clear that the identifier array is a single pointer to an array of 10 integers, while this syntax looks like it's a 2D array but is the same pointer to an array of 10 integers.
    Here we know the number of elements in a single row (i.e. the column size, 10 here) but the number of rows is unknown and hence to be passed as an argument.
    In this case there's some safety since the compiler can flag when a pointer to an array with second dimension not equal to 10 is passed.
    The first dimension is the varying part and can be omitted.

    4. Pass by pointer to a pointer

        // int *array[10] is just fancy notation for the same thing
        void process_pointer_2_pointer(int **array, size_t rows, size_t cols)
        {
            std::cout << __func__ << std::endl;
            for (size_t i = 0; i < rows; ++i)
            {
                std::cout << i << ": ";
                for (size_t j = 0; j < cols; ++j)
                    std::cout << array[i][j] << '\t';
                std::cout << std::endl;
            }
        }

    Again there's an alternative syntax of int *array[10] which is the same as int **array.
    In this syntax the [10] is ignored as it decays into a pointer thereby becoming int **array.
    Perhaps it is just a cue to the caller that the passed array should have at least 10 columns, even then row count is required.
    In any case the compiler doesn't flag for any length/size violations (it only checks if the type passed is a pointer to pointer), hence requiring both row and column counts as parameter makes sense here.

    Note: (4) is the least safest option since it hardly has any type check and the most inconvenient.
    One cannot legitimately pass a 2D array to this function; C-FAQ condemns the usual workaround of doing int x[5][10]; process_pointer_2_pointer((int**)&x[0][0], 5, 10); as it may potentially lead to undefined behaviour due to array flattening.
    The right way of passing an array in this method brings us to the inconvenient part i.e. we need an additional (surrogate) array of pointers with each of its element pointing to the respective row of the actual, to-be-passed array; this surrogate is then passed to the function (see below); all this for getting the same job done as the above methods which are more safer, cleaner and perhaps faster.

121.
Custom Comparator for Priority Queue
http://stackoverflow.com/questions/16111337/declaring-a-priority-queue-in-c-with-a-custom-comparator
http://stackoverflow.com/questions/20826078/priority-queue-comparison
http://fusharblog.com/3-ways-to-define-comparison-functions-in-cpp/

        double computeDistanceFromOrigin(int x, int y)
        {
            return sqrt(((double)x * x) + ((double)y * y));
        }

        bool compGreater(pair<int, int> x, pair<int, int> y)
        {
            return computeDistanceFromOrigin(x.first, x.second) < computeDistanceFromOrigin(y.first, y.second);
        }

        void findKclosestPoints(vector<pair<int, int> >& pointsList, uint32_t k)
        {
            priority_queue< pair<int, int>, vector<pair<int, int> >, std::function<bool(pair<int, int>, pair<int, int>)> > kClosest(compGreater);
            uint32_t i = 0;
            for (; i < k; i++)
            {
                kClosest.push(pointsList[i]);
            }
        }

    EXAMPLE 2:
        struct MeetingTime
        {
            int startTime;
            int endTime;

            MeetingTime(double sT, double eT) : startTime(sT),
                                                endTime(eT) { }

            bool operator < (const MeetingTime& meetTime) const
            {
                return (startTime < meetTime.startTime);
            }

            bool operator > (const MeetingTime& meetTime) const
            {
                return (endTime > meetTime.endTime);
            }
        };

        vector<struct MeetingTime> meetingsEndTimeSort;
        sort(meetingsEndTimeSort.begin(), meetingsEndTimeSort.end(), greater<MeetingTime>());

122.
C++ Erase vector element by value rather than by position
http://stackoverflow.com/questions/3385229/c-erase-vector-element-by-value-rather-than-by-position

        5 9 2 8 0 7

        #include <algorithm>
        ...
        vec.erase(std::remove(vec.begin(), vec.end(), 8), vec.end());

    Take a look at the description of remove(): It moves all values not equal to the value passed to the beginning of the range [begin,end).
    With your example in the question you'd get 5,9,2,0,7,7.
    As remove() however returns an iterator to the new end, vec.erase() can remove the obsolete elements (i.e. the second 7 here) if that is needed.

123.
Function Pointers and Callbacks
http://stackoverflow.com/questions/8975208/whats-the-use-of-function-pointers
http://stackoverflow.com/questions/2592137/what-is-the-point-of-function-pointers

    Most examples boil down to callbacks:
    You call a function f() passing the address of another function g(), and f() calls g() for some specific task.
    If you pass f() the address of h() instead, then f() will call back h() instead.

     Callers can make f() behave differently by passing different callback functions.
     A classic is qsort() from the C standard library that takes its sorting criterion as a pointer to a comparison function. 

        int buttonID = CreateButton ("Click Me!", 100, 100, 200, 100, onClick);
    This would create a button at (100,100) with width 200 and height 100.
    Every time you click it, onClick is called.

http://stackoverflow.com/questions/1758564/what-are-function-pointers-used-for-and-how-would-i-use-them
    A simple case is like this: You have an array of operations (functions) according to your business logic.
    You have a hashing function that reduces an input problem to one of the business logic functions.
    A clean code would have an array of function pointers, and your program will deduce an index to that array from the input and call it.

    Here is a sample code:
        typedef void (*fn)(void) FNTYPE;
        FNTYPE fn_arr[5];

        fn_arr[0] = fun1; // fun1 is previously defined
        fn_arr[1] = fun2;
        ...

        void callMyFun(string inp) {
            int idx = decideWhichFun(inp); // returns an int between 0 and 4
            fn_arr[idx]();
        }

    But of course, callbacks are the most common usage. Sample code below:
        void doLengthyOperation(string inp, void (*callback)(string status)) {
          // do the lengthy task
          callback("finished");
        }

        void fnAfterLengthyTask(string status) {
            cout << status << endl;
        }

        int main() {
            doLengthyOperation(someinput, fnAfterLengthyTask);
        }

http://www.geeksforgeeks.org/function-pointer-in-c/
    Function pointer can be used in place of switch case.
    For example, in below program, user is asked for a choice between 0 and 2 to do different tasks.

        #include <stdio.h>
        void add(int a, int b)
        {
            printf("Addition is %d\n", a+b);
        }
        void subtract(int a, int b)
        {
            printf("Subtraction is %d\n", a-b);
        }
        void multiply(int a, int b)
        {
            printf("Multiplication is %d\n", a*b);
        }
         
        int main()
        {
            // fun_ptr_arr is an array of function pointers
            void (*fun_ptr_arr[])(int, int) = {add, subtract, multiply};
            unsigned int ch, a = 15, b = 10;
         
            printf("Enter Choice: 0 for add, 1 for subtract and 2 "
                    "for multiply\n");
            scanf("%d", &ch);
         
            if (ch > 2) return 0;
         
            (*fun_ptr_arr[ch])(a, b);
         
            return 0;
        }

    For example a simple qsort() function can be used to sort arrays in ascending order or descending or by any other order in case of array of structures.
    Not only this, with function pointers and void pointers, it is possible to use qsort for any data type.
        // A sample comparator function that is used
        // for sorting an integer array in ascending order.
        // To sort any array for any other data type and/or
        // criteria, all we need to do is write more compare
        // functions.  And we can use the same qsort()
        int compare (const void * a, const void * b)
        {
          return ( *(int*)a - *(int*)b );
        }
         
        int main ()
        {
          int arr[] = {10, 5, 15, 12, 90, 80};
          int n = sizeof(arr)/sizeof(arr[0]), i;
         
          qsort (arr, n, sizeof(int), compare);
         
          for (i=0; i<n; i++)
             printf ("%d ", arr[i]);
          return 0;
        }

    // A compare function that is used for searching an integer array
        bool compare (const void * a, const void * b)
        {
          return ( *(int*)a == *(int*)b );
        }
         
        // General purpose search() function that can be used
        // for searching an element *x in an array arr[] of
        // arr_size. Note that void pointers are used so that
        // the function can be called by passing a pointer of
        // any type.  ele_size is size of an array element
        int search(void *arr, int arr_size, int ele_size, void *x,
                   bool compare (const void * , const void *))
        {
            // Since char takes one byte, we can use char pointer
            // for any type/ To get pointer arithmetic correct,
            // we need to multiply index with size of an array
            // element ele_size
            char *ptr = (char *)arr;
         
            int i;
            for (i=0; i<arr_size; i++)
                if (compare(ptr + i*ele_size, x))
                   return i;
         
            // If element not found
            return -1;
        }
         
        int main()
        {
            int arr[] = {2, 5, 7, 90, 70};
            int n = sizeof(arr)/sizeof(arr[0]);
            int x = 7;
            printf ("Returned index is %d ", search(arr, n,
                                       sizeof(int), &x, compare));
            return 0;
        }

123b.
How do function pointers in C work
http://stackoverflow.com/questions/840501/how-do-function-pointers-in-c-work

    Function pointers are useful for passing functions as parameters to other functions

    Let's start with a basic function which we will be pointing to:
        int addInt(int n, int m) {
            return n+m;
        }

    First thing, lets define a pointer to a function which receives 2 ints and returns and int:
        int (*functionPtr)(int,int);

    Now we can safely point to our function:
        functionPtr = &addInt;

    Now that we have a pointer to the function, lets use it:
        int sum = (*functionPtr)(2, 3); // sum == 5

    Passing the pointer to another function is basically the same:
        int add2to3(int (*functionPtr)(int, int)) {
            return (*functionPtr)(2, 3);
        }

    We can use function pointers in return values as well (try to keep up, it gets messy):
        // this is a function called functionFactory which receives parameter n
        // and returns a pointer to another function which receives two ints
        // and it returns another int
        int (*functionFactory(int n))(int, int) {
            printf("Got parameter %d", n);
            int (*functionPtr)(int,int) = &addInt;
            return functionPtr;
        }

    But it's much nicer to use a typedef:
        typedef int (*myFuncDef)(int, int);
        // note that the typedef name is indeed myFuncDef

        myFuncDef functionFactory(int n) {
            printf("Got parameter %d", n);
            myFuncDef functionPtr = &addInt;
            return functionPtr;
        }

124.
Registering a Callback
http://stackoverflow.com/questions/8590335/what-do-you-mean-by-registering-a-callback-function-in-c?lq=1
http://stackoverflow.com/questions/142789/what-is-a-callback-in-c-and-how-are-they-implemented

    Registering a callback function simply means that you are arranging for an external entity to call your function.

    void populate_array(int *array, size_t arraySize, int (*getNextValue)(void))
    {
        for (size_t i=0; i<arraySize; i++)
            array[i] = getNextValue();
    }

    int getNextRandomValue(void)
    {
        return rand();
    }

    int main(void)
    {
        int myarray[10];
        populate_array(myarray, 10, getNextRandomValue);
        ...
    }

125.
Functors in C++ 
http://stackoverflow.com/questions/2592137/what-is-the-point-of-function-pointers

    In C++, this is often done using function objects (also called functors).
    These are objects that overload the function call operator, so you can call them as if they were a function.

    Example:
        class functor {
          public:
             void operator()(int i) {std::cout << "the answer is: " << i << '\n';}
        };

        functor f;
        f(42);

    The idea behind this is that, unlike a function pointer, a function object can carry not only an algorithm, but also data:

        class functor {
          public:
             functor(const std::string& prompt) : prompt_(prompt) {}
             void operator()(int i) {std::cout << prompt_ << i << '\n';}
          private:
             std::string prompt_;
        };

        functor f("the answer is: ");
        f(42);

    Another advantage is that it is sometimes easier to inline calls to function objects than calls through function pointers.
    This is a reason why sorting in C++ is sometimes faster than sorting in C. 

126.
Operator Overloading in C++
http://stackoverflow.com/questions/4421706/operator-overloading/4421791#4421791
http://www.thegeekstuff.com/2013/09/cpp-operator-overloading/?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed:+TheGeekStuff+(The+Geek+Stuff)

    VERY IMP:
        Make it a friend to have access to private memebers

    Not all operators can be overloaded in C++.
    Among the operators that cannot be overloaded are: . :: sizeof typeid .* and the only ternary operator in C++, ?:

        #include <iostream>
        class example
        {
        public:
            int a;
            int b;
            example operator+(const example& obj);
            void operator=(const example& obj);
        };

        void example::operator=(const example& obj)
        {
            (*this).a = obj.a;
            (*this).b = obj.b;

            return;
        }

        example example::operator+(const example& obj2)
        {
            example tmp_obj = *this;
            tmp_obj.a = tmp_obj.a + obj2.a;
            tmp_obj.b = tmp_obj.b + obj2.b;
            return tmp_obj;
        }

        int main(void)
        {
            example obj1, obj2, obj3;

            obj1.a = 1;
            obj1.b = 1;

            obj2.a = 2;
            obj2.b = 2;

            obj3.a = 0;
            obj3.b = 0;

            obj3 = obj1 + obj2;

            std::cout<<obj3.a<<"  "<<obj3.b<<"\n";

            return 0;
        }

    In the example above :
    When ‘obj1 + obj2’ is encountered, function corresponding to overloaded  operator + is called.
    You can think of ‘obj1 + obj2’ as something like ‘obj1.add(obj2)’.
    The function corresponding to overloaded operator + is called in context of obj1 and hence only obj2 is needed to be passed as argument.
    obj1 can be accessed through ‘this’ pointer in that function.
    Here in this function, individual integer member is added and the resultant object is returned.

        class Time
        {
           private:
              int hours;             // 0 to 23
              int minutes;           // 0 to 59
           public:
              // required constructors
              Time(){
                 hours = 0;
                 minutes = 0;
              }
              Time(int h, int m){
                 hours = h;
                 minutes = m;
              }
              // method to display time
              void displayTime()
              {
                 cout << "H: " << hours << " M:" << minutes <<endl;
              }

              // overloaded prefix ++ operator
              Time operator++ ()  
              {
                 ++minutes;          // increment this object
                 if(minutes >= 60)  
                 {
                    ++hours;
                    minutes -= 60;
                 }
                 return Time(hours, minutes);
              }

              // overloaded postfix ++ operator
              Time operator++( int )         
              {
                 // save the orignal value
                 Time T(hours, minutes);
                 // increment this object
                 ++minutes;                    
                 if(minutes >= 60)
                 {
                    ++hours;
                    minutes -= 60;
                 }
                 // return old original value
                 return T; 
              }
        };
        int main()
        {
           Time T1(11, 59), T2(10,40);
         
           ++T1;                    // increment T1
           T1.displayTime();        // display T1
           ++T1;                    // increment T1 again
           T1.displayTime();        // display T1
         
           T2++;                    // increment T2
           T2.displayTime();        // display T2
           T2++;                    // increment T2 again
           T2.displayTime();        // display T2
           return 0;
        }

Overloading new and delete

    BASICS
    In C++, when you write a new expression like new T(arg) two things happen when this expression is evaluated: First operator new is invoked to obtain raw memory, and then the appropriate constructor of T is invoked to turn this raw memory into a valid object.
    Likewise, when you delete an object, first its destructor is called, and then the memory is returned to operator delete.

    C++ allows you to tune both of these operations: memory management and the construction/destruction of the object at the allocated memory.
    The latter is done by writing constructors and destructors for a class.
    Fine-tuning memory management is done by writing your own operator new and operator delete.

    The first of the basic rules of operator overloading – don’t do it – applies especially to overloading new and delete.
    Almost the only reasons to overload these operators are performance problems and memory constraints, and in many cases, other actions, like changes to the algorithms used, will provide a much higher cost/gain ratio than attempting to tweak memory management.

    The C++ standard library comes with a set of predefined new and delete operators. The most important ones are these:
        void* operator new(std::size_t) throw(std::bad_alloc); 
        void  operator delete(void*) throw(); 
        void* operator new[](std::size_t) throw(std::bad_alloc); 
        void  operator delete[](void*) throw(); 

    The first two allocate/deallocate memory for an object, the latter two for an array of objects.
    If you provide your own versions of these, they will not overload, but replace the ones from the standard library.

    If you overload operator new, you should always also overload the matching operator delete, even if you never intend to call it.
    The reason is that, if a constructor throws during the evaluation of a new expression, the run-time system will return the memory to the operator delete matching the operator new that was called to allocate the memory to create the object in.
    If you do not provide a matching operator delete, the default one is called, which is almost always wrong.

    If you overload new and delete, you should consider overloading the array variants, too.
    PLACEMENT NEW
    C++ allows new and delete operators to take additional arguments.
    So-called placement new allows you to create an object at a certain address which is passed to:
        class X { /* ... */ };
        char buffer[ sizeof(X) ];
        void f()
        { 
          X* p = new(buffer) X(/*...*/);
          // ... 
          p->~X(); // call destructor 
        } 

    The standard library comes with the appropriate overloads of the new and delete operators for this:
        void* operator new(std::size_t,void* p) throw(std::bad_alloc); 
        void  operator delete(void* p,void*) throw(); 
        void* operator new[](std::size_t,void* p) throw(std::bad_alloc); 
        void  operator delete[](void* p,void*) throw(); 

    Note that, in the example code for placement new given above, operator delete is never called, unless the constructor of X throws an exception.

    You can also overload new and delete with other arguments.
    As with the additional argument for placement new, these arguments are also listed within parentheses after the keyword new.
    Merely for historical reasons, such variants are often also called placement new, even if their arguments are not for placing an object at a specific address.

    CLASS-SPECIFIC NEW AND DELETE
    Most commonly you will want to fine-tune memory management because measurement has shown that instances of a specific class, or of a group of related classes, are created and destroyed often and that the default memory management of the run-time system, tuned for general performance, deals inefficiently in this specific case.
    To improve this, you can overload new and delete for a specific class:

        class my_class { 
          public: 
            // ... 
            void* operator new();
            void  operator delete(void*,std::size_t);
            void* operator new[](size_t);
            void  operator delete[](void*,std::size_t);
            // ... 
        }; 

    Overloaded thus, new and delete behave like static member functions.
    For objects of my_class, the std::size_t argument will always be sizeof(my_class).
    However, these operators are also called for dynamically allocated objects of derived classes, in which case it might be greater than that.

    GLOBAL NEW AND DELETE
    To overload the global new and delete, simply replace the pre-defined operators of the standard library with our own.
    However, this is rarely ever needs to be done.

127.
Scope Guard in C++
https://en.wikibooks.org/wiki/More_C++_Idioms/Scope_Guard

    Intent
        To ensure that resources are always released in face of an exception but not while returning normally
        To provide basic exception safety guarantee

    Motivation
        Resource Acquisition is Initialization (RAII) idiom allows us to acquire resources in the constructor and release them in the destructor when scope ends successfully or due to an exception.
        It will always release resources.
        This is not very flexible.
        Sometime we don't want to release resources if no exception is thrown but we do want to release them if exception is thrown.

    Solution and Sample Code
        Enhance the typical implementation of Resource Acquisition is Initialization (RAII) idiom with a conditional check.

        class ScopeGuard
        {
        public:
          ScopeGuard () 
           : engaged_ (true) 
          { /* Acquire resources here. */ }
          
          ~ScopeGuard ()  
          { 
            if (engaged_) 
             { /* Release resources here. */} 
          }
          void release () 
          { 
             engaged_ = false; 
             /* Resources no longer be released */ 
          }
        private:
          bool engaged_;
        };
        void some_init_function ()
        {
          ScopeGuard guard;
          // ...... Something may throw here. If it does we release resources.
          guard.release (); // Resources will not be released in normal execution.
        }

128.
C++11 introduced a standardized memory model. What does it mean?
http://stackoverflow.com/questions/6319146/c11-introduced-a-standardized-memory-model-what-does-it-mean-and-how-is-it-g?rq=1

    First, you have to learn to think like a Language Lawyer.

    The C++ specification does not make reference to any particular compiler, operating system, or CPU.
    It makes reference to an abstract machine that is a generalization of actual systems.
    In the Language Lawyer world, the job of the programmer is to write code for the abstract machine; the job of the compiler is to actualize that code on a concrete machine.
    By coding rigidly to the spec, you can be certain that your code will compile and run without modification on any system with a compliant C++ compiler, whether today or 50 years from now.

    The abstract machine in the C++98/C++03 specification is fundamentally single-threaded.
    So it is not possible to write multi-threaded C++ code that is "fully portable" with respect to the spec.
    The spec does not even say anything about the atomicity of memory loads and stores or the order in which loads and stores might happen, never mind things like mutexes.

    Of course, you can write multi-threaded code in practice for particular concrete systems -- like pthreads or Windows.
    But there is no standard way to write multi-threaded code for C++98/C++03.

    The abstract machine in C++11 is multi-threaded by design.
    It also has a well-defined memory model; that is, it says what the compiler may and may not do when it comes to accessing memory.

    Consider the following example, where a pair of global variables are accessed concurrently by two threads:

                   Global
                   int x, y;

        Thread 1            Thread 2
        x = 17;             cout << y << " ";
        y = 37;             cout << x << endl;

    What might Thread 2 output?
    Under C++98/C++03, this is not even Undefined Behavior; the question itself is meaningless because the standard does not contemplate anything called a "thread".

    Under C++11, the result is Undefined Behavior, because loads and stores need not be atomic in general.
    Which may not seem like much of an improvement... And by itself, it's not.

    But with C++11, you can write this:
                   Global
                   atomic<int> x, y;

        Thread 1                 Thread 2
        x.store(17);             cout << y.load() << " ";
        y.store(37);             cout << x.load() << endl;

    Now things get much more interesting.
    First of all, the behavior here is defined.
    Thread 2 could now print 0 0 (if it runs before Thread 1), 37 17 (if it runs after Thread 1), or 0 17 (if it runs after Thread 1 assigns to x but before it assigns to y).

    What it cannot print is 37 0, because the default mode for atomic loads/stores in C++11 is to enforce sequential consistency.
    This just means all loads and stores must be "as if" they happened in the order you wrote them within each thread, while operations among threads can be interleaved however the system likes.
    So the default behavior of atomics provides both atomicity and ordering for loads and stores.

    Now, on a modern CPU, ensuring sequential consistency can be expensive.
    In particular, the compiler is likely to emit full-blown memory barriers between every access here.
    But if your algorithm can tolerate out-of-order loads and stores; i.e., if it requires atomicity but not ordering;
    i.e., if it can tolerate 37 0 as output from this program, then you can write this:

                   Global
                   atomic<int> x, y;

        Thread 1                            Thread 2
        x.store(17,memory_order_relaxed);   cout << y.load(memory_order_relaxed) << " ";
        y.store(37,memory_order_relaxed);   cout << x.load(memory_order_relaxed) << endl;

    The more modern the CPU, the more likely this is to be faster than the previous example.

    Finally, if you just need to keep particular loads and stores in order, you can write:

                   Global
                   atomic<int> x, y;

        Thread 1                            Thread 2
        x.store(17,memory_order_release);   cout << y.load(memory_order_acquire) << " ";
        y.store(37,memory_order_release);   cout << x.load(memory_order_acquire) << endl;

    This takes us back to the ordered loads and stores -- so 37 0 is no longer a possible output -- but it does so with minimal overhead.
    (In this trivial example, the result is the same as full-blown sequential consistency; in a larger program, it would not be.)

    Of course, if the only outputs you want to see are 0 0 or 37 17, you can just wrap a mutex around the original code.
    But if you have read this far, I bet you already know how that works, and this answer is already longer than I intended :-).

    So, bottom line.
    Mutexes are great, and C++11 standardizes them.
    But sometimes for performance reasons you want lower-level primitives (e.g., the classic double-checked locking pattern).
    The new standard provides high-level gadgets like mutexes and condition variables, and it also provides low-level gadgets like atomic types and the various flavors of memory barrier.
    So now you can write sophisticated, high-performance concurrent routines entirely within the language specified by the standard, and you can be certain your code will compile and run unchanged on both today's systems and tomorrow's.

    Although to be frank, unless you are an expert and working on some serious low-level code, you should probably stick to mutexes and condition variables.
    That's what I intend to do.

129.
When is void* useful
http://stackoverflow.com/questions/11626786/what-does-void-mean-and-how-to-use-it?lq=1

    A pointer to void is a "generic" pointer type.
    A void * can be converted to any other pointer type without an explicit cast.
    You cannot dereference a void * or do pointer arithmetic with it; you must convert it to a pointer to an complete data type first.

    It gets used in places where you need to be able to work with different pointer types in the same code.
    One commonly cited example is the library function qsort:

        void qsort(void *base, size_t nmemb, size_t size, 
                   int (*compar)(const void *, const void *));

    base is the address of an array, nmemb is the number of elements in the array, size is the size of each element, and compar is a pointer to a function that compares two elements of the array.

    It gets called like so:
        int iArr[10];
        double dArr[30];
        long lArr[50];
        ...
        qsort(iArr, sizeof iArr/sizeof iArr[0], sizeof iArr[0], compareInt);
        qsort(dArr, sizeof dArr/sizeof dArr[0], sizeof dArr[0], compareDouble);
        qsort(lArr, sizeof lArr/sizeof lArr[0], sizeof lArr[0], compareLong);

    The array expressions iArr, dArr, and lArr are implicitly converted from array types to pointer types in the function call, and each is implicitly converted from "pointer to int/double/long" to "pointer to void".

    The comparison functions would look something like:
        int compareInt(const void *lhs, const void *rhs)
        {
          const int *x = lhs;  // convert void * to int * by assignment
          const int *y = rhs;

          if (*x > *y) return 1;
          if (*x == *y) return 0;
          return -1;
        }

130.
Virtual Destructor in C++
http://stackoverflow.com/questions/461203/when-to-use-virtual-destructors

    Virtual destructors are useful when you can delete an instance of a derived class through a pointer to base class:

        class Base 
        {
            // some virtual methods
        };

        class Derived : public Base
        {
            ~Derived()
            {
                // Do some important cleanup
            }
        }

    Here, you'll notice that I didn't declare Base's destructor to be virtual.
    Now, let's have a look at the following snippet:

        Base *b = new Derived();
        // use b
        delete b; // Here's the problem!

    Since Base's destructor is not virtual and b is a Base* pointing to a Derived object, delete b has undefined behaviour.
    In most implementations, the call to the destructor will be resolved like any non-virtual code, meaning that the destructor of the base class will be called but not the one of the derived class, resulting in resources leak.

131.
Print Unordered Map. Get key and get value

    for (auto itr = myMap.begin(); itr != myMap.end(); itr++)
    {
        cout << itr->first << ": " << itr->second.name << " , " << itr->second.score << endl;
    }

132.
Self Referential Structures
http://stackoverflow.com/questions/588623/self-referential-struct-definition

Clearly a Struct cannot contain another struct as it becomes a never-ending recursion.

However a Struct CAN contain a pointer to another struct.

    typedef struct Cell {
      bool isParent;
      struct Cell* child;
    } Cell;


133.
How to use std::sort to sort a vector
http://fusharblog.com/3-ways-to-define-comparison-functions-in-cpp/
http://www.cplusplus.com/reference/algorithm/sort/

        bool myfunction (int i,int j) { return (i<j); }

        struct myclass {
          bool operator() (int i,int j) { return (i<j);}
        } myobject;

        int main () {
          int myints[] = {32,71,12,45,26,80,53,33};
          std::vector<int> myvector (myints, myints+8);               // 32 71 12 45 26 80 53 33

          // using default comparison (operator <):
          std::sort (myvector.begin(), myvector.begin()+4);           //(12 32 45 71)26 80 53 33

          // using function as comp
          std::sort (myvector.begin()+4, myvector.end(), myfunction); // 12 32 45 71(26 33 53 80)

          // using object as comp
          std::sort (myvector.begin(), myvector.end(), myobject); 

134.
Queue vs Vector
http://stackoverflow.com/questions/14521972/can-i-use-c-vector-insted-of-queue-for-fifo-order
http://stackoverflow.com/questions/5345152/why-would-i-prefer-using-vector-to-deque

    A vector is analogous to a stack not to a queue.
    You may only push and pop from one side not push from one and pop from the other.
    A vector will give you the capability to access arbitrary element by its index in constant time but will not be able to efficiently remove elements from its beginning.

    Elements in a deque are not contiguous in memory;
    vector elements are guaranteed to be.
    So if you need to interact with a plain C library that needs contiguous arrays, or if you care (a lot) about spatial locality, then you might prefer vector.


135. 
Differences between various Custom Comparator functions in C++ 
http://stackoverflow.com/questions/38422886/differences-between-various-custom-comparator-functions-in-c

        struct Student
        {
            string name;
            uint32_t age;

            // Method 1: Using operator <
            bool operator<(const Student& ob)
            {
                return age < ob.age;
            }
        };

        // Method 2: Custom Compare Function
        bool compStudent(const Student& a, const Student& b)
        {
            return a.age < b.age;
        }

        // Method 3: Using operator ()
        struct MyStudComp
        {
            bool operator() (const Student& a, const Student& b)
            {
                return a.age < b.age;
            }
        }obComp;

    To sort a vector of students I can use either of the below methods.

        vector<Student> studs; // Consider I have this object populated
        std::sort(studs.begin(), studs.end());  // Method 1
        std::sort(studs.begin(), studs.end(), compStudent);    // Method 2
        std::sort(studs.begin(), studs.end(), obComp);  // Method 3

        // Method 4: Using Lambda
        sort(studs.begin(), studs.end(), 
             [](const Student& a, const Student& b) -> bool
             { 
                return a.age < b.age; 
             });

    The performance between the different methods is not very different, however, using < will let you be more flexible, and makes using built-ins much easier.
    I also think using () is kind of weird.

The bigger issue in your example is that your methods should be using const refs instead of values. I.e. bool operator<(Student ob) could be friend bool operator<(const Student& ls, const Student& rs){...}. Also, see here for some examples of different things to consider when overloading operators.

136.
Creating a Vector and bitset on heap
http://stackoverflow.com/questions/27449831/create-a-large-bitset

    bitset<400000000UL>& bitsVec = *(new bitset<400000000UL>());
    delete &bitsVec;

    std::vector<int>* pResult = new std::vector<int>();
    pResult->push_back(...) instead of result.push_back(...)

137.
Custom Hash Function
// http://stackoverflow.com/questions/8094790/how-to-get-hash-code-of-a-string-in-c

    #include <functional>   // Contains function for std::hash

    template<typename K, typename V, typename H >
    size_t
    HashTable<K, V, H>::computeHash(const K& key)
    {
        size_t hashVal = H()(key);
        return hashVal % _size;
    }

    static size_t
    myComputeHash(const int& key)
    {
        size_t hashVal = hash<int>()(key);
        return hashVal % 100;
    }

138.
Fastest way to reset every value of std::vector<int> to 0
http://stackoverflow.com/questions/8848575/fastest-way-to-reset-every-value-of-stdvectorint-to-0

    std::fill(v.begin(), v.end(), 0);

139.
Using find_first_not_of and find_first_of

    string tmp = "Hello. World! Hi.there!how are?you";
    string punctChars = " !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
    idx = tmp.find_first_not_of(". !?", punctIdx);
    punctIdx = (tmp.substr(idx)).find_first_of(". !?", idx);
    string res = tmp.substr(idx, punctIdx);

140.
Best way to extract a subvector from a vector?
http://stackoverflow.com/questions/421573/best-way-to-extract-a-subvector-from-a-vector

    {
        vector<T>::const_iterator first = myVec.begin() + 100000;
        vector<T>::const_iterator last = myVec.begin() + 101000;
        vector<T> newVec(first, last);
    }

    {
        std::vector<int>   data();
        // Load Z elements into data so that Z > Y > X

        std::vector<int>   sub(&data[100000],&data[101000]);
    }

141.
Running GDB on mac

    g++ -g -o geek GeeksForGeeks.cpp
    gdb ./geek
    b GeeksForGeeks.cpp:66
    run

142.
C++ enable/disable debug messages of std::couts on the fly
http://stackoverflow.com/questions/3371540/c-enable-disable-debug-messages-of-stdcouts-on-the-fly

    #define DEBUG

    #ifdef DEBUG
    #define DEBUG_MSG(str) do { std::cout << str << std::endl; } while( false )
    #else
    #define DEBUG_MSG(str) do { } while ( false )
    #endif

143.
Why use apparently meaningless do-while and if-else statements in C/C++ macros
http://stackoverflow.com/questions/1067226/c-multi-line-macro-do-while0-vs-scope-block

    Actual Usage: #define FOO(X) do { f(X); g(X); } while (0)
    What If: #define BAR(X) f(x); g(x)

		if (corge)
		  BAR(corge);
		else
		  gralt();

	The above code would expand into
		if (corge)
		  f(corge); g(corge);
		else
		  gralt();

	If IF ELSE is used for the macro, then we would have an extra else
		#define FOO(X) if (1) { f(X); g(X); } else
		if (corge)
		  if (1) { f(corge); g(corge); } else;
		else
		  gralt();

144.
Printing lists with commas C++
http://stackoverflow.com/questions/3496982/printing-lists-with-commas-c

    One common approach is to print the first item prior to the loop,
    and loop only over the remaining items, PRE-printing a comma before each remaining item.

145.
Nested Class Access Specifiers
http://stackoverflow.com/questions/6998369/c-nested-classes-accessibility

		class OutSideClass
		{
		...
		public:
			int i_pub;
		protected:
			int i_pro;
		private:
			int i_pri;

			class InSideClass
			{
				...
				public:
					int j_pub;
				protected:
					int j_pro;
				private:
					int j_pri;
			};
		};

    Question 1> Is it true that OutSideClass can ONLY access public members of InSideClass
	Yes

    Question 2> Is it true that InSideClass can access all members of OutSideClass
	No, in C++03. Yes, in C++11.

    The members of a nested class have no special access to members of an enclosing class, nor to classes or functions that have granted friendship to an enclosing class; the usual access rules (clause 11) shall be obeyed.
	The members of an enclosing class have no special access to members of a nested class; the usual access rules (clause 11) shall be obeyed.

146.
Forward Declarations
http://stackoverflow.com/questions/553682/when-can-i-use-a-forward-declaration

	Put yourself in the compiler's position:
	When you forward declare a type, all the compiler knows is that this type exists; it knows nothing about its size, members, or methods.
	This is why it's called an incomplete type.
	Therefore, you cannot use the type to declare a member, or a base class, since the compiler would need to know the layout of the type.

	Assuming the following forward declaration.
		class X;

    Declare a member to be a pointer or a reference to the incomplete type:
		class Foo {
			X *pt;
			X &pt;
		};

147.
Access Specifier: Public, Private, Default
    C++: Default is Private
    C  : Default is Public

148.
What is std::move
http://stackoverflow.com/questions/3413470/what-is-stdmove-and-when-should-it-be-used
http://thbecker.net/articles/rvalue_references/section_01.html

    In C++11, in addition to copy constructors, objects can have move constructors.
    (And in addition to copy assignment operators, they have move assignment operators.)

    It's a new C++ way to avoid copies.
    For example, using a move constructor, a std::vector could just copy its internal pointer to data to the new object, leaving the moved object in an incorrect state, avoiding to copy all data.
    This would be C++-valid.

149.
Why is sizeof empty class 1
http://stackoverflow.com/questions/2362097/why-is-the-size-of-an-empty-class-in-c-not-zero

    The standard does not allow objects (and classes thereof) of size 0, since that would make it possible for two distinct objects to have the same memory address.
    That's why even empty classes must have a size of (at least) 1.

150. Use of std::endl vs \n
http://stackoverflow.com/questions/213907/c-stdendl-vs-n
http://stackoverflow.com/questions/7324843/why-use-endl-when-i-can-use-a-newline-character

    The difference can be illustrated by the following:
        std::cout << std::endl;
    is equivalent to
        std::cout << '\n' << std::flush;

    - You would need to force a flush right before prompting the user for input from cin, but not when writing a million lines of output.
    - for example, if you want to get all the output, and the program is unstable), use std::endl.
    - Endl is actually slower because it forces a flush, which actually unnecessary.
    - if you are in a command line app and want to guarantee that the user can see the output immediately.

    - Use std::endl If you want to force an immediate flush to the output.
    - Use \n if you are worried about performance (which is probably not the case if you are using the << operator).

    - I use \n on most lines.
    - Then use std::endl at the end of a paragraph (but that is just a habit and not usually necessary).

    endl is more than just an alias for the \n character. When you send something to cout (or any other output stream), it does not process and output the data immediately. For example:
        cout << "Hello, world!";
        someFunction();

    In the above example, there's is some chance that the function call will start to execute before the output is flushed.
    Using endl you force the flush to take place before the second instruction is executed.
    You can also ensure that with the ostream::flush function


Read
http://stackoverflow.com/questions/19470873/why-does-gcc-generate-15-20-faster-code-if-i-optimize-for-size-instead-of-speed?rq=1
http://stackoverflow.com/questions/12264970/why-is-my-program-slow-when-looping-over-exactly-8192-elements?rq=1
http://stackoverflow.com/questions/8547778/why-is-one-loop-so-much-slower-than-two-loops?rq=1
