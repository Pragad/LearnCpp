0.  What are Classes
1.  Using namespace std;
2.  How to split a string
3.  Use of cin ignore
4.  Why to use nested class
5.  NULL pointer - nullptr
6.  Print contents of a vector:
7.  Convert string to Upper Case:
8.  Switch can't be used on strings:
9.  Copy String to Char array
10.  Char * vs Char []
11.  Char * assignment
12.  Passing Array requires number of elements. Arrays decay into pointers.
13.  Deleting Array of objects using delete[]. delete[] vs delete
14.  Setting pointers to NULL after delete
15.  cout << new int[0] << endl; Allocating new with size 0
16.  Default value of a boolean in a struct
17.  Clearing a Char array in C
18.  Re-declaration of default parameter
19.  IMP: Char array vs NULL terminated String
     C FAQs
19b.  Why should SCANF never be used
19c.  But I heard that char a[] was identical to char *a.
20.  Find Substring
21.  Combining vector of strings:
22.  Convert String to Int - C++
22b. Convert INT to STRING
23.  Align std out
24.  IMP: Why Pointers
25.  Garbage Collection:
26.  C++ References:
27.  Smart Pointer:
28.  C++ Cast:
29.  C++ to Java:
30.  Finding all subsets of a Vector of Vector
31.  double vs float
32.  C++ Count occurrences of a char
33.  C++ Cin:
34.  C++ Empty String:
35.  Stack Unwinding
36.  RAII:
37.  Branch Prediction:
38.  Monitors in C++
39.  PThreads:
40.  Convert Vector to Array and Array to Vector
41.  Initialization of a normal array with one default value
42.  Templates: Template keyword vs Class keyword
43.  comparing int with size_t
44.  Unicode vs Ascii
45.  Where are Class Members stored in memory
45b. Memory Layout - Code Segment Data Segment Stack Heap
46.  C++ Class vs C Struct Memory Layout
47.  Pass by Value vs Const Reference
48.  Virtual Function and Pure Virtual Functions
49.  Virtual Functions
51.  Reading Multiple words from cin
52.  Reading multiple lines from cin
53.  Using size_t for loops
54.  size_t vs size_type
55.  File IO
57.  Meaning of const
57a.  Const vs ReadOnly
57b.  Const in C vs C++
58.  Reason to pass a pointer by reference
59.  Returning by reference:
60.  Sorting a vector of objects
61.  Find rightmost set bit
62.  #define vs typedef vs Enum
62a.  C++ Const vs #Define
62a.  C++ semantics of `static const` vs `const`
62b.  C++ Const Read Only
62b.  Const defaults to Internal Linkage in C++ and External Linkage in C
62c.  When to use unnamed namespace
62d.  Superiority of unnamed namespace over static
63.  Dynamic Array in C++
63b.  TWOD Vector in C++
64.  Time in C++
65.  Ordered Data Set
66.  Tail Recursion
67.  Extern Variable; Static vs Extern
68.  vector<bool> vs bitset
69.  Reading from file, donot use EOF for checking
70.  Struct assignment vs memcpy
71.  Why 2's complement is used to represent negative numbers
72.  Extern Linkage and Intern linkage and NO linkage
73.  How a Computer Compiles and Executes a C++ Program
74.  When / Why to use stringstream
75.  Steps involved for execution of a C program
75a.  Storage Classes - Static, Extern, Auto and Register
76.  Abstract Class vs Interface
77.  Can abstract class be instantiated
78.  C++ new int[0] - will it allocate memory
79.  C++ new vs C malloc
80.  How is memory allocated to Vectors
81.  Where Global Variables and Pointers are stored
82.  Where are the Variable Names stored
83.  What is Type Safe
84.  What is the name of the --> operator
85.  Why is ::operator new[] necessary when ::operator new is enough
86.  Allocator vs New
87.  What is RTTI and Why is it necessary
88.  When to use static methods
89.  Freeing memory twice
90.  C++ Memory management New operator vs Operator new 
91.  STACK VS HEAP
92.  Different behavior of Code Valid in C and C++
93.  Case Only Labels: Jumping over initialization
94.  What uses are there for placement new?
95.  Is there a "placement delete"?
96.  Shared Pointers, Weak Pointers and Scoped Pointers
97.  Vector - Accessing member elements using "at()" vs "[]"
98.  Created Vectors of User defined size
99.  How to use memset or fill_n to initialize a dynamic two dimensional array in C++
100. Unique Lock
101. Condition Variable
102. Lock_guard vs Unique_lock
103. Recursive Mutex
104. Lock vs Mutex vs Condition Variable
105. Need for THIS Pointer
106. Sort Unordered Map
107. IMP: Using [] operator in unordered_map inserts the element if not present.
108. Create a vector of userdefined size and initialize with default values
109. Copy from one vector to another
110. Copy Constructor vs Assignment Operator:
111. Volatile keyword:
112. How do you declare an interface in C++
113. Multiple Inheritence in C++
114. Exception handling in C++
115. Side effects of macros:
116. Macros vs Inline Function:
117. What is Arithmetic Overflow and Underflow
118. How to detect integer overflow in C/C++
119. Usage of Templates Function and Class
120. Passing a 2D array to a C++ function

------------------------------------------------------------------------------------------
0. 
What are Classes
    Classes are a collection of functions which operate on data.

1.
Using namespace std;
http://stackoverflow.com/questions/1452721/why-is-using-namespace-std-considered-bad-practice
    Say you have,
    using namespace foo; has function foos()
        using namespace bar; has function bars()

    In version 2.0, foo comes up with a function bars(). Then we will end up calling the other function.
    So use foo::foos(), bar::bars()

2. 
How to split a string
http://stackoverflow.com/questions/236129/split-a-string-in-c
    
    #include <string>
    #include <sstream>
    #include <vector>

    std::vector<std::string> &split(const std::string &s, char delim, std::vector<std::string> &elems) {
        std::stringstream ss(s);
        std::string item;
        while (std::getline(ss, item, delim)) {
            elems.push_back(item);
        }
        return elems;
    }


    std::vector<std::string> split(const std::string &s, char delim)
    {
        std::vector<std::string> elems;
        split(s, delim, elems);
        return elems;
    }

C++ Find Substring using a pattern
http://stackoverflow.com/questions/14265581/parse-split-a-string-in-c-using-string-delimiter-standard-c

    Parsing with a single char delimiter is fine. But what if I want to use a string as delimiter.
    Example: I want to split:
    scott>=tiger
    with >= as delimiter so that I can get scott and tiger.

    You can use the std::string::find() function to find the position of your string delimiter, then use std::string::substr() to get a token.
    Example:
    std::string s = "scott>=tiger";
    std::string delimiter = ">=";
    std::string token = s.substr(0, s.find(delimiter)); // token is "scott"
    The find(const string& str, size_t pos = 0) function returns the position of the first occurrence of str in the string, or npos if the string is not found.
    The substr(size_t pos = 0, size_t n = npos) function returns a substring of the object, starting at position pos and of length npos

3. 
Use of cin ignore
http://stackoverflow.com/questions/25475384/when-and-why-do-i-need-to-use-cin-ignore-in-c
http://stackoverflow.com/questions/5131647/why-would-we-call-cin-clear-and-cin-ignore-after-reading-input

        cin.ignore(256, '\n');

        // cin returns false if an input operation fails, that is, if
        // something other than an int (the type of input_var) is entered.
        while (!(cin >> input_var)) {
          cout << "Please enter numbers only." << endl;
          cin.clear();              // Both lines are very important
          cin.ignore(10000,'\n'); 
        }

    The cin.clear() clears the error flag on cin (so that future I/O operations will work correctly), and then
    cin.ignore(10000, '\n') skips to the next newline (to ignore anything else on the same line as the non-number so that it does not cause another parse failure).
    It will only skip up to 10000 characters, so the code is assuming the user will not put in a very long, invalid line.

        cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

    Essentially, for std::cin statements you use ignore before you do a getline call, because when a user inputs something with std::cin, they hit enter and a '\n' char gets into the cin buffer.
    Then if you use getline, it gets the newline char instead of the string you want.
    So you do a std::cin.ignore(1000,'\n') and that should clear the buffer up to the string that you want.
    (The 1000 is put there to skip over a specific amount of chars before the specified break point, in this case, the \n newline character.)

    std::ws
    Discards leading whitespace from an input stream.
        std::istringstream s("     this is a test");
        std::string line;
        getline(s >> std::ws, line);
        std::cout << "ws + getline returns: \"" << line << "\"\n";

4. 
Why to use nested class
http://stackoverflow.com/questions/4571355/why-would-one-use-nested-classes-in-c

    Cool to hide implementation details:
    class List
    {
        public:
            List(): head(NULL), tail(NULL) {}
        private:
            class Node
            {
                  public:
                      int   data;
                      Node* next;
                      Node* prev;
            };
        private:
            Node*     head;
            Node*     tail;
    };

5. 
NULL pointer - nullptr
http://stackoverflow.com/questions/1282295/what-exactly-is-nullptr
http://stackoverflow.com/questions/20509734/null-vs-nullptr-why-was-it-replaced?lq=1

    nullptr is always a pointer type. 0 (aka. C's NULL bridged over into C++) could cause ambiguity in overloaded function resolution, among other things:
    f(int);
    f(foo *);

6. 
Print contents of a vector:
http://stackoverflow.com/questions/10750057/c-printing-out-the-contents-of-a-vector

    Solution 1:
    for (std::vector<char>::const_iterator i = path.begin(); i != path.end(); ++i)
        std::cout << *i << ' ';

    Solution 2:
    for (auto i = path.begin(); i != path.end(); ++i)
        std::cout << *i << ' ';

7. 
Convert string to Upper Case:
http://stackoverflow.com/questions/735204/convert-a-string-in-c-to-upper-case

    #include <algorithm>
    #include <string>

    std::string str = "Hello World";
    std::transform(str.begin(), str.end(),str.begin(), ::toupper);

8. 
Switch can't be used on strings:
http://stackoverflow.com/questions/650162/why-switch-statement-cannot-be-applied-on-strings

    The reason why has to do with the type system. C/C++ doesn't really support strings as a type.
    It does support the idea of a constant char array but it doesn't really fully understand the notion of a string. 

9. 
Copy String to Char array
http://stackoverflow.com/questions/13294067/how-to-convert-string-to-char-array-in-c

        string tmp = "cat";
        char tab2[1024];
        strcpy(tab2, tmp.c_str());

    For safety, you might prefer:
        string tmp = "cat";
        char tab2[1024];
        strncpy(tab2, tmp.c_str(), sizeof(tab2));
        tab2[sizeof(tab2) - 1] = 0;

10.
Char * vs Char []
http://stackoverflow.com/questions/1704407/what-is-the-difference-between-char-s-and-char-s-in-c

        char *s = "Hello world";
    will place Hello world in the read-only parts of the memory and making s a pointer to that, making any writing operation on this memory illegal. While doing:
        char s[] = "Hello world";
    puts the literal string in read-only memory and copies the string to newly allocated memory on the stack. Thus making
        s[0] = 'J';
    legal.

    First off, in function arguments, they are exactly equivalent:
        void foo(char *x);
        void foo(char x[]); // exactly the same in all respects (note! this only applies if the brackets are empty)

    char s[] = "hello";
    Creates one object - a char array of size 6, called s, initialised with the values 'h', 'e', 'l', 'l', 'o', '\0'.
    Where this array is allocated in memory, and how long it lives for, depends on where the declaration appears.
    If the declaration is within a function, it will live until the end of the block that it is declared in, and almost certainly be allocated on the stack; if it's outside a function, it will probably be stored within an "initialised data segment" that is loaded from the executable file into writeable memory when the program is run.

    On the other hand, this declaration:
        char *s ="hello";
    Creates two objects:
        a read-only array of 6 chars containing the values 'h', 'e', 'l', 'l', 'o', '\0', which has no name and has static storage duration (meaning that it lives for the entire life of the program); and
        a variable of type pointer-to-char, called s, which is initialised with the location of the first character in that unnamed, read-only array.

    The unnamed read-only array is typically located in the "text" segment of the program, which means it is loaded from disk into read-only memory, along with the code itself.
    The location of the s pointer variable in memory depends on where the declaration appears (just like in the first example)

11.
Char * assignment
http://stackoverflow.com/questions/20944784/why-is-conversion-from-string-constant-to-char-valid-in-c-but-invalid-in-c

        char* p = "abc"; // valid in C, invalid in C++
    It uses a deprecated implicit conversion--a string literal should be treated as being of type char const *, since you can't modify its contents

12.
Passing Array requires number of elements. Arrays decay into pointers.
http://stackoverflow.com/questions/2559896/how-are-arrays-passed

    They are passed as pointers. This means that all information about the array size is lost.

13. 
Deleting Array of objects using delete[]. delete[] vs delete
http://stackoverflow.com/questions/703691/how-does-delete-know-its-an-array
http://stackoverflow.com/questions/197675/how-does-delete-know-the-size-of-the-operand-array?lq=1

    The compiler doesn't know it's an array, it's trusting the programmer. Deleting a pointer to a single int with delete [] would result in undefined behavior.

        Foo* set = new Foo[100];
        // ...
        delete [] set;

    When you allocate memory on the heap, your allocator will keep track of how much memory you have allocated.
    This is usually stored in a "head" segment just before the memory that you get allocated.
    That way when it's time to free the memory, the de-allocator knows exactly how much memory to free.

    If the runtime libraries (not the OS, really) can keep track of the number of things in the array, then why do we need the delete[] syntax at all? Why can't a single delete form be used to handle all deletes?
        The answer to this goes back to C++'s roots as a C-compatible language (which it no longer really strives to be.)
        Stroustrup's philosophy was that the programmer should not have to pay for any features that they aren't using.
        If they're not using arrays, then they should not have to carry the cost of object arrays for every allocated chunk of memory.

        That is, if your code simply does
            Foo* foo = new Foo;

        then the memory space that's allocated for foo shouldn't include any extra overhead that would be needed to support arrays of Foo.

        Since only array allocations are set up to carry the extra array size information, you then need to tell the runtime libraries to look for that information when you delete the objects.
        That's why we need to use
            delete[] bar;

        instead of just
            delete bar;

        if bar is a pointer to an array.

14.
Setting pointers to NULL after delete
http://stackoverflow.com/questions/1931126/is-it-good-practice-to-null-a-pointer-after-deleting-it
http://stackoverflow.com/questions/9169774/what-happens-in-a-double-delete

    Double delete causes an undefined behavior. So setting a pointer to NULL will overcome that.
    Deleting a NULL pointer is a Void operation

    Setting a pointer to 0 (which is "null" in standard C++, the NULL define from C is somewhat different) avoids crashes on double deletes.
    Consider the following:
        Foo* foo = 0; // Sets the pointer to 0 (C++ NULL)
        delete foo; // Won't do anything
    Whereas:
        Foo* foo = new Foo();
        delete foo; // Deletes the object
        delete foo; // Undefined behavior

    Under the hood, any memory manager has to maintain some metadata about each block of data it allocates, in a way that allows it to look up the metadata from the pointer that malloc/new returned.
    Typically this takes the form of a structure at fixed offset before the allocated block.
    This structure can contain a "magic number" -- a constant that is unlikely to occur by pure chance.
    If the memory manager sees the magic number in the expected place, it knows that the pointer provided to free/delete is most likely valid.
    If it doesn't see the magic number, or if it sees a different number that means "this pointer was recently freed", it can either silently ignore the free request, or it can print a helpful message and abort.
    Either is legal under the spec, and there are pro/con arguments to either approach.

    If the memory manager doesn't keep a magic number in the metadata block, or doesn't otherwise check the sanity of the metadata, then anything can happen.
    Depending on how the memory manager is implemented, the result is most likely a crash without a helpful message, either immediately in the memory manager logic, somewhat later the next time the memory manager tries to allocate or free memory, or much later and far away when two different parts of the program each think they have ownership of the same chunk of memory.

15.
cout << new int[0] << endl; Allocating new with size 0
http://stackoverflow.com/questions/1087042/c-new-int0-will-it-allocate-memory

    When the value of the expression in a direct-new-declarator is zero, the allocation function is called to allocate an array with no elements.

    From 3.7.3.1/2
        The effect of dereferencing a pointer returned as a request for zero size is undefined.

        That means you can do it, but you can not legally (in a well defined manner across all platforms) dereference the memory that you get - you can only pass it to array delete - and you should delete it.

16.
Default value of a boolean in a struct
http://stackoverflow.com/questions/3845353/what-will-be-the-default-value-of-an-uninitialized-boolean-value-in-c
http://stackoverflow.com/questions/16782103/initializing-default-values-in-a-struct

    The value of the bool will is undefined. It will be whatever else was on the stack before it, which is sometimes zeroed out if nothing has used it previously.
    But again, it is undefined, which means it can be either true or false.
    If you need a default value, you can do:
        struct fool_bool {
          bool b1;
          bool b2;
          fool_bool() {
            b1 = true;
            b2 = false;
        }  };

    In C++ 11 default value can be given inside the struct itself:
        struct foo {
            bool a = true;
            bool b = true;
            bool c;
         } bar;

17.
Clearing a Char array in C
http://stackoverflow.com/questions/632846/clearing-a-char-array-c

    It depends on how you want to view the array. If you are viewing the array as a series of char's then the only way to clear out the data is to touch every entry.
    memset is probably the most effective way to achieve this.
    On the other hand if you are choosing to view this as a C/C++ null terminated string, setting the first byte to 0 will effectively clear the string.

        memset(&arr[0], 0, sizeof(arr));
    This is generally the fastest way to take care of this. If you can use C++, consider std::fill instead:
        char *begin = &arr;
        char *end = begin + sizeof(arr);
        std::fill(begin, end, 0);

18.
Re-declaration of default parameter
http://stackoverflow.com/questions/6210450/the-compiler-is-complaining-about-my-default-parameters

    You have to specify the default values for the arguments only in the declaration but not in the definition.
        class pBase : public sf::Thread {
             // ....
             void setColor( int _color = -1 );
             // ....
         } ;

         void pBase:: setColor( int _color )
         {
             // ....
         }

19.
IMP: Char array vs NULL terminated String
http://stackoverflow.com/questions/11229477/are-all-char-arrays-automatically-null-terminated
http://stackoverflow.com/questions/12019947/null-termination-of-char-array

    VERY NICE LINK. Read all examples here
http://c-faq.com/charstring/index.html

    Only string literals get null-terminated, and that means that char x[]="asdf" is an array of 5 elements.
    char arrays are not automatically NULL terminated

    Also, WE have to make sure there is space for NULL character.
    If you type more than four characters then the extra characters and the null terminator will be written outside the end of the array, overwriting memory not belonging to the array.
    This is a buffer overflow.

Q1:
    Why doesn't strcat(string, '!'); work?

A1:
    There is a very real difference between characters and strings, and strcat concatenates strings.

    A character constant like '!' represents a single character.
    A string literal between double quotes usually represents multiple characters.
    A string literal like "!" seems to represent a single character, but it actually contains two: the ! you requested, and the \0 which terminates all strings in C.

    Characters in C are represented by small integers corresponding to their character set values (see also question 8.6).
    Strings are represented by arrays of characters; you usually manipulate a pointer to the first character of the array.
    It is never correct to use one when the other is expected. To append a ! to a string, use
        strcat(string, "!");

Q2:
     I'm checking a string to see if it matches a particular value. Why isn't this code working?

        char *string;
        ...
        if(string == "value") {
            /* string matches "value" */
            ...
        }

A2:
    Strings in C are represented as arrays of characters, and C never manipulates (assigns, compares, etc.) arrays as a whole.
    The == operator in the code fragment above compares two pointers--the value of the pointer variable string and a pointer to the string literal "value"--to see if they are equal, that is, if they point to the same place.
    They probably don't, so the comparison never succeeds.

    To compare two strings, you generally use the library function strcmp:
        if(strcmp(string, "value") == 0) {
            /* string matches "value" */
            ...
        }

Q3:
    If I can say 
        char a[] = "Hello, world!";

    why can't I say
        char a[14];
        a = "Hello, world!";

A3:
    Strings are arrays, and you can't assign arrays directly. Use strcpy instead:
        strcpy(a, "Hello, world!");

Q4:
    I can't get strcat to work. I tried
        char *s1 = "Hello, ";
        char *s2 = "world!";
        char *s3 = strcat(s1, s2);

    but I got strange results.

A4:
    The main problem here is that space for the concatenated result is not properly allocated.
    C does not provide an automatically-managed string type.
    C compilers allocate memory only for objects explicitly mentioned in the source code (in the case of strings, this includes character arrays and string literals).
    The programmer must arrange for sufficient space for the results of run-time operations such as string concatenation, typically by declaring arrays, or by calling malloc.

    strcat performs no allocation; the second string is appended to the first one, in place.
    The first (destination) string must be writable and have enough room for the concatenated result.
    Therefore, one fix would be to declare the first string as an array:

        char s1[20] = "Hello, ";

    Since strcat returns the value of its first argument (s1, in this case), the variable s3 in the question above is superfluous; after the call to strcat, s1 contains the result.

    The original call to strcat in the question actually has two problems: the string literal pointed to by s1, besides not being big enough for any concatenated text, is not necessarily writable at all.

Q5.
    I'm reading strings typed by the user into an array, and then printing them out later.
    When the user types a sequence like \n, why isn't it being handled properly?

A5:
    Character sequences like \n are interpreted at compile time.
    When a backslash and an adjacent n appear in a character constant or string literal, they are translated immediately into a single newline character.
    (Analogous translations occur, of course, for the other character escape sequences.)
    When you're reading strings from the user or a file, however, no interpretation like this is performed: a backslash is read and printed just like any other character, with no particular interpretation.

Q6: C vs C++
    I think something's wrong with my compiler: I just noticed that sizeof('a') is 2, not 1 (i.e. not sizeof(char)).

A6:
    Perhaps surprisingly, character constants in C are of type int, so sizeof('a') is sizeof(int) (though this is another area where C++ differs)

19b.
Why should SCANF never be used
http://stackoverflow.com/questions/12019947/null-termination-of-char-array

    This is a great example of why scanf("%s") is dangerous and should never be used.
    It doesn't know about the size of your array which means there is no way to use it safely.
    Instead, avoid scanf and use something safer, like fgets():

        fgets() reads in at most one less than size characters from stream and stores them into the buffer pointed to by s.
        Reading stops after an EOF or a newline.
        If a newline is read, it is stored into the buffer.
        A terminating null byte ('\0') is stored after the last character in the buffer.

19c.
But I heard that char a[] was identical to char *a.
http://c-faq.com/aryptr/aryptr2.html
       - The array declaration char a[6] requests that space for six characters be set aside, to be known by the name ``a''.
         That is, there is a location named ``a'' at which six characters can sit
       - The pointer declaration char *p, on the other hand, requests a place which holds a pointer, to be known by the name ``p''.
       - VERY IMP: ``pointer arithmetic and array indexing [that] are equivalent in C, pointers and arrays are different.'')

    3. If they're so different, then why are array and pointer declarations interchangeable as function formal parameters? 
       - Since arrays decay immediately into pointers, an array is never actually passed to a function.

20.
Find Substring
http://www.cplusplus.com/reference/string/string/substr/

    std::string str="We think in generalities, but we live in details.";
                                               // (quoting Alfred N. Whitehead)

    std::string str2 = str.substr (3,5);     // "think"

    std::size_t pos = str.find("live");      // position of "live" in str

    std::string str3 = str.substr (pos);     // get from "live" to the end


21.
Combining vector of strings:
http://stackoverflow.com/questions/1985978/combining-a-vector-of-strings

    Use accumulate
        int main () {
            string str = "Hello World!";
            vector<string>  vec (10,str);
            string a = accumulate( vec.begin(), vec.end(), string("") );
            cout << a << endl;

22.
Convert String to Int - C++
http://stackoverflow.com/questions/7663709/convert-string-to-int-c

    In C++11 there are some nice new convert functions from std::string to a number type.
    So instead of
        atoi( str.c_str() )
    you can use
        std::stoi( str )
    where str is your number as std::string.

    There are version for all flavours of numbers:
        long stol(string), float stof(string), double stod(string)

22b.
Convert INT to STRING

    string strNum = to_string(number);

23.
Align std out
http://stackoverflow.com/questions/2485963/c-alignment-when-printing-cout

    The ISO C++ standard way to do it is to #include <iomanip> and use io manipulators like std::setw
    However, that said, those io manipulators are a real pain to use even for text, and are just about unusable for formatting numbers

24.
IMP: Why Pointers
http://stackoverflow.com/questions/22146094/why-should-i-use-a-pointer-rather-than-the-object-itself

    I'm coming from a Java background and have started working with objects in C++.
    But one thing that occurred to me is that people often use pointers to objects rather than the objects themselves, for example this declaration:
        Object *myObject = new Object;
    rather than:
        Object myObject;

    Or instead of using a function, let's say testFunc(), like this:
        myObject.testFunc();
    we have to write:
        myObject->testFunc();

    You have two questions bundled up into one. The first is when should we use dynamic allocation (using new)? The second is when should we use pointers?
    The important take-home message is that you should always use the appropriate tool for the job.
    In almost all situations, there is something more appropriate and safer than performing manual dynamic allocation and/or using raw pointers.

    Dynamic allocation
        In your question, you've demonstrated two ways of creating an object. The main difference is the storage duration of the object.
        When doing Object myObject; within a block, the object is created with automatic storage duration, which means it will be destroyed automatically when it goes out of scope.
        When you do new Object(), the object has dynamic storage duration, which means it stays alive until you explicitly delete it.
        You should only use dynamic storage duration when you need it. That is, you should always prefer creating objects with automatic storage duration when you can.

        The main two situations in which you might require dynamic allocation:
            1. You need the object to outlive the current scope - that specific object at that specific memory location, not a copy of it.
               If you're okay with copying/moving the object (most of the time you should be), you should prefer an automatic object.

            2. You need to allocate a lot of memory, which may easily fill up the stack.
               It would be nice if we didn't have to concern ourselves with this (most of the time you shouldn't have to), as it's really outside the purview of C++, but unfortunately we have to deal with the reality of the systems we're developing for.

        When you do absolutely require dynamic allocation, you should encapsulate it in a smart pointer or some other type that performs RAII (like the standard containers).
        Smart pointers provide ownership semantics of dynamically allocated objects.
        Take a look at std::unique_ptr and std::shared_ptr, for example.
        If you use them appropriately, you can almost entirely avoid performing your own memory management (see the Rule of Zero).

    Pointers
        However, there are other more general uses for raw pointers beyond dynamic allocation, but most have alternatives that you should prefer.
        As before, always prefer the alternatives unless you really need pointers.

     1. You need reference semantics.
        Sometimes you want to pass an object using a pointer (regardless of how it was allocated) because you want the function to which you're passing it to have access that that specific object (not a copy of it).
        However, in most situations, you should prefer reference types to pointers, because this is specifically what they're designed for.
        Note this is not necessarily about extending the lifetime of the object beyond the current scope, as in situation 1 above.
        As before, if you're okay with passing a copy of the object, you don't need reference semantics.

     2. You need polymorphism.
        You can only call functions polymorphically (that is, according to the dynamic type of an object) through a pointer or reference to the object.
        If that's the behaviour you need, then you need to use pointers or references.
        Again, references should be preferred.

     3. You want to represent that an object is optional by allowing a nullptr to be passed when the object is being omitted.
        If it's an argument, you should prefer to use default arguments or function overloads.
        Otherwise, you should prefer use a type that encapsulates this behaviour, such as boost::optional (or perhaps soon, std::optional - Edit std::optional is voted out of the current C++14 draft n3797).

     4. You want to decouple compilation units to improve compilation time.
        The useful property of a pointer is that you only require a forward declaration of the pointed-to type (to actually use the object, you'll need a definition).
        This allows you to decouple parts of your compilation process, which may significantly improve compilation time.
        See the Pimpl idiom.

     5. You need to interface with a C library or a C-style library.
        At this point, you're forced to use raw pointers.
        The best thing you can do is make sure you only let your raw pointers loose at the last possible moment.
        You can get a raw pointer from a smart pointer, for example, by using its get member function.
        If a library performs some allocation for you which it expects you to deallocate via a handle, you can often wrap the handle up in a smart pointer with a custom deleter that will deallocate the object appropriately.

25.
Garbage Collection:
http://stackoverflow.com/questions/5009869/how-to-implement-garbage-collection-in-c?lq=1

    Garbage collection in C and C++ are both difficult topics for a few reasons:

    1. Pointers can be typecast to integers and vice-versa.
    This means that I could have a block of memory that is reachable only by taking an integer, typecasting it to a pointer, then dereferencing it.
    A garbage collector has to be careful not to think a block is unreachable when indeed it still can be reached.

    2. Pointers are not opaque. Many garbage collectors, like stop-and-copy collectors, like to move blocks of memory around or compact them to save space.
    Since you can explicitly look at pointer values in C and C++, this can be difficult to implement correctly.
    You would have to be sure that if someone was doing something tricky with typecasting to integers that you correctly updated the integer if you moved a block of memory around.

    3. Memory management can be done explicitly. Any garbage collector will need to take into account that the user is able to explicitly free blocks of memory at any time.

    4. In C++, there is a separation between allocation/deallocation and object construction/destruction.
    A block of memory can be allocated with sufficient space to hold an object without any object actually being constructed there.
    A good garbage collector would need to know, when it reclaims memory, whether or not to call the destructor for any objects that might be allocated there.
    This is especially true for the standard library containers, which often make use of std::allocator to use this trick for efficiency reasons.

    5. Memory can be allocated from different areas.
    C and C++ can get memory either from the built-in freestore (malloc/free or new/delete), or from the OS via mmap or other system calls, and, in the case of C++, from get_temporary_buffer or return_temporary_buffer.
    The programs might also get memory from some third-party library.
    A good garbage collector needs to be able to track references to memory in these other pools and (possibly) would have to be responsible for cleaning them up.

    6. Pointers can point into the middle of objects or arrays.
    In many garbage-collected languages like Java, object references always point to the start of the object.
    In C and C++ pointers can point into the middle of arrays, and in C++ into the middle of objects (if multiple inheritance is used). This can greatly complicate the logic for detecting what's still reachable.

    So, in short, it's extremely hard to build a garbage collector for C or C++.
    Most libraries that do garbage collection in C and C++ are extremely conservative in their approach and are technically unsound - they assume that you won't, for example, take a pointer, cast it to an integer, write it to disk, and then load it back in at some later time.
    They also assume that any value in memory that's the size of a pointer could possibly be a pointer, and so sometimes refuse to free unreachable memory because there's a nonzero chance that there's a pointer to it.

    As others have pointed out, the Boehm GC does do garbage collection for C and C++, but subject to the aforementioned restrictions.

    Interestingly, C++11 includes some new library functions that allow the programmer to mark regions of memory as reachable and unreachable in anticipation of future garbage collection efforts.
    It may be possible in the future to build a really good C++11 garbage collector with this sort of information.
    In the meantime though, you'll need to be extremely careful not to break any of the above rules.

26.
C++ References:
http://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in?rq=1

    Summary from answers and links below:
        A pointer can be re-assigned any number of times while a reference can not be re-seated after binding.

    A pointer can be re-assigned:
        int x = 5;
        int y = 6;
        int *p;
        p =  &x;
        p = &y;
        *p = 10;
        assert(x == 5);
        assert(y == 10);

    A reference cannot, and must be assigned at initialization:
        int x = 5;
        int y = 6;
        int &r = x;


    Pointers can point nowhere (NULL), whereas reference always refer to an object.
        int *p = NULL;
        int &r = NULL; <--- compiling error

    You can't take the address of a reference like you can with pointers.
    A pointer has its own memory address and size on the stack (4 bytes on x86), whereas a reference shares the same memory address (with the original variable) but also takes up some space on the stack.
    Since a reference has the same address as the original variable itself, it is safe to think of a reference as another name for the same variable.

    There's no "reference arithmetics" (but you can take the address of an object pointed by a reference and do pointer arithmetics on it as in &obj + 5).

27.
Smart Pointer:
http://stackoverflow.com/questions/106508/what-is-a-smart-pointer-and-when-should-i-use-one
http://ootips.org/yonat/4dev/smart-pointers.html

    The simplest example of a smart pointer is auto_ptr, which is included in the standard C++ library.
    You can find it in the header <memory>, or take a look at Scott Meyers' auto_ptr implementation.
    Here is part of auto_ptr's implementation, to illustrate what it does:
        template <class T> class auto_ptr
        {
            T* ptr;
        public:
            explicit auto_ptr(T* p = 0) : ptr(p) {}
            ~auto_ptr()                 {delete ptr;}
            T& operator*()              {return *ptr;}
            T* operator->()             {return ptr;}
            // ...
        };

    As you can see, auto_ptr is a simple wrapper around a regular pointer.
    It forwards all meaningful operations to this pointer (dereferencing and indirection).
    Its smartness in the destructor: the destructor takes care of deleting the pointer.
    For the user of auto_ptr, this means that instead of writing:

        void foo()
        {
            MyClass* p(new MyClass);
            p->DoSomething();
            delete p;
        }

    You can write:
        void foo()
        {
            auto_ptr<MyClass> p(new MyClass);
            p->DoSomething();
        }
    And trust p to cleanup after itself. 

28.
C++ Cast:
http://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used?rq=1

    static_cast is the first cast you should attempt to use.
        It does things like implicit conversions between types (such as int to float, or pointer to void*), and it can also call explicit conversion functions (or implicit ones).
        In many cases, explicitly stating static_cast isn't necessary, but it's important to note that the T(something) syntax is equivalent to (T)something and should be avoided (more on that later).
        A T(something, something_else) is safe, however, and guaranteed to call the constructor.
        static_cast can also cast through inheritance hierarchies. It is unnecessary when casting upwards (towards a base class), but when casting downwards it can be used as long as it doesn't cast through virtual inheritance.
        It does not do checking, however, and it is undefined behavior to static_cast down a hierarchy to a type that isn't actually the type of the object.

    const_cast can be used to remove or add const to a variable; no other C++ cast is capable of removing it (not even reinterpret_cast).
        It is important to note that modifying a formerly const value is only undefined if the original variable is const; if you use it to take the const off a reference to something that wasn't declared with const, it is safe.
        This can be useful when overloading member functions based on const, for instance.
        It can also be used to add const to an object, such as to call a member function overload.
        const_cast also works similarly on volatile, though that's less common.

    dynamic_cast is almost exclusively used for handling polymorphism.
        You can cast a pointer or reference to any polymorphic type to any other class type (a polymorphic type has at least one virtual function, declared or inherited).
        You can use it for more than just casting downwards -- you can cast sideways or even up another chain.
        The dynamic_cast will seek out the desired object and return it if possible.
        If it can't, it will return nullptr in the case of a pointer, or throw std::bad_cast in the case of a reference.
        dynamic_cast has some limitations, though. It doesn't work if there are multiple objects of the same type in the inheritance hierarchy (the so-called 'dreaded diamond') and you aren't using virtual inheritance.
        It also can only go through public inheritance - it will always fail to travel through protected or private inheritance.
        This is rarely an issue, however, as such forms of inheritance are rare.

    reinterpret_cast is the most dangerous cast, and should be used very sparingly.
        It turns one type directly into another - such as casting the value from one pointer to another, or storing a pointer in an int, or all sorts of other nasty things.
        Largely, the only guarantee you get with reinterpret_cast is that normally if you cast the result back to the original type, you will get the exact same value (but not if the intermediate type is smaller than the original type).
        There are a number of conversions that reinterpret_cast cannot do, too.
        It's used primarily for particularly weird conversions and bit manipulations, like turning a raw data stream into actual data, or storing data in the low bits of an aligned pointer.

29.
C++ to Java:
http://stackoverflow.com/questions/5732224/just-enough-java-for-hadoop

31.
double vs float
http://stackoverflow.com/questions/2386772/difference-between-float-and-double
http://programmers.stackexchange.com/questions/188721/when-do-you-use-float-and-when-do-you-use-double

    - As the name implies, a double has 2x the precision of float[1]. In general a double has 15 to 16 decimal digits of precision, while float only has 7
    - Also, the maximum value of float is only about 3e38, but double is about 1.7e308, so using float can hit Infinity much easier than double for something simple e.g. computing 60!

    float should only be used if you need to operate on a lot of floating-point numbers (think in the order of thousands or more) and analysis of the algorithm has shown that the reduced range and accuracy don't pose a problem.

    long double can be used if you need more range or accuracy than double, and if it provides this on your target platform.

    In summary, float and long double should be reserved for use by the specialists, with double for "every-day" use.

Double Float Comparison
http://stackoverflow.com/questions/17333/most-effective-way-for-float-and-double-comparison
    bool AreSame(double a, double b)
    {
        return fabs(a - b) < EPSILON;
    }

32.
C++ Count occurrences of a char
http://stackoverflow.com/questions/3867890/count-character-occurrences-in-a-string

    How can I count the number of "_" in a string like "bla_bla_blabla_bla"

    #include <algorithm>

    std::string s = "a_b_c";
    size_t n = std::count(s.begin(), s.end(), '_');

33.
C++ Cin:
How to include White space using Cin
http://stackoverflow.com/questions/2765462/how-to-cin-space-in-c
http://stackoverflow.com/questions/5838711/c-cin-input-with-spaces

    It skips all whitespace (spaces, tabs, new lines, etc.) by default.
    You can either change its behavior, or use a slightly different mechanism.
    To change its behavior, use the manipulator noskipws, as follows:

        cin >> noskipws >> a[i];
    But, since you seem like you want to look at the individual characters, I'd suggest using get, like this prior to your loop
        cin.get( a, n );

    #include <iostream>
    #include <string>
    int main()
    {
       std::string a;
       std::getline(std::cin,a);
       for(std::string::size_type i = 0; i < a.size(); ++i)
       {
           if(a[i] == ' ')
              std::cout<<"It is a space!!!"<<std::endl;
       }


    int main()
    {
       std::string name, title;

       std::cout << "Enter your name: ";
       std::getline(std::cin, name);

       std::cout << "Enter your favourite movie: ";
       std::getline(std::cin, title);

       std::cout << name << "'s favourite movie is " << title;
    }

34.
C++ Empty String:
http://stackoverflow.com/questions/26310772/why-an-empty-string-can-output-index-0-element-in-c
http://stackoverflow.com/questions/17997204/does-an-empty-string-contain-an-empty-string-in-c

    #include<iostream>
    #include<string>

    using std::string;
    using std::cout;
    using std::endl;

    int main()
    {
        string s;
        cout << s.size() << endl;
        cout << s[0] << endl;  //output empty line
        return 0;
    }


    There's a special rule that you can access s[n] where n is the length of s.
    The result is a null character (i.e. the value that results from value-initializing the character type) and attempting to modify it causes undefined behaviour

35.
Stack Unwinding
http://stackoverflow.com/questions/2331316/what-is-stack-unwinding

    Stack unwinding is usually talked about in connection with exception handling. Here's an example:
        void func( int x )
        {
            char* pleak = new char[1024]; // might be lost => memory leak
            std::string s( "hello world" ); // will be properly destructed

            if ( x ) throw std::runtime_error( "boom" );

            delete [] pleak; // will only get here if x == 0. if x!=0, throw exception
        }

        int main()
        {
            try
            {
                func( 10 );
            }
            catch ( const std::exception& e )
            {
                return 1;
            }

            return 0;
        }

    Here memory allocated for pleak will be lost if exception is thrown, while memory allocated to s will be properly released by std::string destructor in any case.
    The objects allocated on the stack are "unwound" when the scope is exited (here the scope is of the function func.)
    This is done by the compiler inserting calls to destructors of automatic (stack) variables.
    Now this is a very powerful concept leading to the technique called RAII, that is Resource Acquisition Is Initialization, that helps us manage resources like memory, database connections, open file descriptors, etc. in C++.

36.
RAII:
http://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii
http://www.tomdalling.com/blog/software-design/resource-acquisition-is-initialisation-raii-explained/
http://stackoverflow.com/questions/6500313/why-should-c-programmers-minimize-use-of-new?rq=1

    In C++ there's a neat construct called a destructor.
    This mechanism allows you to manage resources by aligning the lifetime of the resource with the lifetime of a variable.

    It's a really terrible name for an incredibly powerful concept, and perhaps one of the number 1 things that C++ developers miss when they switch to other languages.
    There has been a bit of a movement to try to rename this concept as Scope-Bound Resource Management, though it doesn't seem to have caught on just yet.

    When we say 'Resource' we don't just mean memory - it could be file handles, network sockets, database handles, GDI objects.
    In short, things that we have a finite supply of and so we need to be able to control their usage.
    The 'Scope-bound' aspect means that the lifetime of the object is bound to the scope of a variable, so when the variable goes out of scope then the destructor will release the resource.
    A very useful property of this is that it makes for greater exception-safety. For instance, compare this:

        RawResourceHandle* handle=createNewResource();
        handle->performInvalidOperation();  // Oops, throws exception
        ...
        deleteResource(handle); // oh dear, never gets called so the resource leaks

    With the RAII one
        class ManagedResourceHandle {
        public:
           ManagedResourceHandle(RawResourceHandle* rawHandle_) : rawHandle(rawHandle_) {};
           ~ManagedResourceHandle() {delete rawHandle; }
           ... // omitted operator*, etc
        private:
           RawResourceHandle* rawHandle;
        };

        ManagedResourceHandle handle(createNewResource());
        handle->performInvalidOperation();

    In this latter case, when the exception is thrown and the stack is unwound, the local variables are destroyed which ensures that our resource is cleaned up and doesn't leak.

        File f;
        f.open("boo.txt");
        //UNSAFE - an exception here means the file is never closed
        loadFromFile(f);
        f.close();

        Dog* dog = new Daschund;
        //UNSAFE - an exception here means the dog is never deleted
        goToThePark(dog); 
        delete dog;

        Lock* lock = getLock();
        lock.aquire();
        //UNSAFE - an exception here means the lock is never released
        doSomething();
        lock.release();

37.
Branch Prediction:
http://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-an-unsorted-array?rq=1

    Why is processing a sorted array faster than an unsorted array

    You are a processor and you see a branch.
    You have no idea which way it will go. What do you do? You halt execution and wait until the previous instructions are complete.
    Then you continue down the correct path.

    Modern processors are complicated and have long pipelines. So they take forever to "warm up" and "slow down".
    Is there a better way? You guess which direction the branch will go!
    If you guessed right, you continue executing.
    If you guessed wrong, you need to flush the pipeline and roll back to the branch. Then you can restart down the other path.
    If you guess right every time, the execution will never have to stop.
    If you guess wrong too often, you spend a lot of time stalling, rolling back, and restarting.

    Notice that the data is evenly distributed between 0 and 255.
    When the data is sorted, roughly the first half of the iterations will not enter the if-statement.
    After that, they will all enter the if-statement.

    This is very friendly to the branch predictor since the branch consecutively goes the same direction many times.
    Even a simple saturating counter will correctly predict the branch except for the few iterations after it switches direction.

    However, when the data is completely random, the branch predictor is rendered useless because it can't predict random data.
    Thus there will probably be around 50% misprediction. (no better than random guessing)

38.
Monitors in C++
http://stackoverflow.com/questions/12647217/making-a-c-class-a-monitor-in-the-concurrent-sense

39.
PThreads:
http://stackoverflow.com/questions/21323628/warning-cast-to-from-pointer-from-to-integer-of-different-size
http://stackoverflow.com/questions/1640423/error-cast-from-void-to-int-loses-precision

    Pthread Join and Pthread exit
http://stackoverflow.com/questions/20824229/when-to-use-pthread-exit-and-when-to-use-pthread-join-in-linux

    Both methods ensure that your process doesn't end before all of your threads have ended.

    The join method has your thread of the main function explicitly wait for all threads that are to be "joined".

    The pthread_exit method terminates your main function and thread in a controlled way. main has the particularity that ending main otherwise would be terminating your whole process including all other threads.

40.
Convert Vector to Array and Array to Vector
http://stackoverflow.com/questions/2923272/how-to-convert-vector-to-array-c

    There's a fairly simple trick to do so, since the spec now guarantees vectors store their elements contiguously:
        std::vector<double> v;
        double* a = &v[0];

    Convert array to vector:
http://stackoverflow.com/questions/8777603/what-is-the-simplest-way-to-convert-array-to-vector

        int x[3]={1, 2, 3};
        std::vector<int> v(x, x + sizeof x / sizeof x[0]);

    VERY IMP: GIVES ERROR
        void fn(vector<int>& nums)

        int arr[] = {1,2,3}
        fn(vector<int> (arr, arr + sizeof(arr)/sizeof(arr[0]);
    
    As the function take a REFERENCE, we should first store in a variable before passing it. Cant pass a value to a reference.

Converting String to Vector of Chars
http://stackoverflow.com/questions/8263926/how-to-copy-stdstring-into-stdvectorchar

        std::string str = "hello";
        std::vector<char> data(str.begin(), str.end());

    If you already have a vector and want to add the characters at the end, you need a back inserter:

        std::string str = "hello";
        std::vector<char> data = /* ... */;
        std::copy(str.begin(), str.end(), std::back_inserter(data));

41.
Initialization of a normal array with one default value
http://stackoverflow.com/questions/1065774/c-c-initialization-of-a-normal-array-with-one-default-value

    Using the syntax that you used:
        int array[100] = {-1};
    says "set the first element to -1 and the rest to 0" since all omitted elements are set to 0.

    In C++, to set them all to -1, you can use something like std::fill_n (from <algorithm>):
        std::fill_n(array, 100, -1);

Initialize TwoD (two dimensional) array with 0
    int a[100][200] = {{0}};

    OR 

    fill_n( a, 100*200, 0 );

42.
Templates: Template keyword vs Class keyword
http://stackoverflow.com/questions/213121/use-class-or-typename-for-template-parameters

    Stroustrup originally used class to specify types in templates to avoid introducing a new keyword.
    Some in the committee worried that this overloading of the keyword led to confusion.
    Later, the committee introduced a new keyword typename to resolve syntactic ambiguity, and decided to let it also be used to specify template types to reduce confusion, but for backward compatibility, class kept its overloaded meaning.

43.
comparing int with size_t
http://stackoverflow.com/questions/3642010/comparing-int-with-size-t

    size_t CANNOT be compared with int when the int is INT is negative

    It's safe provided the int is zero or positive.
    If it's negative, and size_t is of equal or higher rank than int, then the int will be converted to size_t and so its negative value will instead become a positive value.
    This new positive value is then compared to the size_t value, which may (in a staggeringly unlikely coincidence) give a false positive.
    To be truly safe (and perhaps overcautious) check that the int is nonnegative first:

    /* given int i; size_t s; */
        if (i>=0 && i == s)
    and to suppress compiler warnings:
    if (i>=0 && (size_t)i == s)

44.
Unicode vs Ascii
http://stackoverflow.com/questions/19212306/whats-the-difference-between-ascii-and-unicode

    ASCII defines 128 characters, which map to the numbers 0127.
    Unicode defines (less than) 221 characters, which, similarly, map to numbers 0221 (though not all numbers are currently assigned, and some are reserved).

45.
Where are Class Members stored in memory
http://stackoverflow.com/questions/15572411/where-are-member-functions-stored-for-an-object
http://stackoverflow.com/questions/22119360/class-members-and-member-functions-memory-location/22119456#22119456
http://stackoverflow.com/questions/1169858/global-memory-management-in-c-in-stack-or-heap
http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch10s04.html

    Typically a process has 5 different areas of memory allocated

        Code - text segment
        Initialized data  data segment
        Uninitialized data  bss segment
        Heap
        Stack

    The size of the text and data segments are known as soon as compilation or assembly is completed. The stack and heap segments, on the other hand, grow and shrink during program execution.

    In the assembler's point of view, all variables are global.
    The notion of a variable's scope in C or Java is enforced by the compiler, not the hardware.
    Hardware knows only about memory addresses, and the compiler must keep track of which addresses are used by each subprogram.

    member functions don't eat any additional space in the object. If it is non-virtual, it is just a plain function (in the code segment)

    Member functions or pointers to them aren't stored in the object.
    (virtual functions are typically called through a pointer stored in a table to which an object has a single pointer to) This would be a huge waste of memory. 

    They're typically stored in a code memory section, and are known to the compiler.
    The object (*this) is typically passed as an invisible parameter so the functions know on which object to operate when they are called.

    Size of a C++ Object is determined by Classs data members and base classes
    Only non-virtual data members occupy space.
    Each instance of derived class will contain a complete copy of the instance data of the base class

http://stackoverflow.com/questions/5037701/where-are-const-objects-stored
http://programmers.stackexchange.com/questions/142475/how-does-const-storage-work-item-2-scott-myers-effective-c
    Compilers wouldn't set aside data memory for const objects of integer type: they would trade it for program memory.

    Automatic variables are either stored on the stack or in a register. Doesn't matter if they're const or not.

    Static variables are stored in program memory.
    There may be multiple blocks of program memory, some read-only and some not.
    Declaring a variable const may affect which block something is stored in.

    Variables allocated with new will be on the heap. Doesn't matter if it's const or not.

    STATIC MEMBER FUNCTIONS:
        http://stackoverflow.com/questions/10952385/distinguish-if-a-c-static-method-is-called-by-the-class-or-by-an-object
        Can be called either using an object or just with the Class Name

    CALLING A MEMBER FUNCTION WILL BE A JUMP INSTRUCTION TO THAT FUNCTION

45b.
Memory Layout - Code Segment Data Segment Stack Heap
    http://www.geeksforgeeks.org/memory-layout-of-c-program/

    Text / Code Segment:
        Machine instructions gets stored here
        Code segment, also known as text segment contains machine code of the compiled program.
        The text segment of an executable object file is often read-only segment that prevents a program from being accidentally modified.

    DATA Segment:
        - Has Initialized and Uninitialized segments
        Data segment stores program data.
        This data could be in form of initialized or uninitialized variables, and it could be local or global.
        Data segment is further divided into four sub-data segments (initialized data segment, uninitialized or .bss data segment, stack, and heap)



46.
C++ Class vs C Struct Memory Layout
http://stackoverflow.com/questions/422830/structure-of-a-c-object-in-memory-vs-a-struct

    The C++ standard guarantees that memory layouts of a C struct and a C++ class (or struct -- same thing) will be identical, provided that the C++ class/struct fits the criteria of being POD ("Plain Old Data").

    So what does POD mean?
    A class or struct is POD if:
    All data members are public and themselves POD or fundamental types (but not reference or pointer-to-member types), or arrays of such
    It has no user-defined constructors, assignment operators or destructors
    It has no virtual functions
    It has no base classes

47.
Pass by Value vs Const Reference
http://stackoverflow.com/questions/2582797/why-pass-by-const-reference-instead-of-by-value
http://stackoverflow.com/questions/1567138/const-t-arg-vs-t-arg/1567186#1567186

    Passing arguments by value and thus copying them can be expensive - const references avoid that expensive step while still promising the caller that the object won't be changed.
    Usually fundamental types (int, double, ...) are passed by value, while class-types are passed by const reference.

    Use const T & arg if sizeof(T)>sizeof(void*) and use T arg if sizeof(T) <= sizeof(void*)

48.
Virtual Function and Pure Virtual Functions
http://stackoverflow.com/questions/1306778/c-virtual-pure-virtual-explained?rq=1

    - What a Virtual function will do is,
        - It will make its CLASS a polymorphic base class. 
        - So we can have derived classes that can override the virtual methods in the base class.

    - What a PURE Virtual function will do is,
        http://stackoverflow.com/questions/1306778/c-virtual-pure-virtual-explained
        - When you want SOMEONE TO DEFINE ALL THE METHODS in your class.
        - It will make the base Class ABSTRACT. And any class that derives it MUST have an 
          implementation for the virtual function.
        - A pure virtual function or pure virtual method is a virtual function that is
          REQUIRED to be implemented by a derived class that is not abstract"

    A virtual function or virtual method is a function or method whose behavior can be overridden within an inheriting class by a function with the same signature 

    A pure virtual function or pure virtual method is a virtual function that is required to be implemented by a derived class that is not abstract" - Wikipedia

    The virtual keyword gives C++ its' ability to support polymorphism. When you have a pointer to an object of some class such as:

        class Animal
        {
          public:
            virtual int GetNumberOfLegs() = 0;
        };

        class Duck : public Animal
        {
          public:
             int GetNumberOfLegs() { return 2; }
        };

        class Horse : public Animal
        {
          public:
             int GetNumberOfLegs() { return 4; }
        };

        void SomeFunction(Animal * pAnimal)
        {
          cout << pAnimal->GetNumberOfLegs();
        }

    In this (silly) example, the GetNumberOfLegs() function returns the appropriate number based on the class of the object that it is called for.
    Now, consider the function 'SomeFunction'.
    It doesn't care what type of animal object is passed to it, as long as it is derived from Animal.
    The compiler will automagically cast any Animal-derived class to a Animal as it is a base class.

    If we do this:
        Duck d;
        SomeFunction(&d);
    it'd output '2'.

    If we do this:
        Horse h;
        SomeFunction(&h);
    it'd output '4'.

    We can't do this:
        Animal a;
        SomeFunction(&a);
    because it won't compile due to the GetNumberOfLegs() virtual function being pure, which means it must be implemented by deriving classes (subclasses).

    Pure Virtual Functions are mostly used to define:
        a) abstract classes
        These are base classes where you have to derive from them and then implement the pure virtual functions.

        b) interfaces
        These are 'empty' classes where all functions are pure virtual and hence you have to derive and then implement all of the functions.

    Purpose of Virtual in C++
        - When you want to OVERRIDE an method in base class AND
            - CALL it using a base class pointer
        You use virtual functions when you want to override a certain behavior (read method) for your derived class rather than the one implemented for the base class and
    you want to do so at run-time through a pointer to the base class. 


49.
Virtual Functions
http://stackoverflow.com/questions/2391679/why-do-we-need-virtual-methods-in-c

    Each time you create a class that contains virtual functions, or you derive from a class that contains virtual functions, the compiler creates a VTABLE for that class
    In that table it places the addresses of all the functions that are declared virtual in this class or in the base class

    Why VIRTUAL Methods in C++
        Let's say you have these two classes:

        class Animal
        {
        public:
        void eat() { std::cout << "I'm eating generic food."; }
        }

        class Cat : public Animal
        {
        public:
        void eat() { std::cout << "I'm eating a rat."; }
        }

        In your main function:

        Animal *animal = new Animal;
        Cat *cat = new Cat;

        animal->eat(); // outputs: "I'm eating generic food."
        cat->eat();    // outputs: "I'm eating a rat."

        So far so good right? Animals eat generic food, cats eat rats, all without virtual.

        Let's change it a little now so that eat() is called via an intermediate function (a trivial function just for this example):

        //this can go at the top of the main.cpp file
        void func(Animal *xyz) { xyz->eat(); }

        Now our main function is:

        Animal *animal = new Animal;
        Cat *cat = new Cat;

        func(animal); // outputs: "I'm eating generic food."
        func(cat);    // outputs: "I'm eating generic food."

        Uh oh... we passed a Cat into func(), but it won't eat rats. Should you overload func() so it takes a Cat* ? If you have to derive more animals from Animal they would all need their own func().

        The solution is to make eat() a virtual function:

        class Animal
        {
        public:
        virtual void eat() { std::cout << "I'm eating generic food."; }
        }
        class Cat : public Animal
        {
        public:
        void eat() { std::cout << "I'm eating a rat."; }
        }

        Main:

        func(animal); // outputs: "I'm eating generic food."
        func(cat);    // outputs: "I'm eating a rat."


50. new vs new()
http://stackoverflow.com/questions/620137/do-the-parentheses-after-the-type-name-make-a-difference-with-new

    new Thing(); is explicit that you want a constructor called whereas new Thing; is taken to imply you don't mind if the constructor isn't called

    If used on a struct/class with a user-defined constructor, there is no difference.
    If called on a trivial struct/class (e.g. struct Thing { int i; };) then new Thing; is like malloc(sizeof(Thing)); whereas new Thing(); is like calloc(sizeof(Thing)); - it gets zero initialized.


51.
Reading Multiple words from cin

    std::getline(cin, wordsList);

52.
Reading multiple lines from cin

        while (getline(cin, line))
        {
            if (!line.empty())
            {
                lines.push_back(line);
            }
            else
            {
                break;
            }
        }

53.
Using size_t for loops
http://www.embedded.com/electronics-blogs/programming-pointers/4026076/Why-size-t-matters
http://stackoverflow.com/questions/1951519/when-should-i-use-stdsize-t
http://stackoverflow.com/questions/19732319/difference-between-size-t-and-unsigned-int
http://stackoverflow.com/questions/131803/unsigned-int-vs-size-t

    Code that assumes sizeof yields an unsigned int would not be portable. Code that assumes it yields a size_t is more likely to be portable.

    The size_t type is meant to specify the size of something so it's natural to use it, for example, getting the length of a string and then processing each character:

        for (size_t i = 0, max = strlen (str); i < max; i++)
            doSomethingWith (str[i]);

    You do have to watch out for boundary conditions of course, since it's an unsigned type.
    The boundary at the top end is not usually that important since the maximum is usually large (though it is possible to get there).
    Most people just use an int for that sort of thing because they rarely have structures or arrays that get big enough to exceed the capacity of that int.

    IMP: But watch out for things like:

        for (size_t i = strlen (str) - 1; i >= 0; i--)

    which will cause an infinite loop due to the wrapping behaviour of unsigned values (although I've seen compilers warn against this).
    This can also be alleviated by the (slightly harder to understand but at least immune to wrapping problems):

        for (size_t i = strlen (str); i-- > 0; )


    So, you ask, why not just use an unsigned int?
        Because unsigned int is not the only unsigned integral type.
        size_t could be any of unsigned char, unsigned short, unsigned int, unsigned long or unsigned long long, depending on the implementation.

        It may not be able to hold big enough numbers.
        In an implementation where unsigned int is 32 bits, the biggest number it can represent is 4294967295.
        Some processors, such as the IP16L32, can copy objects larger than 4294967295 bytes.
        For example in 64 bit systems int and unsigned int may be 32 bit wide, but size_t must be big enough to store numbers bigger than 4G

    So, you ask, why not use an unsigned long int?
        It exacts a performance toll on some platforms.
        Standard C requires that a long occupy at least 32 bits.
        An IP16L32 platform implements each 32-bit long as a pair of 16-bit words.
        Almost all 32-bit operators on these platforms require two instructions, if not more, because they work with the 32 bits in two 16-bit chunks.
        For example, moving a 32-bit long usually requires two machine instructions -- one to move each 16-bit chunk.

54.
size_t vs size_type
http://stackoverflow.com/questions/918567/size-t-vs-containersize-type

    size_type - C++
    For better portability

    This is how SIZE should be used
        for(size_t i = 0; i < dataVecs.size(); i++)

    This is how SIZE_TYPE should be used
        for(vector<string>::size_type i = 0; i < dataVecs.size(); i++)

55.
File IO
http://www.cplusplus.com/doc/tutorial/files/

    For ifstream and ofstream classes, ios::in and ios::out are automatically and respectively assumed, even if a mode that does not include them is passed as second argument to the open member function (the flags are combined).

    Copying from One file to Another
        ifstream in("document1.txt");
        ofstream out("document2.txt");
        string str;
        while(getline(in,str))
        {
            out<<str;
        }
        in.close(); // <---
        out.close(); // <---

        // position to the nth byte of fileObject (assumes ios::beg)
        fileObject.seekg( n );

        // position n bytes forward in fileObject
        fileObject.seekg( n, ios::cur );

        // position n bytes back from end of fileObject
        fileObject.seekg( n, ios::end );

        // position at end of fileObject
        fileObject.seekg( 0, ios::end );

    Using ENDL will cause the buffer to be FLUSH. So use "\n" for performance reasons
    Closing the file will flush the buffer.

    Output in C++ may be buffered.
    This means that anything that is output to a file stream may not be written to disk immediately.
    Instead, several output operations may be batched and handled together.
    This is done primarily for performance reasons.
    When a buffer is written to disk, this is called flushing the buffer.
    One way to cause the buffer to be flushed is to close the file -- the contents of the buffer will be flushed to disk, and then the file will be closed.

    Buffering is usually not a problem, but in certain circumstance it can cause complications for the unwary.
    The main culprit in this case is when there is data in the buffer, and then program terminates immediately (either by crashing, or by calling exit()).
    In these cases, the destructors for the file stream classes are not executed, which means the files are never closed, which means the buffers are never flushed.
    In this case, the data in the buffer is not written to disk, and is lost forever.
    This is why it is always a good idea to explicitly close any open files before calling exit().

    It is possible to flush the buffer manually using the ostream::flush() function or sending std::flush to the output stream.
    Either of these methods can be useful to ensure the contents of the buffer are written to disk immediately, just in case the program crashes.

    One interesting note is that std::endl; also flushes the output stream.
    Consequently, overuse of std::endl (causing unnecessary buffer flushes) can have performance impacts when doing buffered I/O where flushes are expensive (such as writing to a file).
    For this reason, performance conscious programmers will often use \n instead of std::endl to insert a newline into the output stream, to avoid unnecessary flushing of the buffer.

56:
What is string::npos
http://www.cplusplus.com/reference/string/string/npos/

    npos is a static member constant value with the greatest possible value for an element of type size_t.

    This value, when used as the value for a len (or sublen) parameter in string's member functions, means "until the end of the string"

57.
Meaning of const
http://stackoverflow.com/questions/1143262/what-is-the-difference-between-const-int-const-int-const-and-int-const
http://www.gotw.ca/gotw/006.htm
http://stackoverflow.com/questions/455518/how-many-and-which-are-the-uses-of-const-in-c

        int* - pointer to int
        int const * - pointer to const int
        int * const - const pointer to int
        int const * const - const pointer to const int

    Now the first const can be on either side of the type so:

        const int * == int const *
        const int * const == int const * const

    Since the point object is passed by value, there is little or no benefit to declaring it const.
    Normally const pass-by-value is unuseful and misleading at best.


    CONST MEMBER FUNCTION:
        const int* const Method3(const int* const&) const;
    The final const means that the function Method3 does not modify the non mutable members of its class.

    CONST variable can either be stored in CODE segment and just copied over.

    c1 is different from the other two constants in that it is initialized with a literal value.
    This lets compiler put that value everywhere the constant is used, like this:
        int x = z + c1;
    can be replaced by
        int x = z + 1; <--- This is constant folding

    This means that the compiler does not need to allocate space and store 1 in it.

    c3 and c4 are different: one is calculated using a function, and the other one is supplied from a different compilation unit.
    This means that the compiler can no longer perform the substitution the way it could with c1: the values of the c3 and c4 are not known to the compiler.
    Therefore the compiler generates code for

        int x = z + c4;
    in the same way as if c4 were a variable stored in some place in memory.


57a.
Const vs ReadOnly
http://stackoverflow.com/questions/4486442/how-does-const-differ-in-c-and-c
http://stackoverflow.com/questions/4486326/does-const-just-mean-read-only-or-something-more

    By declaring a variable as const you indicate compiler that you have no intentions of modifying that variable. But it does not mean others don't have

    const does not mean read only, because you can write const volatile, that would mean it could change by itself anytime, but I have no intentions to modify it.

    EDIT: here is a classical example: consider I'm writing the code that reads current time from a memory-mapped port. Consider that RTC is mapped to memory DWORD 0x1234.

        const volatile DWORD* now = *(DWORD*)0x1234;

    It's const because it's a read-only port, and it's volatile because each time I will read it it will change

     It reminds you as you look at function prototypes of the contract that your functions expect.
     Your compiler will yell at you if you carelessly break it.
     (But not if you intentionally break it, as with the above cast.)

    const means that you promise not to mutate the variable.
    It could still be changed.
        class A {
          public:
            A(const int& a);
            int getValue() const;
            void setValue(int b);
          private:
            const int& a;
        };
        A::A(a) : a(a) {}
        int A::getValue() const {
            return a;
        }
        void A::setValue(int b) {
            a = b;  // error
        }

        int main() {
            int my_a = 0;
            A a(my_a);
            std::cout << a.getValue() << std::endl;  // prints 0
            my_a = 42;
            std::cout << a.getValue() << std::endl;  // prints 42
        }

    No method A::* may change a, but main can.

57b.
Const in C vs C++
http://stackoverflow.com/questions/4486442/how-does-const-differ-in-c-and-c

    const in C cannot be used to build constant expressions.

    For example :
        #include <stdio.h>
        int main()
        {
           int i = 2;
           const int C = 2;
           switch(i)
           {
              case C  : printf("Hello") ;
              break;

              default : printf("World");
           }
        }

    doesn't work in C because case label does not reduce to an integer constant.

58.
Reason to pass a pointer by reference
http://stackoverflow.com/questions/10240161/reason-to-pass-a-pointer-by-reference-in-c

    Linked List, changing the HEAD pointer.

    You would want to pass a pointer by reference if you have a need to modify the pointer rather than the object that the pointer is pointing to.

    This is similar to why double pointers are used; using a reference to a pointer is slightly safer than using pointers.


    50% of C++ programmers like to set their pointers to null after a delete:

    template<typename T>    
    void moronic_delete(T*& p)
    {
        delete p;
        p = nullptr;
    }

    Without the reference, you would only be changing a local copy of the pointer, not affecting the caller.

59.
Returning by reference:
http://stackoverflow.com/questions/752658/is-the-practice-of-returning-a-c-reference-variable-evil

        int& getInt(void)
        {
            int i;
            return i;
        }

    That is all sorts of evil. The stack-allocated i will go away and you are referring to nothing. This is semi-evil:

        int& getInt(void)
        {
            int *i = new int;
            return *i;
        }

    Because now the client has to eventually do the strange:

        int& myInt = getInt(); // note the &.
        int badInt = getInt(); // the & will be easy to miss (source of problems).
        delete &myInt; // must delete.
        delete &badInt; // won't work. badInt was a copy of the allocated int, which
                        // is now lost forever

    I think the best way to do something like that is just:

        int *getInt(void)
        {
            return new int;
        }

    And now the client stores a pointer:

        int *myInt = getInt(); // has to be a pointer
        int& weirdInt = *getInt(); // but this works too if you really want.
        delete myInt; // being a pointer, this is easy to do.
        delete &weirdInt; // works.

    Now for members of classes, & is powerful, such as operator chaining (cout's <<), or operator[].

    What is evil is making a reference to a dynamically allocated object and losing the original pointer. When you new an object you assume an obligation to have a guaranteed delete.

    But have a look at, eg, operator<<: that must return a reference, or

        cout << "foo" << "bar" << "bletch" << endl ;

    won't work.

60.
Sorting a vector of objects
http://stackoverflow.com/questions/1380463/sorting-a-vector-of-custom-objects

        struct MyStruct
        {
            int key;
            std::string stringValue;

            MyStruct(int k, const std::string& s) : key(k), stringValue(s) {}

            bool operator < (const MyStruct& str) const
            {
                return (key < str.key);
            }
        };

    Using this method means you can simply sort the vector as follows:

        std::sort(vec.begin(), vec.end());

    DESCENDING ORDER:
        struct MyStruct
        {
            int key;
            std::string stringValue;

            MyStruct(int k, const std::string& s) : key(k), stringValue(s) {}

            bool operator > (const MyStruct& str) const
            {
                return (key > str.key);
            }
        };

    And you should call sort as:
        std::sort(vec.begin(), vec.end(), greater<MyStruct>())

        struct Xgreater
        {
            bool operator()( const X& lx, const X& rx ) const {
                return lx.x < rx.x;
            }
        };
        std::sort( my_vec.begin(), my_vec.end(), Xgreater() );

61.
Find rightmost set bit
http://www.geeksforgeeks.org/position-of-rightmost-set-bit/
http://stackoverflow.com/questions/20026243/find-2-missing-numbers-in-an-array-of-integers-with-two-missing-values

        log2(n&-n)+1;

    Find leftmost set bit
        x = x &(~(x-1));

62. 
#define vs typedef vs Enum
http://stackoverflow.com/questions/1666353/are-typedef-and-define-the-same-in-c

    A typedef is generally preferred unless there's some odd reason that you specifically need a macro.

    macros do textual substitution, which can do considerable violence to the semantics of the code.

    #define is a preprocessor token: the compiler itself will never see it.
    typedef is a compiler token: the preprocessor does not care about it.

    typedef obeys scoping rules just like variables, whereas
    define stays valid until the end of the file (or until a matching undef

        typedef int* int_p1;
        int_p1 a, b, c;  // a, b, and c are all int pointers.

        #define int_p2 int*
        int_p2 a, b, c;  // only the first is a pointer!

        typedef int a10[10];
        a10 a, b, c; // create three 10-int arrays

http://stackoverflow.com/questions/1674032/static-const-vs-define-vs-enum
        static const int var = 5;
        #define var 5
        enum { var = 5 };

    Ignoring issues about the choice of name, then:
        If you need to pass a pointer around, you must use (1).
        Since (2) is apparently an option, you don't need to pass pointers around.
        Both (1) and (3) have a symbol in the debugger's symbol table - that makes debugging easier. It is more likely that (2) will not have a symbol, leaving you wondering what it is.
        (1) cannot be used as a dimension for arrays at global scope; both (2) and (3) can.
        (1) cannot be used as a dimension for static arrays at function scope; both (2) and (3) can.
        Under C99, all of these can be used for local arrays. Technically, using (1) would imply the use of a VLA (variable-length array), though the dimension referenced by 'var' would of course be fixed at size 5.
        (1) cannot be used in places like switch statements; both (2) and (3) can.
        (1) cannot be used to initialize static variables; both (2) and (3) can.
        (2) can change code that you didn't want changed because it is used by the preprocessor; both (1) and (3) will not have unexpected side-effects like that.
        You can detect whether (2) has been set in the preprocessor; neither (1) nor (3) allows that.

    So, in most contexts, prefer the 'enum' over the alternatives.
    Otherwise, the first and last bullet points are likely to be the controlling factors  and you have to think harder if you need to satisfy both at once.

    If you were asking about C++, then you'd use option (1)  the static const  every time

62a.
C++ Const vs #Define vs Enum
http://stackoverflow.com/questions/1637332/static-const-vs-define
http://stackoverflow.com/questions/1674032/static-const-vs-define-vs-enum

    And, finally, in C++ const is preferable.
    At least because such constants are typed and scoped.
    There are simply no reasons to prefer #define over const, aside from few exceptions.

    String constants, BTW, are one example of such an exception.
    With #defined string constants one can use compile-time concatenation feature of C/C++ compilers, as in
        #define OUT_NAME "output"
        #define LOG_EXT ".log"
        #define TEXT_EXT ".txt"

        const char *const log_file_name = OUT_NAME LOG_EXT;
        const char *const text_file_name = OUT_NAME TEXT_EXT;

    It depends on what you need the value for.
    You (and everyone else so far) omitted the third alternative:

        (1) static const int var = 5;
        (2) #define var 5
        (3) enum { var = 5 };

    Ignoring issues about the choice of name, then:
        * If you need to pass a pointer around, you must use (1).
        Since (2) is apparently an option, you don't need to pass pointers around.
        Both (1) and (3) have a symbol in the debugger's symbol table - that makes debugging easier. It is more likely that (2) will not have a symbol, leaving you wondering what it is.
        (1) cannot be used as a dimension for arrays at global scope; both (2) and (3) can.
        (1) cannot be used as a dimension for static arrays at function scope; both (2) and (3) can.
        Under C99, all of these can be used for local arrays. Technically, using (1) would imply the use of a VLA (variable-length array), though the dimension referenced by 'var' would of course be fixed at size 5.
        (1) cannot be used in places like switch statements; both (2) and (3) can.
        (1) cannot be used to initialize static variables; both (2) and (3) can.
        (2) can change code that you didn't want changed because it is used by the preprocessor; both (1) and (3) will not have unexpected side-effects like that.
        * You can detect whether (2) has been set in the preprocessor; neither (1) nor (3) allows that.

    So, in most contexts, prefer the 'enum' over the alternatives.
    Otherwise, the first and last bullet points are likely to be the controlling factors  and you have to think harder if you need to satisfy both at once.

    If you were asking about C++, then you'd use option (1)  the static const  every time

62a.
C++ semantics of `static const` vs `const`
http://stackoverflow.com/questions/3709207/c-semantics-of-static-const-vs-const

Question:
    In C++ specifically, what are the semantic differences between for example:
        static const int x = 0 ;
    and
        const int x = 0 ;
    for both static as a linkage and a storage class specifier (i.e. inside and outside a function).

Solution:
    At file scope, no difference in C++.
    const makes internal linkage the default, and all global variables have static lifetime.
    But the first variant has the same behavior in C, so that may be a good reason to use it.

    Within a function, the second version can be computed from parameters, in C or C++ it doesn't have to be a compile-time constant like some other languages require.

    Within a class, basically the same thing as for functions, an instance const value can be computed in the ctor-initializer-list.
    A static const is set during startup initialization and remains unchanged for the rest of the program.
    (Note: the code for static members looks a little different because declaration and initialization are separated.)

    Remember, in C++, const means read-only, not constant.
    If you have a pointer-to-const then other parts of the program may change the value while you're not looking.
    If the variable was defined with const, then no one can change it after initialization but initialization can still be arbitrarily complex.

62b.
C++ Const Read Only

62b.
Const defaults to Internal Linkage in C++ and External Linkage in C
Thinking in C++ Pg 288

62c.
When to use unnamed namespace
http://stackoverflow.com/questions/5312213/uses-of-unnamed-namespace-in-c
C++ Primer - Pg 431
Thinking in C++ - Pg 289

    When you want an object to be available only for that SPECIFIC file and not for the entire progrgam.

    The names of global functions, global variables, and classes are still in a single global name space.
    The static keyword gives you some control over this by allowing you to give variables and functions internal linkage (make them file static).
    A namespace definition can be continued over multiple header files

    According to Stroustrup, you should use it in places where in old C you would have made static globals.
    The idea is that the items in question can be "global" to the source file they are in, but not pollute the namespace of any other source files in your compilation.

    In other words, you shouldn't be creating static globals in C++.
    You should be using unnamed namespaces instead.

62d.
Superiority of unnamed namespace over static
http://stackoverflow.com/questions/4422507/superiority-of-unnamed-namespace-over-static

Question:
    The project makes frequent use of unnamed namespaces.
    For example, something like this may occur in a class definition file:

        // newusertype.cc
        namespace {
          const int SIZE_OF_ARRAY_X;
          const int SIZE_OF_ARRAY_Y;
          bool getState(userType*,otherUserType*);
        }

        newusertype::newusertype(...) {...

    What are the design considerations that might cause one to use an unnamed namespace? What are the advantages and disadvantages?

Solution:
http://en.cppreference.com/w/cpp/language/namespace#Unnamed_namespaces
    SINCE C++11
    Unnamed namespaces as well as all namespaces declared directly or indirectly within an unnamed namespace have internal linkage, which means that any name that is declared within an unnamed namespace has internal linkage. 

    The use of the static keyword is deprecated when declaring objects in a namespace scope; the unnamed-namespace provides a superior alternative.

    Unnamed namespace is superior to static keyword, primarily because the keyword static applies only to the variables declarations and functions, not to the user-defined types.

    The following code is valid in C++
       //legal code
       static int sample_function() { /* function body */ }
       static int sample_variable;

    But this code is NOT valid:
       //illegal code
       static class sample_class { /* class body */ };
       static struct sample_struct { /* struct body */ };

    So the solution is, unnamed-namespace, which is this,
       //legal code
       namespace 
       {  
            class sample_class { /* class body */ };
            struct sample_struct { /* struct body */ };
       }

62e.
Why Static still exists
http://stackoverflow.com/questions/8460327/why-are-anonymous-namespaces-not-a-sufficient-replacement-for-namespace-static

    unnamed namespaces place entities into different namespaces (in addition to affecting their linkage).
    static only affects the linkage, leaving the namespace of which functions and variables are a member of unchanged.

63.
Dynamic Array in C++
Variable Length arrays
http://stackoverflow.com/questions/1204521/dynamic-array-in-stack
http://stackoverflow.com/questions/14989674/dynamic-array-without-new-operator
http://stackoverflow.com/questions/5368531/why-cant-i-create-an-array-of-size-n

    int n;
    cin >> n;
    int array[n];

    This will work if use g++. g++ support VLAs as an extension. However ISO C++ mandates size of an array to be a constant expression i.e the size must be known at compile time.

        Why is it that C++ don't allow you to create array of dynamic length in stack memory?

    Simple answer "Because the standard says so". Even the upcoming C++ Standard (C++0x) is not going to allow Variable Length Arrays.

    Below Code is standard C99. This is because C99 allows you to declare arrays dynamically that way.
    To clarify, this is also standard C99:
        #include <stdio.h>

        int main()
        {
            int x = 0;

            scanf("%d", &x);

            char pz[x]; 
        }

    This is not standard anything:
        #include <iostream>
        int main()
        {
            int x = 0;
            std::cin >> x;
            char pz[x]; 
        }
    It cannot be standard C++ because that required constant array sizes, and it cannot be standard C because C does not have std::cin (or namespaces, or classes, etc...)

    To make it standard C++, do this:
        int main()
        {
            const int x = 12; // x is 12 now and forever...
            char pz[x]; // ...therefore it can be used here
        }

    If you want a dynamic array, you can do this:
        #include <iostream>

        int main()
        {
            int x = 0;
            std::cin >> x;

            char *pz = new char[x];

            delete [] pz;
        }

    But you should do this:
        #include <iostream>
        #include <vector>

        int main()
        {
            int x = 0;
            std::cin >> x;

            std::vector<char> pz(x);
        }

63b.
TWOD Vector in C++
http://stackoverflow.com/questions/17663186/initializing-a-two-dimensional-stdvector

        std::vector::vector(count, value)
        vector< vector<int> > myTwoDVec(rows, vector<int> (cols, 5));

64.
Time in C++
http://www.cplusplus.com/reference/ctime/tm/
http://code.runnable.com/U2DKRsrlaUEEYt4f/get-the-current-local-time-with-ctime-for-c%2B%2B

        time_t rawTime = time(nullptr);   // get time now
        //time_t rawTime = time(0);   // get time now
        struct tm *locTime = localtime(& rawTime); // Convert to tm struct
        cout << "Year: " << locTime->tm_year + 1900 << endl;
        cout << "Mon : " << locTime->tm_mon + 1 << endl;
        cout << "Hour: " << locTime->tm_hour << endl;
        cout << "Min : " << locTime->tm_min << endl;
        cout << "Sec : " << locTime->tm_sec << endl;

65.
Ordered Data Set
http://stackoverflow.com/questions/17296570/best-data-structure-for-ordered-list-performance

    There are at least two efficient solutions:

        Append elements to a vector; sort the vector; scan the vector.
        Insert elements into a priority_queue; drain it.

    The vector has the advantage of O(N) load time (vs. O(N log N) for the priority_queue). (Note that it still takes O(N log N) overall, due to the sort).

    The priority_queue has the advantage of freeing memory as you drain it. This doesn't reduce the maximum memory footprint, and is probably of negligible benefit, but it's worth trying anyway

66. 
Tail Recursion
http://stackoverflow.com/questions/33923/what-is-tail-recursion

    In traditional recursion, the typical model is that you perform your recursive calls first, and then you take the return value of the recursive call and calculate the result.
    In this manner, you don't get the result of your calculation until you have returned from every recursive call.

    In tail recursion, you perform your calculations first, and then you execute the recursive call, passing the results of your current step to the next recursive step.
    Basically, the return value of any given recursive step is the same as the return value of the next recursive call.

    The consequence of this is that once you are ready to perform your next recursive step, you don't need the current stack frame any more.
    This allows for some optimization.
    In fact, with an appropriately written compiler, you should never have a stack overflow snicker with a tail recursive call.
    Simply reuse the current stack frame for the next recursive step. I'm pretty sure Lisp does this.

67. 
Extern Variable; Static vs Extern
http://stackoverflow.com/questions/10422034/when-to-use-extern-in-c
Thinking in C++ PG 288

    It is useful when you share a variable between a few modules. You define it in one module, and use extern in the others.

    For example:
    in file1.cpp:

        int global_int = 1;

    in file2.cpp:
        extern int global_int;
        //in some function
        cout << "global_int = " << global_int;

    In addition, the visibility of a is global, across all translation units.
    In terms of visibility, the opposite of static (visible only in this translation unit) is extern, which explicitly states that the visibility of the name is across all translation units.
    So the above definition is equivalent to saying
        extern int a = 0;

68.
vector<bool> vs bitset
http://stackoverflow.com/questions/17794569/why-is-vectorbool-not-a-stl-container
http://stackoverflow.com/questions/4156538/how-can-stdbitset-be-faster-than-stdvectorbool

    Note: vector<bool> is overloaded and not very efficient (i.e. this structure was optimized for size not speed)

    Measurements on Visual Studio 2010 show that std::bitset is not generally faster than std::vector<bool>
    For space-optimization reasons, the C++ standard (as far back as C++98) explicitly calls out vector<bool> as a special standard container where each bool uses only one bit of space rather than one byte as a normal bool would (implementing a kind of "dynamic bitset").
    In exchange for this optimization it doesn't offer all the capabilities and interface of a normal standard container.

69.
Reading from file, donot use EOF for checking
http://stackoverflow.com/questions/5605125/why-is-iostreameof-inside-a-loop-condition-considered-wrong

    Because iostream::eof will only return true after reading the end of the stream. It does not indicate, that the next read will be the end of the stream.

    Consider this (and assume then next read will be at the end of the stream):

        while(!inStream.eof()){
          int data;
          // yay, not end of stream yet, now read ...
          inStream >> data;
          // oh crap, now we read the end and *only* now the eof bit will be set (as well as the fail bit)
          // do stuff with (now uninitialized) data
        }

    Against this:
        int data;
        while(inStream >> data){
          // when we land here, we can be sure that the read was successful.
          // if it wasn't, the returned stream from operator>> would be converted to false
          // and the loop wouldn't even be entered
          // do stuff with correctly initialized data (hopefully)
        }

70.
Struct assignment vs memcpy
http://stackoverflow.com/questions/5383318/struct-assignment-or-memcpy

    struct1 = struct2;
    VS
    memcpy(&struct1, &struct2, sizeof(mystruct_t));

    USE struct1=struct2;
    notation is not only more concise, but also shorter and leaves more optimization opportunities to the compiler.
    The semantic meaning of = is an assignment, while memcpy just copies memory.
    That's a huge difference in readability as well, although memcpy does the same in this case.

    Also, if the structure is heavily padded, assignment might make the compiler emit something more efficient, since it doesn't have to copy the padding (and it knows where it is),
    but mempcy() doesn't so it will always copy the exact number of bytes you tell it to copy.


    MEMCPY is a SHALLOW COPY
    is a shallow copy. In other words, if you have a char * pointing to a specific string, both structures will point to the same string.

71.
Why 2's complement is used to represent negative numbers
http://stackoverflow.com/questions/1125304/why-is-twos-complement-used-to-represent-negative-numbers?rq=1
http://stackoverflow.com/questions/1049722/what-is-2s-complement
    
    - Makes addition with negative numbers simple
    - When register size increases from (say) 4 to 8, easy to just take MSB and copy it throughout.

    - Eg 1: 5 + (-2) would be
      0 101
      1 010
      -----
      1 111 <--- Wrong

    - With 2's complement: -2 would be 1101 + 1 = 1110
      0 101
      1 110
      -----
     10 011 = 3 (Discard the extra carry bit)

    Additionally, in the "intuitive" storage method, there are two zeroes:

    0000  "zero"
    1000  "negative zero"

    Which are intuitively the same number but have two different values when stored. Every application will need to take extra steps to make sure that non-zero values are also not negative zero.

    There's another bonus with storing ints this way, and that's when you need to extend the width of the register the value is being stored in.
    With two's complement, storing a 4-bit number in a 8-bit register is a matter of repeating its most significant bit:

        0001 (one, in four bits)
    00000001 (one, in eight bits)
        1110 (negative two, in four bits)
    11111110 (negative two, in eight bits)

    It's just a matter of looking at the sign bit of the smaller word and repeating it until it pads the width of the bigger word.

    With your method you would need to clear the existing bit, which is an extra operation in addition to padding:

        0001 (one, in four bits)
    00000001 (one, in eight bits)
        1010 (negative two, in four bits)
    10000010 (negative two, in eight bits)

    You still need to set those extra 4 bits in both cases, but in the "intuitive" case you need to clear the 5th bit as well.
    It's one tiny extra step in one of the most fundamental and common operations present in every application.

72.
Extern Linkage and Intern linkage and NO linkage

    External linkage means the symbol (function or global variable) is accessible throughout your program and
    internal linkage means that it's only accessible in one translation unit

    INTERNAL LINAKGE:
        Internal linkage means that storage is created to represent the identifier only for the file being compiled.
        Other files may use the same identifier name with internal linkage, or for a global variable, and no conflicts will be found by the linker - separate storage is created for each identifier.
        Internal linkage is specified by the keyword static in C and C++.

        Note that instead of using static for internal linkage it is better to use anonymous namespaces into which you can also put classes.
        The linkage for anonymous namespaces has changed between C++98 and C++11 but the main thing is that they are unreachable from other translation units.

            namespace {
               int i; // external linkage but unreachable from other translation units.
               class invisible_to_others { };
            }

    EXTERNAL LINKAGE:
        External linkage means that a single piece of storage is created to represent the identifier for all files being compiled.
        The storage is created once, and the linker must resolve all other references to that storage.
        Global variables and function names have external linkage.
        These are accessed from other files by declaring them with the keyword extern.
        Variables defined outside all functions (with the exception of const in C++) and function definitions default to external linkage.
        You can specifically force them to have internal linkage using the static keyword.
        You can explicitly state that an identifier has external linkage by defining it with the extern keyword.
        Defining a variable or function with extern is not necessary in C, but it is sometimes necessary for const in C++.

    NO LINKAGE:
        Automatic (local) variables exist only temporarily, on the stack, while a function is being
        called. The linker doesnt know about automatic variables, and they have no linkage


73.
How a Computer Compiles and Executes a C++ Program
http://sites.psu.edu/bdk5043/wp-content/uploads/sites/11448/2014/04/process_description.pdf
http://stackoverflow.com/questions/6264249/how-does-the-compilation-linking-process-work
        1. C++ Code -> (Preprocessor) -> Modified C++ Code -> (Compiler) -> Assembly Code -> (Assembler) -> Binary Code -> (Linker links with other external libs) -> Executable file
           -> (Loader) -> Gets loaded in main meory from disk
                    
    CALLING A MEMBER FUNCTION WILL BE A JUMP INSTRUCTION TO THAT FUNCTION

74.
When / Why to use stringstream
http://stackoverflow.com/questions/20594520/what-exactly-does-stringstream-do

    ostringstream os;
    os << "dec: " << 15 << " hex: " << std::hex << 15 << endl;
    cout<<os.str()<<endl;

    Sometimes it is very convenient to use stringstream to convert bettween strings and other numerical types.

75.
Steps involved for execution of a C program
http://www.thegeekstuff.com/2011/10/c-program-to-an-executable/
Thinking in C++ - Pg 167

    All global objects implicitly have static storage class, so if you say (at file scope),
        int a = 0;
    then storage for a will be in the programs static data area, and the initialization for a will occur once, before main( ) is entered

    Each separate C file is a translation unit.
    That is, the compiler is run separately on each translation unit, and when it is running it is aware of only that unit.
    Thus, any information you provide by including header files is quite important because it provides the compilers understanding of the rest of your program.

    External References should be resolved at Link Time
    For each translation unit, the compiler creates an object file, with an extension of .o or .obj or something similar.
    These object files, along with the necessary start-up code, must be collected by the linker into the executable program.
    During linking, all the external references must be resolved.
    For example, in Libtest.c, functions like initialize( ) and fetch( ) are declared (that is, the compiler is told what they look like) and used, but not defined.
    They are defined elsewhere, in Lib.c.
    Thus, the calls in Libtest.c are external references.
    The linker must, when it puts all the object files together, take the unresolved external references and find the addresses they actually refer to.
    Those addresses are put in to replace the external references.

75a.
Storage Classes - Static, Extern, Auto and Register
Thinking in C++

    The auto specifier is almost never used because it tells the compiler that this is a local variable.
    The compiler can always determine this fact from the context in which the variable is defined, so auto is redundant.

    A register variable is a local (auto) variable, along with a hint to the compiler that this particular variable will be heavily used, so the compiler ought to keep it in a register if it can.

76.
Abstract Class vs Interface
http://stackoverflow.com/questions/479142/when-to-use-an-interface-instead-of-an-abstract-class-and-vice-versa
http://stackoverflow.com/questions/197893/why-an-abstract-class-implementing-an-interface-can-miss-the-declaration-impleme


    Interface:
        - Interfaces have no implementation.
        - A class implementing an interface should implements all its functions.
        
    - Abstract class have some implementation.

When to use Abstract Class vs Interface
http://stackoverflow.com/questions/56867/interface-vs-base-class

    Theoretically you can override them from a higher base class, but essentially an interface allows you to add on only the things you need into a class without the need for inheritance.

    Use abstract clases and inheritance if you can make the statement "A is a B".
    Use interfaces if you can make the statement "A is capable of [doing] as", or also, abstract for what a class is, interface for what a class can do.
    For example, we can say a triangle is a polygon but it makes no sense to say a triangle is capable of being a polygon

        public class Dog : Mammal
        public class Cat : Mammal
        public class Giraffe : Mammal
        public class Rhinoceros : Mammal
        public class Hippopotamus : Mammal

        public interface IPettable
        {
            IList<Trick> Tricks{get; set;}
            void Bathe();
            void Train(Trick t);
        }

    The implementation for the above contract will not be the same between a cat and dog; putting their implementations in an abstract class to inherit will be a bad idea.

    Your Dog and Cat definitions should now look like:

        public class Dog : Mammal, IPettable
        public class Cat : Mammal, IPettable

77.
Can abstract class be instantiated
http://stackoverflow.com/questions/13670991/interview-can-we-instantiate-abstract-class

        abstract class My {
            public void myMethod() {
                System.out.print("Abstract");
            }
        }

    Poly.java:

        class Poly extends My {
            public static void main(String a[]) {
                My m = new My() {};
                m.myMethod();
            }
        }

    Now, compile both your source files:

        javac My.java Poly.java

    Now in the directory where you compiled the source code, you will see the following class files:

        My.class
        Poly$1.class  // Class file corresponding to anonymous subclass
        Poly.class

    See that class - Poly$1.class. It's the class file created by the compiler corresponding to the anonymous subclass you instantiated using the below code:

        new My() {};

    So, it's clear that there is a different class being instantiated. It's just that, that class is given a name only after compilation by the compiler

http://stackoverflow.com/questions/2091426/why-cant-we-create-objects-for-an-abstract-class-in-c/2091633#2091633
    They can't be instantiated for the simple reason that they're missing those methods.

    An abstract class is a description that is incomplete.
    It indicates what things need to be filled out to make it complete but without those bits its not complete.

    My first example was a chess game:
    The game has lots of pieces of different type (King,Queen,Pawn ... etc).

    But there are no actual objects of type piece, but all objects are instances of objects derived from piece.
    How can you have an object of something that is not fully defined.
    There is not point in creating an object of piece as the game does not know how it moves (that is the abstract part). It knows it can move but not how it does it.

    Classes are a collection of functions which operate on data.
    Functions themselves contain no memory in a class. The following class:

        struct dumb_class
        {
            void foo(){}
            void bar(){}
            void baz(){}
            // .. for all eternity

            int i;
        };
    Has a size of int.
    No matter how many functions you have ever, this class will only take up the space it takes to operate on an int.
    When you call a function in this class, the compiler will pass you a pointer to the place where the data in the class is stored; this is the this pointer.

    So, the function lie in memory somewhere, loaded once at the beginning of your program, and wait to be called with data to operate on.

    Virtual functions are different.
    The C++ standard does not mandate how the behavior of the virtual functions should go about, only what that behavior should be.
    Typically, implementations use what's called a virtual table, or vtable for short.
    A vtable is a table of function pointers, which like normal functions, only get allocated once.

    Take this class, and assume our implementor uses vtables:

        struct base { virtual void foo(void); };
        struct derived { virtual void foo(void); };

    The compiler will need to make two vtables, one for base and one for derived.
    They will look something like this:

        typedef /* some generic function pointer type */ func_ptr;

        func_ptr __baseTable[] = {&base::foo}; 
        func_ptr __derivedTable[] = {&derived::foo}; 

    How does it use this table? When you create an instance of a class above, the compiler slips in a hidden pointer, which will point to the correct vtable.
    So when you say:
        derived d;
        base* b = &d;
        b->foo();

    Upon executing the last line, it goes to the correct table (__derivedTable in this case), goes to the correct index (0 in this case), and calls that function.
    As you can see, that will end up calling derived::foo, which is exactly what should happen.

    Note, for later, this is the same as doing derived::foo(b), passing b as the this pointer.

    So, when virtual methods are present, the class of the size will increase by one pointer (the pointer to the vtable.)
    Multiple inheritance changes this a bit, but it's mostly the same. You can get more details at C++-FAQ.

    Now, to your question. I have:
        struct base { virtual void foo(void) = 0; }; // notice the = 0
        struct derived { virtual void foo(void); };

    and base::foo has no implementation.
    This makes base::foo a pure abstract function.  So, if I were to call it, like above:

        derived d;
        base* b = &d;
        base::foo(b);

    What behavior should we expect? Being a pure virtual method, base::foo doesn't even exist.
    The above code is undefined behavior, and could do anything from nothing to crashing, with anything in between. (Or worse.)

78.
C++ new int[0] - will it allocate memory
http://stackoverflow.com/questions/1087042/c-new-int0-will-it-allocate-memory?rq=1

    When the value of the expression in a direct-new-declarator is zero, the allocation function is called to allocate an array with no elements.
    The effect of dereferencing a pointer returned as a request for zero size is undefined.
    Even if the size of the space requested [by new] is zero, the request can fail.

http://stackoverflow.com/questions/9058103/memory-allocation-on-c-object-creation
        class C {
         int i;
         int j;
        };

        void f() {
         C *c = new C;
         C *c2 = new C[2];
         C (*c3)[2] = new C[2][2];
        }

    c is allocated with 8 bytes;

    c2 is allocated with 8*2+4 bytes;

    c3 is allocated with 8*2*2+4 bytes. 

    A lot of compilers use the 4 bytes before the pointer returned from new[] to store the number of objects actually being allocated.
    This is all implementation dependent

79.
C++ new vs C malloc
http://www.tutorialspoint.com/cplusplus/cpp_dynamic_memory.htm

    The main advantage of new over malloc() is that new doesn't just allocate memory, it constructs objects which is prime purpose of C++.

80.
How is memory allocated to Vectors
http://stackoverflow.com/questions/12507114/how-does-a-stack-allocated-vector-expand-in-c

    Internally, a vector<string> will most likely consist of a string* pointing at the actual data and probably two more size_t members indicating occupied and reserved memory.
    All the rest will be on the heap.
    Therefore, sizeof(vector<string>) is fixed, and the allocation on the stack won't change.

    std::vector internaly maintains a pointer to heap allocated space that is resized as necessary. The footprint on the stack doesn't change.

http://stackoverflow.com/questions/10366474/where-does-a-stdvector-allocate-its-memory
        Does a std::vector allocate memory for its elements on the heap?
    Yes. Or more accurately it allocates based on the allocator you pass in at construction. You didn't specify one, so you get the default allocator. By default, this will be the heap.

        But how does it free that heap memory?
    Through its destructor when it goes out of scope. (Note that a pointer to a vector going out of scope won't trigger the destructor).

    The main advantage of new over malloc() is that new doesn't just allocate memory, it constructs objects which is prime purpose of C++.

    All containers in the STL are parameterized with template arguments, usually the last argument is called A or Allocator and defaults to std::allocator<...> where ... represents the type of the value stored within the container.

    The Allocator is a class that is used to provide memory and build/destroy the elements in this memory area.
    It can allocate memory from a pool or directly from the heap, whichever you build the allocator from.
    By default the std::allocator<T> is a simple wrapper around ::operator new and will thus allocate memory on the heap as you inferred.

    The memory is allocated on demand, and is deallocated at the very least when the vector's destructor is called.
    C++11 introduces shrink_to_fit to release memory sooner too.
    Finally, when the vector outgrow its current capacity, a new (larger) allocation is made, the objects are moved to it, and the old allocation is released

http://stackoverflow.com/questions/8036474/allocating-vectors-memory-on-heap-or-stack
        vector<Type> vect;
    will allocate the vector, i.e. the header info, on the stack, but the elements on the free store ("heap").

        vector<Type> *vect = new vector<Type>;
    allocates everything on the free store.

        vector<Type*> vect;
    will allocate the vector on the stack and a bunch of pointers on the free store, but where these point is determined by how you use them (you could point element 0 to the free store and element 1 to the stack, say).

NICE LINK ON HOW VECTOR MEMORY ALLOCATION HAPPENS
https://frogatto.com/2009/11/17/how-cs-vector-works-the-gritty-details/

    begin points to the start of the buffer.
    It is fairly easy to understand. You can get it using the begin() member of vector.

    end points to one past the end of the valid, initialized elements of the vector.
    Note that it points one past the end, making it so that end  begin = size. You can retrieve the end pointer using the end() function and the size() function is the same as evaluating end()  begin().
    capacity pointers to one past the end of the buffer.

    Therefore, compared to arrays, vectors consume more memory in exchange for the ability to manage storage and grow dynamically in an efficient way.

What should your store in a Vector
    Built-ins like integers can be stored easily, of course.
    But what about objects of class type?
    Suppose you are programming a particle system and have a particle class, and want to store a long list of particles, what is the best way to do it? One way is to store a vector<particle>, another is to store a vector<particle*>  that is, dont store the particles themselves directly in the vector, but store pointers to particles.

    How do you choose which?
        Generally, the larger and bulkier the object is, the more likely it is you want to store pointers to it, rather than the object itself.
        Storing a vector<int*> would be very inefficient, since the pointers would be as large or larger than the integers and youd have to have the overhead of the memory allocations too.
        But for a large object, like Frogattos custom_object class, a vector<custom_object*> is probably what we want.
        Note that to store an object directly, it must be copyable, i.e. have accessible copy constructors and assignment operators.

81.
Where Global Variables and Pointers are stored
http://stackoverflow.com/questions/3113668/location-of-pointers-and-global-variables-in-c

    Compile
        When a file is compiled, variables with "program duration" (static or global variables) which are defined within that "compilation unit" (in rough terms, the "c file") determine how much global space this program needs, and how it is initialized.

    Link
        When the linker creates your executable, it combines this information and puts it into sections of the executable used for that purpose.
        The linker then goes through and changes all references to that data to where it will put that data in the process's memory space when the program is loaded.
        So the pointers to the global data will be like constants in your source file; no memory needs to be set aside for them.

        For zero-initialized or uninitialized global data, just the amount of space needed for such data is stored. For initialized data, the initial values are stored.

    Load
        When your program is loaded, the loader will look into the program file to tell how much zero-initialized data is needs, and sets aside enough of the process's memory space for it, and initializes it all to binary zero.
        For the initialized data, it sets aside memory for that and initializes it to the initial values saved in the exe file. It also sets aside areas for the heap (used by malloc()) and the stack.

    Dynamic Libraries
        If your code is in a dynamic library, the linker can't know where it will put the global data.
        In this case, it creates sections in the library to tell it where the references to the global data are, and the loader takes care of changing the references to point to the right place when it loads the file (this is why you pass -fPIC on the gcc command line for dlls).
        But since this is done at load time, by the time your program runs the placement of the data is known, so the loader knows where that data will be pointers to global data can still act as constants in your program.

    Dynamic Loading
        If you link dynamically to a dll, the loader doesn't know about it, so you have to call functions which know how to load a dll and get the address of its exported data and functions.

Where are my Varibles stored in memory in  C
http://stackoverflow.com/questions/14588767/where-in-memory-are-my-variables-stored-in-c
    You got some of these right, but whoever wrote the questions tricked you on at least one question:

        global variables -------> data (correct)
        Global Variables - Global variables can be in a couple places, depending on how they're set up - for example, const globals may be in a read-only section of the executable.
        "Normal" globals are in a read-write section of the executable.

        static variables -------> data (correct)

        constant data types -----> code and/or data.
        in the GCC compiler, on most machines, read-only variables, constants, and jump tables are placed in the text section
        Consider string literals for a situation when a constant itself would be stored in the data segment, and references to it would be embedded in the code

        local variables(declared and defined in functions) --------> stack (correct)

        variables declared and defined in main function -----> Also stack (the teacher was trying to trick you)

        pointers(ex: char *arr, int *arr) -------> heap data or stack, depending on the context.
        C lets you declare a global or a static pointer, in which case the pointer itself would end up in the data segment.
        Pointers - Pointers are just a type of variable, so they can be wherever you want them to be (on the heap if you malloc() them, on the stack if they're local variables, or in the data section if they're global).

        dynamically allocated space(using malloc, calloc, realloc) --------> heap

82.
Where are the Variable Names stored
http://stackoverflow.com/questions/14612314/how-are-variable-names-stored-in-memory-in-c
http://www.csee.umbc.edu/~chang/cs313.s02/stack.shtml

    A C compiler first creates a symbol table, which stores the relationship between the variable name and where it's located in memory.
    When compiling, it uses this table to replace all instances of the variable with a specific memory location

    Variable names don't exist anymore after the compiler runs (barring special cases like exported globals in shared libraries or debug symbols).
    The entire act of compilation is intended to take those symbolic names and algorithms represented by your source code and turn them into native machine instructions.
    So yes, if you have a global variable_name, and compiler and linker decide to put it at 0xaaaaaaaa, then wherever it is used in the code, it will just be accessed via that address.

    So to answer your literal questions:

        How does the compiler recognize that the string "variable_name" is associated with that particular memory address?

    The toolchain (compiler & linker) work together to assign a memory location for the variable.
    It's the compiler's job to keep track of all the references, and linker puts in the right addresses later.

        Is the string "variable_name" stored somewhere in memory?

    Only while the compiler is running.

        Does the compiler just substitute variable_name for 0xaaaaaaaa whenever it sees it, and if so, wouldn't it have to use memory in order to make that substitution?

    Yes, that's pretty much what happens, except it's a two-stage job with the linker.
    And yes, it uses memory, but it's the compiler's memory, not anything at runtime for your program.

    An example might help you understand. Let's try out this program:

        int x = 12;

        int main(void)
        {
            return x;
        }

    Pretty straightforward, right? OK. Let's take this program, and compile it and look at the disassembly:
        $ cc -Wall -Werror -Wextra -O3    example.c   -o example
        $ otool -tV example
        example:
        (__TEXT,__text) section
        _main:
        0000000100000f60    pushq   %rbp
        0000000100000f61    movq    %rsp,%rbp
        0000000100000f64    movl    0x00000096(%rip),%eax
        0000000100000f6a    popq    %rbp
        0000000100000f6b    ret

    See that movl line? It's grabbing the global variable (in an instruction-pointer relative way, in this case). No more mention of x.

    Now let's make it a bit more complicated and add a local variable:

        int x = 12;

        int main(void)
        {  
            volatile int y = 4;
            return x + y;
        }

    The disassembly for this program is:
        (__TEXT,__text) section
        _main:
        0000000100000f60    pushq   %rbp
        0000000100000f61    movq    %rsp,%rbp
        0000000100000f64    movl    $0x00000004,0xfc(%rbp)
        0000000100000f6b    movl    0x0000008f(%rip),%eax
        0000000100000f71    addl    0xfc(%rbp),%eax
        0000000100000f74    popq    %rbp
        0000000100000f75    ret

    Now there are two movl instructions and an addl instruction.
    You can see that the first movl is initializing y, which it's decided will be on the stack (base pointer - 4).
    Then the next movl gets the global x into a register eax, and the addl adds y to that value.
    But as you can see, the literal x and y strings don't exist anymore.
    They were conveniences for you, the programmer, but the computer certainly doesn't care about them at execution time.

VERY NICE LINK ON HOW A FUNCTION CALL ACTUALLY HAPPENS
http://www.csee.umbc.edu/~chang/cs313.s02/stack.shtml
    Return Value of More than 4 bytes
        Return values of 4 bytes or less are stored in the EAX register. If a return value with more than 4 bytes is needed, then the caller passes an "extra" first argument to the callee. This extra argument is address of the location where the return value should be stored. I.e., in C parlance the function call:

           x = foo(a, b, c) ;

        is transformed into the call:

           foo(&x, a, b, c) ;

83.
What is Type Safe
http://stackoverflow.com/questions/260626/what-is-type-safe
http://stackoverflow.com/questions/2140369/what-is-type-safety-and-what-are-the-type-safe-alternatives

    Type safety means that the compiler can check whether you're using the right types.
    For example, if you're using printf, you could accidentally crash your program by writing this:
        printf("The meaning of life is %s", 42);
    because 42 is an integer, not a string

    when you call memcpy, the function (and compiler) only sees two pointers in memory, and will happily start copying data. This means you can mix incompatible data types like this:
        SomeClass a;
        AnotherClass b;
        memcpy((void*)&a, (void*)&b, sizeof(b));

    Type safety means that the compiler will validate types while compiling, and throw an error if you try to assign the wrong type to a variable.
    Some simple examples:
        // Fails, Trying to put an integer in a string
        String one = 1;
        // Also fails.
        int foo = "bar";

    This also applies to method arguments, since you are passing explicit types to them:
        int AddTwoNumbers(int a, int b)
        {
            return a + b;
        }

    If I tried to call that using:
        int Sum = AddTwoNumbers(5, "5");

    The compiler would throw an error, because I am passing a string ("5"), and it is expecting an integer.

84.
What is the name of the --> operator
http://stackoverflow.com/questions/1642028/what-is-the-name-of-the-operator?rq=1

    while (x --> 0) // x goes to 0

    --> is not an operator. It is in fact two separate operators, -- and >.
    while( (x--) > 0 )

85.
Why is ::operator new[] necessary when ::operator new is enough
http://stackoverflow.com/questions/24603142/why-is-operator-new-necessary-when-operator-new-is-enough?rq=1

    ::operator new[] and ~delete[] facilitate memory usage debugging, being a central point to audit allocation and deallocation operations;
    you can then ensure the array form is used for both or neither.

    operator new can reasonably expect that an object will be constructed at the exact address returned, but operator new[] cannot.
    The first bytes of the allocation block might be used for a size "cookie", the array might be sparsely initialized, etc.

86.
Allocator vs New
http://stackoverflow.com/questions/5628059/c-stl-allocator-vs-operator-new

    For general programming, yes you should use new and delete.

    However, if you are writing a library, you should not! I don't have your textbook, but I imagine it is discussing allocators in the context of writing library code.

    Users of a library may want control over exactly what gets allocated from where.
    If all of the library's allocations went through new and delete, the user would have no way to have that fine-grained level of control.

    All STL containers take an optional allocator template argument.
    The container will then use that allocator for its internal memory needs.
    By default, if you omit the allocator, it will use std::allocator which uses new and delete (specifically, ::operator new(size_t) and ::operator delete(void*)).

    This way, the user of that container can control where memory gets allocated from if they desire.

http://stackoverflow.com/questions/31358804/whats-the-advantage-of-using-stdallocator-instead-of-new-in-c
    new T[N] doesn't allow you control over what constructors are called.
    And it forces you to construct all your objects at the same time.
    This is terrible for the purposes of, for example, std::vector where you only want to allocate occasionally.

    With a raw memory allocator, you can allocate a certain amount of memory, which determines your capacity.
    Then, as the user adds items to the vector (using the constructor of their choice), you can construct objects in place in this memory.

    sometimes you want to separate allocation and construction into two steps (and similarly to separate destruction and deallocation into two steps).
    If you don't want to do that, don't use an allocator, use new instead.

Q. In which cases can it be used and when should it be used instead of new and delete?

    When you need the behaviour of an allocator, not the behaviour of new and delete, obviously! The typical case is when implementing a container.

    Consider the following code:
        std::vector<X> v;
        v.reserve(4);        // (1)
        v.push_back( X{} );  // (2)
        v.push_back( X{} );  // (3)
        v.clear();           // (4)

    Here line (1) must allocate enough memory for four objects, but not construct them yet.
    Then lines (2) and (3) must construct objects into the allocated memory.
    Then line (4) must destroy those objects, but not deallocate the memory. Finally, in the vector's destructor, all the memory can be deallocated.

    So the vector cannot just use new X() or delete &m_data[1] to create and destroy the objects, it must perform allocation/deallocation separately from construction/destruction.
    A container's allocator template argument defines the policy that should be used for (de)allocating memory and constructing/destructing objects, allowing the container's use of memory to be customised.
    The default policy is the std::allocator type.

    So you use an allocator when an allocator is required (such as when using a container) and you use std::allocator when you don't want to provide a custom allocator and just want the standard one.

    You don't use an allocator as a replacement for new and delete

87. 
What is RTTI and Why is it necessary

    Run-time type information (RTTI) is a mechanism that allows the type of an object to be determined during program execution.

    There are three main C++ language elements to run-time type information:
    1. The dynamic_cast operator.
       Used for conversion of polymorphic types.

    2. The typeid operator.
       Used for identifying the exact type of an object.

    3. The type_info class.
       Used to hold the type information returned by the typeid operator.

http://stackoverflow.com/questions/18590086/use-of-rtti-in-c
    It enables you to identify the dynamic type of a object at run time.
    You can use it when checking post-condtions:

        class Clonable
        {
            virtual Clonable* doClone() const = 0;
        public:
            Clonable* clone() const
            {
                Clonable* results = doClone();
                assert( typeid(*results) == typeid(*this) );
                return results;
            }
        };

    It can also be used as an index into a map of factory functions: in C++11, you have std::type_index with which you can wrap it; in earlier versions, you wrote your own:

        std::map<std::type_index, Base* (*)()> factoryMap;

    The fact that the output of std::type_info::name() isn't specified, however, limits its utility much more that one would like.


    Here is an example: Sometimes you would want to (though you should avoid to) downcast polymorphic objects. In many cases, you do not know at compile time whether this cast will be valid every time you do it:

        struct Base { virtual ~Base() {} };
        struct A : Base {};
        struct B : Base {};

        void foo(Base * base)
        {
            A * a = dynamic_cast<A *>(base); // RTTI magic here!
            if(a != nullptr)
            {
                // do something with a
            }
        }

    Notice that RTTI comes at the cost of runtime checks and thus performance loss, but you probably already know that if you are familiar with the concept.


88.
When to use static methods
http://stackoverflow.com/questions/2671496/java-when-to-use-static-methods

    So in a class Car you might have a method double convertMpgToKpl(double mpg) which would be static, because one might want to know what 35mpg converts to, even if nobody has ever built a Car.
    But void setMileage(double mpg) (which sets the efficiency of one particular Car) can't be static since it's inconceivable to call the method before any Car has been constructed.

89.
Freeing memory twice
http://stackoverflow.com/questions/2468853/freeing-memory-twice
http://stackoverflow.com/questions/3117615/why-free-crashes-when-called-twice

    Freeing memory does not set the pointer to null.
    The pointer remains pointing to the memory it used to own, but which has now had ownership transferred back to the heap manager.
    The heap manager may have since reallocated the memory your stale pointer is pointing to.

        thread A allocated and freed memory at address 42.
        thread B allocated memory a address 42 and started using it.
        thread A freed that memory a second time.
        thread C allocated memory a address 42 and started using it.

        Malloc some memory -- adds the bookkeeping data.
        Free it -- memory is returned to pool.
        You or someone else malloc's some more memory, which might or might not include or line up with the old allocation.
        You free the old pointer again.

90.
C++ Memory management
New operator vs Operator new 
http://www.bogotobogo.com/cplusplus/memoryallocation.php

    1. new operator:
        - It allocates enough memory to hold an object of the type requested.
        - It calls a constructor to initialize an object in the memory that was allocated.


    So, what function is the new calling?
    It is operator new.
        void * operator new (size_t size);

    The return type is void*.
    Since this function returns a pointer to raw which is not typed and uninitialized memory large enough to hold an object of the specified type.
    The size_t specifies how much memory to allocate.

    It's rare but there is a chance we may want to call operator new directly.
        void *pRawMemory = operator new(sizeof(string));


    Operator New:
        The operator new returns a pointer to a chunk of memory enough to hole a string object.
        The operator new is similar to malloc in that it's responsible only for allocating memory.
        It knows nothing about constructors.
        All operator new understands is memory allocation. That's it. 

Delete Operator and Operator Delete 
    When we use a delete expression to delete a dynamically allocated object:
        delete ptr;

    two things happen.
    First, the appropriate destructor is run on the object to which ptr points.
    Then, the memory used by the object is freed by calling a operator delete function.

    Overloaded versions of operator new and operator delete
        Note that operator new and operator delete apply only to allocations for single objects.
        Memory for array is allocated by operator new[] and deallocated by operator delete[].
        Also note that heap memory for STL containers is managed by the containers' allocator objects, not by new and delete directly.

        There are two overloaded versions of operator new and operator delete functions:

        void *operator new(size_t);	// allocate an object
        void *perator new[](size_t);  	// allocate an array

        void *operator delete(void*);	// free an object
        void *perator delete[](void*); 	// free an array

    Malloc vs New
        Malloc just allocates memory. New allocates memory as well as constructs the object
91.
STACK VS HEAP
http://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap?rq=1

    Each thread gets a stack, while there's typically only one heap for the application (although it isn't uncommon to have multiple heaps for different types of allocation).

    Q. What is their scope?
        The stack is attached to a thread, so when the thread exits the stack is reclaimed.
        The heap is typically allocated at application startup by the runtime, and is reclaimed when the application (technically process) exits

    Q. What determines the size of each of them?
        The size of the stack is set when a thread is created.
        The size of the heap is set on application startup, but can grow as space is needed (the allocator requests more memory from the operating system).

    Q. What makes one faster?

        The stack is faster because the access pattern makes it trivial to allocate and deallocate memory from it (a pointer/integer is simply incremented or decremented),
        while the heap has much more complex bookkeeping involved in an allocation or free.

        Also, each byte in the stack tends to be reused very frequently which means it tends to be mapped to the processor's cache, making it very fast.
        Another performance hit for the heap is that the heap, being mostly a global resource, typically has to be multi-threading safe,
        i.e. each allocation and deallocation needs to be - typically - synchronized with "all" other heap accesses in the program.

92.
Different behavior of Code Valid in C and C++
http://stackoverflow.com/questions/12887700/can-code-that-is-valid-in-both-c-and-c-produce-different-behavior-when-compile?rq=1

        #include <stdio.h>

        int  sz = 80;

        int main(void)
        {
            struct sz { char c; };

            int val = sizeof(sz);      // sizeof(int) in C,
                                       // sizeof(struct sz) in C++
            printf("%d\n", val);
            return 0;
        }

        #include <stdio.h>

        struct f { };

        int main() {
            f();
        }

        int f() {
            return printf("hello");
        }

    In C++ this will print nothing because a temporary f is created and destroyed, but in C it will print hello because functions can be called without having been declared.

    In case you were wondering about the name f being used twice, the C and C++ standards explicitly allows this, and to make an object you have to say struct f to disambiguate if you want the structure, or leave off struct if you want the function.

93.
Case Only Labels: Jumping over initialization
http://stackoverflow.com/questions/92396/why-cant-variables-be-declared-in-a-switch-statement?rq=1

    Case statements are only 'labels'.
    This means the compiler will interpret this as a jump directly to the label.
    In C++, the problem here is one of scope.
    Your curly brackets define the scope as everything inside the 'switch' statement.
    This means that you are left with a scope where a jump will be performed further into the code skipping the initialization.
    The correct way to handle this is to define a scope specific to that case statement and define your variable within it.

        switch (val)
        {   
        case VAL:  
        {
          // This will work
          int newVal = 42;  
          break;
        }
        case ANOTHER_VAL:  
        ...
        break;
        }

94.
What uses are there for placement new?
http://stackoverflow.com/questions/222557/what-uses-are-there-for-placement-new?rq=1

    We use it with custom memory pools.

    Placement new allows you to construct an object on memory that's already allocated.

    You may want to do this for optimizations (it is faster not to re-allocate all the time) but you need to re-construct an object multiple times.
    If you need to keep re-allocating it might be more efficient to allocate more than you need, even though you don't want to use it yet.

    Devex gives a good example:

        Standard C++ also supports placement new operator, which constructs an object on a pre-allocated buffer.
        This is useful when building a memory pool, a garbage collector or simply when performance and exception safety are paramount (there's no danger of allocation failure since the memory has already been allocated, and constructing an object on a pre-allocated buffer takes less time):

        char *buf  = new char[sizeof(string)]; // pre-allocated buffer
        string *p = new (buf) string("hi");    // placement new
        string *q = new string("hi");          // ordinary heap allocation

    You may also want to be sure there can be no allocation failure at a certain part of critical code (maybe you work on a pacemaker for example).
    In that case you would want to use placement new.

    Deallocation in placement new:
        You should not deallocate every object that is using the memory buffer.
        Instead you should delete[] only the original buffer. You would have to then call the destructors directly of your classes manually.

95.
Is there a "placement delete"?
http://www.stroustrup.com/bs_faq2.html#placement-delete

    No, but if you need one you can write your own.

    Consider placement new used to place objects in a set of arenas
            class Arena {
            public:
                    void* allocate(size_t);
                    void deallocate(void*);
                    // ...
            };

            void* operator new(size_t sz, Arena& a)
            {
                    return a.allocate(sz);
            }

            Arena a1(some arguments);
            Arena a2(some arguments);

    Given that, we can write

            X* p1 = new(a1) X;
            Y* p2 = new(a1) Y;
            Z* p3 = new(a2) Z;
            // ...

    But how can we later delete those objects correctly? The reason that there is no built-in "placement delete" to match placement new is that there is no general way of assuring that it would be used correctly. Nothing in the C++ type system allows us to deduce that p1 points to an object allocated in Arena a1. A pointer to any X allocated anywhere can be assigned to p1.

    However, sometimes the programmer does know, and there is a way:

            template<class T> void destroy(T* p, Arena& a)
            {
                    if (p) {
                            p->~T();		// explicit destructor call
                            a.deallocate(p);
                    }
            }

    Now, we can write:

            destroy(p1,a1);
            destroy(p2,a2);
            destroy(p3,a3);

    If an Arena keeps track of what objects it holds, you can even write destroy() to defend itself against mistakes.

96.
Auto, Unique, Shared Pointers, Weak Pointers and Scoped Pointers
    auto_ptr, unique_ptr and shared_ptr

97.
Vector - Accessing member elements using "at()" vs "[]"
http://stackoverflow.com/questions/9376049/vectorat-vs-vectoroperator
    Vector.at() is SLOWER than vector[]

    IMP: Use vector.at() when INDEX is not in your control.

98.
Created Vectors of User defined size
http://stackoverflow.com/questions/10559283/how-to-create-a-vector-of-user-defined-size

    // create a vector with 20 integer elements
    std::vector<int> arr(20);

99.
How to use memset or fill_n to initialize a dynamic two dimensional array in C++
http://stackoverflow.com/questions/36506331/how-to-use-memset-or-fill-n-to-initialize-a-dynamic-two-dimensional-array-in-c

    1.
    I think that your main problem here is that you don't have an array of int values.
    You have an array of pointers to ints.

    You probably should start with int* abc = new int[rows * cols]; and work from there, if I understand what you are trying to achieve here.

    2.
        int **abc = new int*[rows];
        for (uint32_t i = 0; i < rows; i++)
        {
            abc[i] = new int[cols];
            std::fill_n(abc[i], cols, 1);
        }
    
100.
Unique Lock
http://www.cplusplus.com/reference/mutex/unique_lock/

    A unique lock is an object that manages a mutex object with unique ownership in both states: locked and unlocked.

    On construction (or by move-assigning to it), the object acquires a mutex object, for whose locking and unlocking operations becomes responsible.

    The object supports both states: locked and unlocked.

    This class guarantees an unlocked status on destruction (even if not called explicitly). Therefore it is especially useful as an object with automatic duration, as it guarantees the mutex object is properly unlocked in case an exception is thrown.

101.
Condition Variable
http://www.cplusplus.com/reference/condition_variable/condition_variable/wait/
    wait()
    notify_one()

102.
Lock_guard vs Unique_lock
http://stackoverflow.com/questions/20516773/stdunique-lockstdmutex-or-stdlock-guardstdmutex

    lock_guard and unique_lock are pretty much the same thing; lock_guard is a restricted version with a limited interface.

    A lock_guard always holds a lock from its construction to its destruction.
    A lock_guard can't transfer ownership of a lock
    A unique_lock can be created without immediately locking, can unlock at any point in its existence, and can transfer ownership of the lock from one instance to another.

    So you always use lock_guard, unless you need the capabilities of unique_lock.
    A condition_variable needs a unique_lock.

103.
Recursive Mutex
    The same lock can be obtained by the same thread multiple times.

104.
Lock vs Mutex vs Condition Variable
http://stackoverflow.com/questions/1055398/differences-between-conditional-variables-mutexes-and-locks

    "mutex" is the actual low-level synchronizing primitive.
    You can take a mutex and then release it, and only one thread can take it at any single time (hence it is a synchronizing primitive).
    A recursive mutex is one which can be taken by the same thread multiple times, and then it needs to be released as many times by the same thread before others can take it.

    A "lock" here is just a C++ wrapper class that takes a mutex in its constructor and releases it at the destructor.
    It is useful for establishing synchronizing for C++ scopes.

    A condition variable is a more advanced / high-level form of synchronizing primitive which combines a lock with a "signaling" mechanism.
    It is used when threads need to wait for a resource to become available.
    A thread can "wait" on a CV and then the resource producer can "signal" the variable, in which case the threads who wait for the CV get notified and can continue execution.
    A mutex is combined with CV to avoid the race condition where a thread starts to wait on a CV at the same time another thread wants to signal it; then it is not controllable whether the signal is delivered or gets lost.

105.
Need for THIS Pointer
http://stackoverflow.com/questions/577243/is-there-any-reason-to-use-this
    1. When the name of the formal argument is same as actual argument.
    2. For templates

    The only place where it really makes a difference is in templates in derived classes:

        template<typename T>
        class A {
        protected:
          T x;
        };

        template<typename T>
        class B : A<T> {
        public:
          T get() {
            return this->x;
          }
        };

    Due to details in the name lookup in C++ compilers, it has to be made explicitly clear that x is a (inherited) member of the class, most easily done with this->x.
    But this is a rather esoteric case, if you don't have templated class hierarchies you don't really need to explicitly use this to access members of a class.

106.
Sort Unordered Map
http://stackoverflow.com/questions/24212356/why-stl-unordered-map-and-unordered-set-cannot-be-sorted-by-stl-algorithms

    unordered containers store internally hashed data and thus it's not possible to order them after the hash has been generated.

    In order to sort the data you can use an additional non-hashed container (e.g. map or set) and either use them along with the unordered version (so you can use the normal one to sort the data and the unordered one to have fast per-item access) or you can do something like

    std::map<int, int> ordered(unordered.begin(), unordered.end());
    for(auto it = ordered.begin(); it != ordered.end(); ++it)
         std::cout << it->second;

107.
IMP: Using [] operator in unordered_map inserts the element if not present.
http://www.cplusplus.com/reference/unordered_map/unordered_map/operator[]/
    
    If k matches the key of an element in the container, the function returns a reference to its mapped value.

    If k does not match the key of any element in the container, the function inserts a new element with that key and returns a reference to its mapped value.
    Notice that this always increases the container size by one, even if no mapped value is assigned to the element (the element is constructed using its default constructor).

    IMP: Use .at() method instead

108. 
Create a vector of userdefined size and initialize with default values

    vector<int32_t> sumArr1(divNum, 0);
    vector<uint32_t> sumArr1(4, 0);

109.
Copy from one vector to another
http://stackoverflow.com/questions/644673/fast-way-to-copy-one-vector-into-another

    1) vector a = b;
    2) vector<int> new_(original);

110.
Copy Constructor vs Assignment Operator:
    A copy constructor is used to initialize a previously uninitialized object from some other object's data.

    A(const A& rhs) : data_(rhs.data_) {}

    An assignment operator is used to replace the data of a previously initialized object with some other object's data.

    A& operator=(const A& rhs) {data_ = rhs.data_; return *this;}

    Copy constructor is called when a new object is created from an existing object, as a copy of the existing object (see this G-Fact). And assignment operator is called when an already initialized object is assigned a new value from another existing object.
    t2 = t1;  // calls assignment operator, same as "t2.operator=(t1);"
    Test t3 = t1;  // calls copy constructor, same as "Test t3(t1);"

111.
Volatile keyword:
http://stackoverflow.com/questions/246127/why-is-volatile-needed-in-c

112.
How do you declare an interface in C++
    Make a class with pure virtual methods. Use the interface by creating another class that overrides those virtual methods.

    class IDemo
    {
        public:
            virtual ~IDemo() {}
            virtual void OverrideMe() = 0;
    }

    class Child : public IDemo
    {
        public:
            virtual void OverrideMe()
            {
                //do stuff
            }
    }   

113.
Multiple Inheritence in C++
http://www.geeksforgeeks.org/multiple-inheritance-in-c/
    IT creates the Diamond problem.
         A
        /  \
       B    C
        \  /
         D

    - Can be solved by making the BASE class virtual.

114.
Exception handling in C++
http://stackoverflow.com/questions/7480146/difference-between-exception-handling-in-c-and-java
    Question:
        In Java, if a specific line of code causes the program to crash, then the exception is caught and the program continues to execute.

        However, in C++, if I have a piece of code that causes the program to crash, like:

        try
        {
            int x = 6;
            int *p = NULL;
            p = reinterpret_cast<int*>(x);

            *p = 10; // the program crashed here

            cout << "x = " << *p << endl;
        }
        catch(const char* Message)
        {
            cout << "There is an run-time error";
        }

        Then the program still crash and the exception is not caught

    Answer:
        The line that crashes is dereferencing an invalid pointer.
        In C++ this will not throw an exception. Instead it is undefined behaviour.

        There's no such thing as a null pointer exception in C++, unlike Java which will throw a null pointer exception.
        Instead dereferencing an invalid pointer will lead to undefined behaviour.

    How to use exception in C++ - Example
      try
      {
        int* myarray= new int[1000];
      }
      catch (exception& e)
      {
        cout << "Standard exception: " << e.what() << endl;
      }

115.
Side effects of macros:
https://gcc.gnu.org/onlinedocs/cpp/Duplication-of-Side-Effects.html

        Many C programs define a macro min, for minimum, like this:
         #define min(X, Y)  ((X) < (Y) ? (X) : (Y))

        When you use this macro with an argument containing a side effect, as shown here,
         next = min (x + y, foo (z));

        it expands as follows:
         next = ((x + y) < (foo (z)) ? (x + y) : (foo (z)));

        foo (z) gets executed twice.

116.
Macros vs Inline Function:
http://stackoverflow.com/questions/1137575/inline-functions-vs-preprocessor-macros

    - Macros are not type safe, and can be expanded regardless of whether they are syntatically correct - the compile phase will report errors resulting from macro expansion problems.
    - Macros can be used in context where you don't expect, resulting in problems
    - Macros are more flexible, in that they can expand other macros - whereas inline functions don't necessarily do this.
    - Macros can result in side effects because of their expansion, since the input expressions are copied wherever they appear in the pattern.
    - Inline function are not always guaranteed to be inlined - some compilers only do this in release builds, or when they are specifically configured to do so. Also, in some cases inlining may not be possible.
    - Inline functions can provide scope for variables (particularly static ones), preprocessor macros can only do this in code blocks {...}, and static variables will not behave exactly the same way.
 
117.
What is Arithmetic Overflow and Underflow
http://stackoverflow.com/questions/6360049/what-are-arithmetic-underflow-and-overflow-in-c

    The situation where an integer outside the allowed range requires more bits than can be stored is called an overflow.

    Underflow
        Similarly, with real numbers, an exponent that is too small to be stored causes an underflow.

        The condition in a computer program that can occur when the true result of a floating point operation is smaller in magnitude (that is, closer to zero) than the smallest value representable as a normal floating point number in the target datatype.

118.
How to detect integer overflow in C/C++
http://stackoverflow.com/questions/199333/how-to-detect-integer-overflow-in-c-c
http://www.cplusplus.com/articles/DE18T05o/

    Overflow can only occur when sign of numbers being added is the same (which will always be the case in unsigned numbers)
    signed overflow can be easily detected by seeing that its sign is opposite to that of the operands.

    For addition, any two operands will result in (at most) one bit more than the largest operand's highest one-bit. For example:
        bool addition_is_safe(uint32_t a, uint32_t b) {
            size_t a_bits=highestOneBitPosition(a), b_bits=highestOneBitPosition(b);
            return (a_bits<32 && b_bits<32);
        }

    For multiplication, any two operands will result in (at most) the sum of the bits of the operands. For example:
        bool multiplication_is_safe(uint32_t a, uint32_t b) {
            size_t a_bits=highestOneBitPosition(a), b_bits=highestOneBitPosition(b);
            return (a_bits+b_bits<=32);
        }

    Similarly, you can estimate the maximum size of the result of a to the power of b like this:
        bool exponentiation_is_safe(uint32_t a, uint32_t b) {
            size_t a_bits=highestOneBitPosition(a);
            return (a_bits*b<=32);
        }

    (Substitute the number of bits for your target integer, of course.)

    I'm not sure of the fastest way to determine the position of the highest one-bit in a number, here's a brute-force method:
        size_t highestOneBitPosition(uint32_t a) {
            size_t bits=0;
            while (a!=0) {
                ++bits;
                a>>=1;
            };
            return bits;
        }

119.
Usage of Templates Function and Class
http://www.codeproject.com/Articles/257589/An-Idiots-Guide-to-Cplusplus-Templates-Part#ClassTempl

    // Read a request
    GetData<DataType>(&_chain, sizeof(header), resultData);

    template<class T>
    int GetData(Chain* chain, uint32_t offset, T*& pStruct)
    {
        uint8_t* pData = NULL;

        Chk(chain->getDataVolatile(offset, sizeof(T), pData));
        pStruct = reinterpret_cast<T*>(pData);
    }

120.
Passing a 2D array to a C++ function
http://stackoverflow.com/questions/8767166/passing-a-2d-array-to-a-c-function

    FIXED SIZE

    1. Pass by reference

        template <size_t rows, size_t cols>
        void process_2d_array_template(int (&array)[rows][cols])
        {
            std::cout << __func__ << std::endl;
            for (size_t i = 0; i < rows; ++i)
            {
                std::cout << i << ": ";
                for (size_t j = 0; j < cols; ++j)
                    std::cout << array[i][j] << '\t';
                std::cout << std::endl;
            }
        }

        In C++ passing the array by reference without losing the dimension information is probably the safest, since one needn't worry about the caller passing an incorrect dimension (compiler flags when mismatching).
        However, this isn't possible with dynamic (freestore) arrays; it works for automatic (usually stack-living) arrays only i.e. the dimensionality should be known at compile time.

    2. Pass by pointer

        void process_2d_array_pointer(int (*array)[5][10])
        {
            std::cout << __func__ << std::endl;
            for (size_t i = 0; i < 5; ++i)
            {
                std::cout << i << ": ";
                for (size_t j = 0; j < 10; ++j)
                    std::cout << (*array)[i][j] << '\t';
                std::cout << std::endl;
            }    
        }

    The C equivalent of the previous method is passing the array by pointer.
    This should not be confused with passing by the array's decayed pointer type (3), which is the common, popular method, albeit less safe than this one but more flexible.
    Like (1), use this method when all the dimensions of the array is fixed and known at compile-time.
    Note that when calling the function the array's address should be passed process_2d_array_pointer(&a) and not the address of the first element by decay process_2d_array_pointer(a)

    Variable Size

    These are inherited from C but are less safe, the compiler has no way of checking, guaranteeing that the caller is passing the required dimensions.
    The function only banks on what the caller passes in as the dimension(s).
    These are more flexible than the above ones since arrays of different lengths can be passed to them invariably.

    It is to be remembered that there's no such thing as passing an array directly to a function in C [while in C++ they can be passed as a reference (1)]; (2) is passing a pointer to the array and not the array itself.
    Always passing an array as-is becomes a pointer-copy operation which is facilitated by array's nature of decaying into a pointer.

    3. Pass by (value) a pointer to the decayed type

        // int array[][10] is just fancy notation for the same thing
        void process_2d_array(int (*array)[10], size_t rows)
        {
            std::cout << __func__ << std::endl;
            for (size_t i = 0; i < rows; ++i)
            {
                std::cout << i << ": ";
                for (size_t j = 0; j < 10; ++j)
                    std::cout << array[i][j] << '\t';
                std::cout << std::endl;
            }
        }

    Although int array[][10] is allowed, I'd not recommend it over the above syntax since the above syntax makes it clear that the identifier array is a single pointer to an array of 10 integers, while this syntax looks like it's a 2D array but is the same pointer to an array of 10 integers.
    Here we know the number of elements in a single row (i.e. the column size, 10 here) but the number of rows is unknown and hence to be passed as an argument.
    In this case there's some safety since the compiler can flag when a pointer to an array with second dimension not equal to 10 is passed.
    The first dimension is the varying part and can be omitted.

    4. Pass by pointer to a pointer

        // int *array[10] is just fancy notation for the same thing
        void process_pointer_2_pointer(int **array, size_t rows, size_t cols)
        {
            std::cout << __func__ << std::endl;
            for (size_t i = 0; i < rows; ++i)
            {
                std::cout << i << ": ";
                for (size_t j = 0; j < cols; ++j)
                    std::cout << array[i][j] << '\t';
                std::cout << std::endl;
            }
        }

    Again there's an alternative syntax of int *array[10] which is the same as int **array.
    In this syntax the [10] is ignored as it decays into a pointer thereby becoming int **array.
    Perhaps it is just a cue to the caller that the passed array should have at least 10 columns, even then row count is required.
    In any case the compiler doesn't flag for any length/size violations (it only checks if the type passed is a pointer to pointer), hence requiring both row and column counts as parameter makes sense here.

    Note: (4) is the least safest option since it hardly has any type check and the most inconvenient.
    One cannot legitimately pass a 2D array to this function; C-FAQ condemns the usual workaround of doing int x[5][10]; process_pointer_2_pointer((int**)&x[0][0], 5, 10); as it may potentially lead to undefined behaviour due to array flattening.
    The right way of passing an array in this method brings us to the inconvenient part i.e. we need an additional (surrogate) array of pointers with each of its element pointing to the respective row of the actual, to-be-passed array; this surrogate is then passed to the function (see below); all this for getting the same job done as the above methods which are more safer, cleaner and perhaps faster.

121.
Custom Comparator for Priority Queue
http://stackoverflow.com/questions/16111337/declaring-a-priority-queue-in-c-with-a-custom-comparator
http://stackoverflow.com/questions/20826078/priority-queue-comparison

        double computeDistanceFromOrigin(int x, int y)
        {
            return sqrt(((double)x * x) + ((double)y * y));
        }

        bool compGreater(pair<int, int> x, pair<int, int> y)
        {
            return computeDistanceFromOrigin(x.first, x.second) < computeDistanceFromOrigin(y.first, y.second);
        }

        void findKclosestPoints(vector<pair<int, int> >& pointsList, uint32_t k)
        {
            priority_queue< pair<int, int>, vector<pair<int, int> >, std::function<bool(pair<int, int>, pair<int, int>)> > kClosest(compGreater);
            uint32_t i = 0;
            for (; i < k; i++)
            {
                kClosest.push(pointsList[i]);
            }
        }

122.
C++ Erase vector element by value rather than by position
http://stackoverflow.com/questions/3385229/c-erase-vector-element-by-value-rather-than-by-position

        5 9 2 8 0 7

        #include <algorithm>
        ...
        vec.erase(std::remove(vec.begin(), vec.end(), 8), vec.end());

    Take a look at the description of remove(): It moves all values not equal to the value passed to the beginning of the range [begin,end).
    With your example in the question you'd get 5,9,2,0,7,7.
    As remove() however returns an iterator to the new end, vec.erase() can remove the obsolete elements (i.e. the second 7 here) if that is needed.


To Read
http://stackoverflow.com/questions/19470873/why-does-gcc-generate-15-20-faster-code-if-i-optimize-for-size-instead-of-speed?rq=1
http://stackoverflow.com/questions/12264970/why-is-my-program-slow-when-looping-over-exactly-8192-elements?rq=1
http://stackoverflow.com/questions/8547778/why-is-one-loop-so-much-slower-than-two-loops?rq=1
